{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/uploadthing/node_modules/effect/dist/esm/internal/core-effect.js","sources":["file:///D:/840%20G3/7th%20semester/FSPM/Trackly/Trackly/node_modules/uploadthing/node_modules/effect/src/internal/core-effect.ts"],"sourcesContent":["import * as Arr from \"../Array.js\"\nimport type * as Cause from \"../Cause.js\"\nimport * as Chunk from \"../Chunk.js\"\nimport * as Clock from \"../Clock.js\"\nimport * as Context from \"../Context.js\"\nimport * as Duration from \"../Duration.js\"\nimport type * as Effect from \"../Effect.js\"\nimport type { Exit } from \"../Exit.js\"\nimport type * as Fiber from \"../Fiber.js\"\nimport type * as FiberId from \"../FiberId.js\"\nimport type * as FiberRef from \"../FiberRef.js\"\nimport * as FiberRefs from \"../FiberRefs.js\"\nimport type * as FiberRefsPatch from \"../FiberRefsPatch.js\"\nimport type { LazyArg } from \"../Function.js\"\nimport { constFalse, constTrue, constVoid, dual, identity, pipe } from \"../Function.js\"\nimport * as HashMap from \"../HashMap.js\"\nimport * as HashSet from \"../HashSet.js\"\nimport * as List from \"../List.js\"\nimport * as LogLevel from \"../LogLevel.js\"\nimport * as LogSpan from \"../LogSpan.js\"\nimport type * as Metric from \"../Metric.js\"\nimport type * as MetricLabel from \"../MetricLabel.js\"\nimport * as Option from \"../Option.js\"\nimport * as Predicate from \"../Predicate.js\"\nimport type * as Random from \"../Random.js\"\nimport * as Ref from \"../Ref.js\"\nimport type * as runtimeFlagsPatch from \"../RuntimeFlagsPatch.js\"\nimport * as Tracer from \"../Tracer.js\"\nimport type * as Types from \"../Types.js\"\nimport type { Unify } from \"../Unify.js\"\nimport { internalCall } from \"../Utils.js\"\nimport * as internalCause from \"./cause.js\"\nimport { clockTag } from \"./clock.js\"\nimport * as core from \"./core.js\"\nimport * as defaultServices from \"./defaultServices.js\"\nimport * as doNotation from \"./doNotation.js\"\nimport * as fiberRefsPatch from \"./fiberRefs/patch.js\"\nimport type { FiberRuntime } from \"./fiberRuntime.js\"\nimport * as metricLabel from \"./metric/label.js\"\nimport * as runtimeFlags from \"./runtimeFlags.js\"\nimport * as internalTracer from \"./tracer.js\"\n\n/* @internal */\nexport const annotateLogs = dual<\n  {\n    (key: string, value: unknown): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n    (\n      values: Record<string, unknown>\n    ): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  },\n  {\n    <A, E, R>(effect: Effect.Effect<A, E, R>, key: string, value: unknown): Effect.Effect<A, E, R>\n    <A, E, R>(effect: Effect.Effect<A, E, R>, values: Record<string, unknown>): Effect.Effect<A, E, R>\n  }\n>(\n  (args) => core.isEffect(args[0]),\n  function<A, E, R>() {\n    const args = arguments\n    return core.fiberRefLocallyWith(\n      args[0] as Effect.Effect<A, E, R>,\n      core.currentLogAnnotations,\n      typeof args[1] === \"string\"\n        ? HashMap.set(args[1], args[2])\n        : (annotations) =>\n          Object.entries(args[1] as Record<string, unknown>).reduce(\n            (acc, [key, value]) => HashMap.set(acc, key, value),\n            annotations\n          )\n    )\n  }\n)\n\n/* @internal */\nexport const asSome = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<Option.Option<A>, E, R> =>\n  core.map(self, Option.some)\n\n/* @internal */\nexport const asSomeError = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<A, Option.Option<E>, R> =>\n  core.mapError(self, Option.some)\n\n/* @internal */\nexport const try_: {\n  <A, E>(options: {\n    readonly try: LazyArg<A>\n    readonly catch: (error: unknown) => E\n  }): Effect.Effect<A, E>\n  <A>(thunk: LazyArg<A>): Effect.Effect<A, Cause.UnknownException>\n} = <A, E>(\n  arg: LazyArg<A> | {\n    readonly try: LazyArg<A>\n    readonly catch: (error: unknown) => E\n  }\n) => {\n  let evaluate: LazyArg<A>\n  let onFailure: ((error: unknown) => E) | undefined = undefined\n  if (typeof arg === \"function\") {\n    evaluate = arg\n  } else {\n    evaluate = arg.try\n    onFailure = arg.catch\n  }\n  return core.suspend(() => {\n    try {\n      return core.succeed(internalCall(evaluate))\n    } catch (error) {\n      return core.fail(\n        onFailure\n          ? internalCall(() => onFailure(error))\n          : new core.UnknownException(error, \"An unknown error occurred in Effect.try\")\n      )\n    }\n  })\n}\n\n/* @internal */\nexport const _catch: {\n  <N extends keyof E, K extends E[N] & string, E, A1, E1, R1>(\n    discriminator: N,\n    options: {\n      readonly failure: K\n      readonly onFailure: (error: Extract<E, { [n in N]: K }>) => Effect.Effect<A1, E1, R1>\n    }\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<\n    A | A1,\n    Exclude<E, { [n in N]: K }> | E1,\n    R | R1\n  >\n  <A, E, R, N extends keyof E, K extends E[N] & string, A1, E1, R1>(\n    self: Effect.Effect<A, E, R>,\n    discriminator: N,\n    options: {\n      readonly failure: K\n      readonly onFailure: (error: Extract<E, { [n in N]: K }>) => Effect.Effect<A1, E1, R1>\n    }\n  ): Effect.Effect<A | A1, Exclude<E, { [n in N]: K }> | E1, R | R1>\n} = dual(\n  3,\n  (self, tag, options) =>\n    core.catchAll(self, (e) => {\n      if (Predicate.hasProperty(e, tag) && e[tag] === options.failure) {\n        return options.onFailure(e)\n      }\n      return core.fail(e)\n    })\n)\n\n/* @internal */\nexport const catchAllDefect = dual<\n  <A2, E2, R2>(\n    f: (defect: unknown) => Effect.Effect<A2, E2, R2>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A | A2, E | E2, R | R2>,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (defect: unknown) => Effect.Effect<A2, E2, R2>\n  ) => Effect.Effect<A | A2, E | E2, R | R2>\n>(2, <A, E, R, A2, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  f: (defect: unknown) => Effect.Effect<A2, E2, R2>\n): Effect.Effect<A | A2, E | E2, R | R2> =>\n  core.catchAllCause(\n    self,\n    (cause): Effect.Effect<A | A2, E | E2, R | R2> => {\n      const option = internalCause.find(cause, (_) => internalCause.isDieType(_) ? Option.some(_) : Option.none())\n      switch (option._tag) {\n        case \"None\": {\n          return core.failCause(cause)\n        }\n        case \"Some\": {\n          return f(option.value.defect)\n        }\n      }\n    }\n  ))\n\n/* @internal */\nexport const catchSomeCause: {\n  <E, A2, E2, R2>(\n    f: (cause: Cause.Cause<Types.NoInfer<E>>) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A, E | E2, R2 | R>\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (cause: Cause.Cause<Types.NoInfer<E>>) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ): Effect.Effect<A2 | A, E | E2, R2 | R>\n} = dual(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (cause: Cause.Cause<Types.NoInfer<E>>) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ): Effect.Effect<A2 | A, E | E2, R2 | R> =>\n    core.matchCauseEffect(self, {\n      onFailure: (cause): Effect.Effect<A2, E | E2, R2> => {\n        const option = f(cause)\n        switch (option._tag) {\n          case \"None\": {\n            return core.failCause(cause)\n          }\n          case \"Some\": {\n            return option.value\n          }\n        }\n      },\n      onSuccess: core.succeed\n    })\n)\n\n/* @internal */\nexport const catchSomeDefect = dual<\n  <A2, E2, R2>(\n    pf: (defect: unknown) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A | A2, E | E2, R | R2>,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    pf: (defect: unknown) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ) => Effect.Effect<A | A2, E | E2, R | R2>\n>(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    pf: (defect: unknown) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ): Effect.Effect<A | A2, E | E2, R | R2> =>\n    core.catchAllCause(\n      self,\n      (cause): Effect.Effect<A | A2, E | E2, R | R2> => {\n        const option = internalCause.find(cause, (_) => internalCause.isDieType(_) ? Option.some(_) : Option.none())\n        switch (option._tag) {\n          case \"None\": {\n            return core.failCause(cause)\n          }\n          case \"Some\": {\n            const optionEffect = pf(option.value.defect)\n            return optionEffect._tag === \"Some\" ? optionEffect.value : core.failCause(cause)\n          }\n        }\n      }\n    )\n)\n\n/* @internal */\nexport const catchTag: {\n  <\n    E,\n    const K extends Arr.NonEmptyReadonlyArray<E extends { _tag: string } ? E[\"_tag\"] : never>,\n    A1,\n    E1,\n    R1\n  >(\n    ...args: [\n      ...tags: K,\n      f: (e: Extract<Types.NoInfer<E>, { _tag: K[number] }>) => Effect.Effect<A1, E1, R1>\n    ]\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A | A1, Exclude<E, { _tag: K[number] }> | E1, R | R1>\n  <\n    A,\n    E,\n    R,\n    const K extends Arr.NonEmptyReadonlyArray<E extends { _tag: string } ? E[\"_tag\"] : never>,\n    A1,\n    E1,\n    R1\n  >(\n    self: Effect.Effect<A, E, R>,\n    ...args: [\n      ...tags: K,\n      f: (e: Extract<Types.NoInfer<E>, { _tag: K[number] }>) => Effect.Effect<A1, E1, R1>\n    ]\n  ): Effect.Effect<A | A1, Exclude<E, { _tag: K[number] }> | E1, R | R1>\n} = dual(\n  (args: any) => core.isEffect(args[0]),\n  <A, E, R, const K extends Arr.NonEmptyReadonlyArray<E extends { _tag: string } ? E[\"_tag\"] : never>, R1, E1, A1>(\n    self: Effect.Effect<A, E, R>,\n    ...args: [\n      ...tags: K & { [I in keyof K]: E extends { _tag: string } ? E[\"_tag\"] : never },\n      f: (e: Extract<Types.NoInfer<E>, { _tag: K[number] }>) => Effect.Effect<A1, E1, R1>\n    ]\n  ): Effect.Effect<A | A1, Exclude<E, { _tag: K[number] }> | E1, R | R1> => {\n    const f = args[args.length - 1] as any\n    let predicate: Predicate.Predicate<E>\n    if (args.length === 2) {\n      predicate = Predicate.isTagged(args[0] as string)\n    } else {\n      predicate = (e) => {\n        const tag = Predicate.hasProperty(e, \"_tag\") ? e[\"_tag\"] : undefined\n        if (!tag) return false\n        for (let i = 0; i < args.length - 1; i++) {\n          if (args[i] === tag) return true\n        }\n        return false\n      }\n    }\n    return core.catchIf(self, predicate as Predicate.Refinement<E, Extract<E, { _tag: K[number] }>>, f) as any\n  }\n) as any\n\n/** @internal */\nexport const catchTags: {\n  <\n    E,\n    Cases extends (E extends { _tag: string } ? {\n        [K in E[\"_tag\"]]+?: (error: Extract<E, { _tag: K }>) => Effect.Effect<any, any, any>\n      } :\n      {})\n  >(\n    cases: Cases\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<\n    | A\n    | {\n      [K in keyof Cases]: Cases[K] extends ((...args: Array<any>) => Effect.Effect<infer A, any, any>) ? A : never\n    }[keyof Cases],\n    | Exclude<E, { _tag: keyof Cases }>\n    | {\n      [K in keyof Cases]: Cases[K] extends ((...args: Array<any>) => Effect.Effect<any, infer E, any>) ? E : never\n    }[keyof Cases],\n    | R\n    | {\n      [K in keyof Cases]: Cases[K] extends ((...args: Array<any>) => Effect.Effect<any, any, infer R>) ? R : never\n    }[keyof Cases]\n  >\n  <\n    R,\n    E,\n    A,\n    Cases extends (E extends { _tag: string } ? {\n        [K in E[\"_tag\"]]+?: (error: Extract<E, { _tag: K }>) => Effect.Effect<any, any, any>\n      } :\n      {})\n  >(\n    self: Effect.Effect<A, E, R>,\n    cases: Cases\n  ): Effect.Effect<\n    | A\n    | {\n      [K in keyof Cases]: Cases[K] extends ((...args: Array<any>) => Effect.Effect<infer A, any, any>) ? A : never\n    }[keyof Cases],\n    | Exclude<E, { _tag: keyof Cases }>\n    | {\n      [K in keyof Cases]: Cases[K] extends ((...args: Array<any>) => Effect.Effect<any, infer E, any>) ? E : never\n    }[keyof Cases],\n    | R\n    | {\n      [K in keyof Cases]: Cases[K] extends ((...args: Array<any>) => Effect.Effect<any, any, infer R>) ? R : never\n    }[keyof Cases]\n  >\n} = dual(2, (self, cases) => {\n  let keys: Array<string>\n  return core.catchIf(\n    self,\n    (e): e is { readonly _tag: string } => {\n      keys ??= Object.keys(cases)\n      return Predicate.hasProperty(e, \"_tag\") && Predicate.isString(e[\"_tag\"]) && keys.includes(e[\"_tag\"])\n    },\n    (e) => cases[e[\"_tag\"]](e)\n  )\n})\n\n/* @internal */\nexport const cause = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<Cause.Cause<E>, never, R> =>\n  core.matchCause(self, { onFailure: identity, onSuccess: () => internalCause.empty })\n\n/* @internal */\nexport const clockWith: <A, E, R>(f: (clock: Clock.Clock) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R> =\n  Clock.clockWith\n\n/* @internal */\nexport const clock: Effect.Effect<Clock.Clock> = clockWith(core.succeed)\n\n/* @internal */\nexport const delay = dual<\n  (duration: Duration.DurationInput) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, duration: Duration.DurationInput) => Effect.Effect<A, E, R>\n>(2, (self, duration) => core.zipRight(Clock.sleep(duration), self))\n\n/* @internal */\nexport const descriptorWith = <A, E, R>(\n  f: (descriptor: Fiber.Fiber.Descriptor) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> =>\n  core.withFiberRuntime((state, status) =>\n    f({\n      id: state.id(),\n      status,\n      interruptors: internalCause.interruptors(state.getFiberRef(core.currentInterruptedCause))\n    })\n  ) as Effect.Effect<A, E, R>\n\n/* @internal */\nexport const allowInterrupt: Effect.Effect<void> = descriptorWith(\n  (descriptor) =>\n    HashSet.size(descriptor.interruptors) > 0\n      ? core.interrupt\n      : core.void\n)\n\n/* @internal */\nexport const descriptor: Effect.Effect<Fiber.Fiber.Descriptor> = descriptorWith(core.succeed)\n\n/* @internal */\nexport const diffFiberRefs = <A, E, R>(\n  self: Effect.Effect<A, E, R>\n): Effect.Effect<[FiberRefsPatch.FiberRefsPatch, A], E, R> => summarized(self, fiberRefs, fiberRefsPatch.diff)\n\n/* @internal */\nexport const diffFiberRefsAndRuntimeFlags = <A, E, R>(\n  self: Effect.Effect<A, E, R>\n): Effect.Effect<[[FiberRefsPatch.FiberRefsPatch, runtimeFlagsPatch.RuntimeFlagsPatch], A], E, R> =>\n  summarized(\n    self,\n    core.zip(fiberRefs, core.runtimeFlags),\n    ([refs, flags], [refsNew, flagsNew]) => [fiberRefsPatch.diff(refs, refsNew), runtimeFlags.diff(flags, flagsNew)]\n  )\n\n/* @internal */\nexport const Do: Effect.Effect<{}> = core.succeed({})\n\n/* @internal */\nexport const bind: {\n  <N extends string, A extends object, B, E2, R2>(\n    name: Exclude<N, keyof A>,\n    f: (a: Types.NoInfer<A>) => Effect.Effect<B, E2, R2>\n  ): <E1, R1>(\n    self: Effect.Effect<A, E1, R1>\n  ) => Effect.Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }, E2 | E1, R2 | R1>\n  <A extends object, N extends string, E1, R1, B, E2, R2>(\n    self: Effect.Effect<A, E1, R1>,\n    name: Exclude<N, keyof A>,\n    f: (a: Types.NoInfer<A>) => Effect.Effect<B, E2, R2>\n  ): Effect.Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }, E1 | E2, R1 | R2>\n} = doNotation.bind<Effect.EffectTypeLambda>(core.map, core.flatMap)\n\n/* @internal */\nexport const bindTo: {\n  <N extends string>(name: N): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<{ [K in N]: A }, E, R>\n  <A, E, R, N extends string>(self: Effect.Effect<A, E, R>, name: N): Effect.Effect<{ [K in N]: A }, E, R>\n} = doNotation.bindTo<Effect.EffectTypeLambda>(core.map)\n\n/* @internal */\nexport const let_: {\n  <N extends string, A extends object, B>(\n    name: Exclude<N, keyof A>,\n    f: (a: Types.NoInfer<A>) => B\n  ): <E, R>(\n    self: Effect.Effect<A, E, R>\n  ) => Effect.Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }, E, R>\n  <A extends object, N extends string, E, R, B>(\n    self: Effect.Effect<A, E, R>,\n    name: Exclude<N, keyof A>,\n    f: (a: Types.NoInfer<A>) => B\n  ): Effect.Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }, E, R>\n} = doNotation.let_<Effect.EffectTypeLambda>(core.map)\n\n/* @internal */\nexport const dropUntil: {\n  <A, E, R>(\n    predicate: (a: Types.NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>\n  ): (elements: Iterable<A>) => Effect.Effect<Array<A>, E, R>\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: A, i: number) => Effect.Effect<boolean, E, R>\n  ): Effect.Effect<Array<A>, E, R>\n} = dual(\n  2,\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: A, i: number) => Effect.Effect<boolean, E, R>\n  ): Effect.Effect<Array<A>, E, R> =>\n    core.suspend(() => {\n      const iterator = elements[Symbol.iterator]()\n      const builder: Array<A> = []\n      let next: IteratorResult<A, any>\n      let dropping: Effect.Effect<boolean, E, R> = core.succeed(false)\n      let i = 0\n      while ((next = iterator.next()) && !next.done) {\n        const a = next.value\n        const index = i++\n        dropping = core.flatMap(dropping, (bool) => {\n          if (bool) {\n            builder.push(a)\n            return core.succeed(true)\n          }\n          return predicate(a, index)\n        })\n      }\n      return core.map(dropping, () => builder)\n    })\n)\n\n/* @internal */\nexport const dropWhile: {\n  <A, E, R>(\n    predicate: (a: Types.NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>\n  ): (elements: Iterable<A>) => Effect.Effect<Array<A>, E, R>\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: A, i: number) => Effect.Effect<boolean, E, R>\n  ): Effect.Effect<Array<A>, E, R>\n} = dual(\n  2,\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: A, i: number) => Effect.Effect<boolean, E, R>\n  ): Effect.Effect<Array<A>, E, R> =>\n    core.suspend(() => {\n      const iterator = elements[Symbol.iterator]()\n      const builder: Array<A> = []\n      let next\n      let dropping: Effect.Effect<boolean, E, R> = core.succeed(true)\n      let i = 0\n      while ((next = iterator.next()) && !next.done) {\n        const a = next.value\n        const index = i++\n        dropping = core.flatMap(dropping, (d) =>\n          core.map(d ? predicate(a, index) : core.succeed(false), (b) => {\n            if (!b) {\n              builder.push(a)\n            }\n            return b\n          }))\n      }\n      return core.map(dropping, () => builder)\n    })\n)\n\n/* @internal */\nexport const contextWith = <R, A>(f: (context: Context.Context<R>) => A): Effect.Effect<A, never, R> =>\n  core.map(core.context<R>(), f)\n\n/* @internal */\nexport const eventually = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<A, never, R> =>\n  core.orElse(self, () => core.flatMap(core.yieldNow(), () => eventually(self)))\n\n/* @internal */\nexport const filterMap = dual<\n  <Eff extends Effect.Effect<any, any, any>, B>(\n    pf: (a: Effect.Effect.Success<Eff>) => Option.Option<B>\n  ) => (elements: Iterable<Eff>) => Effect.Effect<Array<B>, Effect.Effect.Error<Eff>, Effect.Effect.Context<Eff>>,\n  <Eff extends Effect.Effect<any, any, any>, B>(\n    elements: Iterable<Eff>,\n    pf: (a: Effect.Effect.Success<Eff>) => Option.Option<B>\n  ) => Effect.Effect<Array<B>, Effect.Effect.Error<Eff>, Effect.Effect.Context<Eff>>\n>(2, (elements, pf) =>\n  core.map(\n    core.forEachSequential(elements, identity),\n    Arr.filterMap(pf)\n  ))\n\n/* @internal */\nexport const filterOrDie: {\n  <A, B extends A>(\n    refinement: Predicate.Refinement<Types.NoInfer<A>, B>,\n    orDieWith: (a: Types.EqualsWith<A, B, A, Exclude<A, B>>) => unknown\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E, R>\n  <A>(\n    predicate: Predicate.Predicate<Types.NoInfer<A>>,\n    orDieWith: (a: Types.NoInfer<A>) => unknown\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  <A, E, R, B extends A>(\n    self: Effect.Effect<A, E, R>,\n    refinement: Predicate.Refinement<A, B>,\n    orDieWith: (a: Types.EqualsWith<A, B, A, Exclude<A, B>>) => unknown\n  ): Effect.Effect<B, E, R>\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    predicate: Predicate.Predicate<A>,\n    orDieWith: (a: A) => unknown\n  ): Effect.Effect<A, E, R>\n} = dual(\n  3,\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    predicate: Predicate.Predicate<A>,\n    orDieWith: (a: A) => unknown\n  ): Effect.Effect<A, E, R> => filterOrElse(self, predicate, (a) => core.dieSync(() => orDieWith(a)))\n)\n\n/* @internal */\nexport const filterOrDieMessage: {\n  <A, B extends A>(\n    refinement: Predicate.Refinement<Types.NoInfer<A>, B>,\n    message: string\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E, R>\n  <A>(\n    predicate: Predicate.Predicate<Types.NoInfer<A>>,\n    message: string\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  <A, E, R, B extends A>(\n    self: Effect.Effect<A, E, R>,\n    refinement: Predicate.Refinement<A, B>,\n    message: string\n  ): Effect.Effect<B, E, R>\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    predicate: Predicate.Predicate<A>,\n    message: string\n  ): Effect.Effect<A, E, R>\n} = dual(\n  3,\n  <A, E, R>(self: Effect.Effect<A, E, R>, predicate: Predicate.Predicate<A>, message: string): Effect.Effect<A, E, R> =>\n    filterOrElse(self, predicate, () => core.dieMessage(message))\n)\n\n/* @internal */\nexport const filterOrElse: {\n  <A, C, E2, R2, B extends A>(\n    refinement: Predicate.Refinement<Types.NoInfer<A>, B>,\n    orElse: (a: Types.EqualsWith<A, B, Types.NoInfer<A>, Exclude<Types.NoInfer<A>, B>>) => Effect.Effect<C, E2, R2>\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B | C, E2 | E, R2 | R>\n  <A, C, E2, R2>(\n    predicate: Predicate.Predicate<Types.NoInfer<A>>,\n    orElse: (a: Types.NoInfer<A>) => Effect.Effect<C, E2, R2>\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A | C, E2 | E, R2 | R>\n  <A, E, R, C, E2, R2, B extends A>(\n    self: Effect.Effect<A, E, R>,\n    refinement: Predicate.Refinement<A, B>,\n    orElse: (a: Types.EqualsWith<A, B, A, Exclude<A, B>>) => Effect.Effect<C, E2, R2>\n  ): Effect.Effect<B | C, E | E2, R | R2>\n  <A, E, R, C, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    predicate: Predicate.Predicate<A>,\n    orElse: (a: A) => Effect.Effect<C, E2, R2>\n  ): Effect.Effect<A | C, E | E2, R | R2>\n} = dual(3, <A, E, R, B, E2, R2>(\n  self: Effect.Effect<A, E, R>,\n  predicate: Predicate.Predicate<A>,\n  orElse: (a: A) => Effect.Effect<B, E2, R2>\n): Effect.Effect<A | B, E | E2, R | R2> =>\n  core.flatMap(\n    self,\n    (a) => predicate(a) ? core.succeed<A | B>(a) : orElse(a)\n  ))\n\n/** @internal */\nexport const liftPredicate = dual<\n  <T extends A, E, B extends T = T, A = T>(\n    predicate: Predicate.Refinement<T, B> | Predicate.Predicate<T>,\n    orFailWith: (a: Types.EqualsWith<T, B, A, Exclude<A, B>>) => E\n  ) => (a: A) => Effect.Effect<Types.EqualsWith<T, B, A, B>, E>,\n  <A, E, B extends A = A>(\n    self: A,\n    predicate: Predicate.Refinement<A, B> | Predicate.Predicate<A>,\n    orFailWith: (a: Types.EqualsWith<A, B, A, Exclude<A, B>>) => E\n  ) => Effect.Effect<B, E>\n>(\n  3,\n  <A, E, B extends A = A>(\n    self: A,\n    predicate: Predicate.Refinement<A, B> | Predicate.Predicate<A>,\n    orFailWith: (a: Types.EqualsWith<A, B, A, Exclude<A, B>>) => E\n  ): Effect.Effect<B, E> =>\n    core.suspend(() => predicate(self) ? core.succeed(self as B) : core.fail(orFailWith(self as any)))\n)\n\n/* @internal */\nexport const filterOrFail: {\n  <A, E2, B extends A>(\n    refinement: Predicate.Refinement<Types.NoInfer<A>, B>,\n    orFailWith: (a: Types.EqualsWith<A, B, Types.NoInfer<A>, Exclude<Types.NoInfer<A>, B>>) => E2\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<Types.NoInfer<B>, E2 | E, R>\n  <A, E2>(\n    predicate: Predicate.Predicate<Types.NoInfer<A>>,\n    orFailWith: (a: Types.NoInfer<A>) => E2\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E2 | E, R>\n  <A, E, R, E2, B extends A>(\n    self: Effect.Effect<A, E, R>,\n    refinement: Predicate.Refinement<A, B>,\n    orFailWith: (a: Types.EqualsWith<A, B, A, Exclude<A, B>>) => E2\n  ): Effect.Effect<Types.NoInfer<B>, E2 | E, R>\n  <A, E, R, E2>(\n    self: Effect.Effect<A, E, R>,\n    predicate: Predicate.Predicate<A>,\n    orFailWith: (a: A) => E2\n  ): Effect.Effect<A, E2 | E, R>\n  <A, B extends A>(\n    refinement: Predicate.Refinement<Types.NoInfer<A>, B>\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<Types.NoInfer<B>, Cause.NoSuchElementException | E, R>\n  <A>(\n    predicate: Predicate.Predicate<Types.NoInfer<A>>\n  ): <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, Cause.NoSuchElementException | E, R>\n  <A, E, R, B extends A>(\n    self: Effect.Effect<A, E, R>,\n    refinement: Predicate.Refinement<A, B>\n  ): Effect.Effect<Types.NoInfer<B>, E | Cause.NoSuchElementException, R>\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    predicate: Predicate.Predicate<A>\n  ): Effect.Effect<A, E | Cause.NoSuchElementException, R>\n} = dual((args) => core.isEffect(args[0]), <A, E, R, E2>(\n  self: Effect.Effect<A, E, R>,\n  predicate: Predicate.Predicate<A>,\n  orFailWith?: (a: A) => E2\n): Effect.Effect<A, E | E2 | Cause.NoSuchElementException, R> =>\n  filterOrElse(\n    self,\n    predicate,\n    (a): Effect.Effect<never, E2 | Cause.NoSuchElementException, never> =>\n      orFailWith === undefined ? core.fail(new core.NoSuchElementException()) : core.failSync(() => orFailWith(a))\n  ))\n\n/* @internal */\nexport const findFirst: {\n  <A, E, R>(\n    predicate: (a: Types.NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>\n  ): (elements: Iterable<A>) => Effect.Effect<Option.Option<A>, E, R>\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: Types.NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>\n  ): Effect.Effect<Option.Option<A>, E, R>\n} = dual(\n  2,\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: Types.NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>\n  ): Effect.Effect<Option.Option<A>, E, R> =>\n    core.suspend(() => {\n      const iterator = elements[Symbol.iterator]()\n      const next = iterator.next()\n      if (!next.done) {\n        return findLoop(iterator, 0, predicate, next.value)\n      }\n      return core.succeed(Option.none())\n    })\n)\n\nconst findLoop = <A, E, R>(\n  iterator: Iterator<A>,\n  index: number,\n  f: (a: A, i: number) => Effect.Effect<boolean, E, R>,\n  value: A\n): Effect.Effect<Option.Option<A>, E, R> =>\n  core.flatMap(f(value, index), (result) => {\n    if (result) {\n      return core.succeed(Option.some(value))\n    }\n    const next = iterator.next()\n    if (!next.done) {\n      return findLoop(iterator, index + 1, f, next.value)\n    }\n    return core.succeed(Option.none())\n  })\n\n/* @internal */\nexport const firstSuccessOf = <Eff extends Effect.Effect<any, any, any>>(\n  effects: Iterable<Eff>\n): Effect.Effect<Effect.Effect.Success<Eff>, Effect.Effect.Error<Eff>, Effect.Effect.Context<Eff>> =>\n  core.suspend(() => {\n    const list = Chunk.fromIterable(effects)\n    if (!Chunk.isNonEmpty(list)) {\n      return core.dieSync(() => new core.IllegalArgumentException(`Received an empty collection of effects`))\n    }\n    return pipe(\n      Chunk.tailNonEmpty(list),\n      Arr.reduce(Chunk.headNonEmpty(list), (left, right) => core.orElse(left, () => right) as Eff)\n    )\n  })\n\n/* @internal */\nexport const flipWith: {\n  <E, A, R, E2, A2, R2>(\n    f: (effect: Effect.Effect<E, A, R>) => Effect.Effect<E2, A2, R2>\n  ): (self: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2, R2>\n  <A, E, R, E2, A2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (effect: Effect.Effect<E, A, R>) => Effect.Effect<E2, A2, R2>\n  ): Effect.Effect<A2, E2, R2>\n} = dual(2, <A, E, R, E2, A2, R2>(\n  self: Effect.Effect<A, E, R>,\n  f: (effect: Effect.Effect<E, A, R>) => Effect.Effect<E2, A2, R2>\n): Effect.Effect<A2, E2, R2> => core.flip(f(core.flip(self))))\n\n/* @internal */\nexport const match: {\n  <E, A2, A, A3>(\n    options: {\n      readonly onFailure: (error: E) => A2\n      readonly onSuccess: (value: A) => A3\n    }\n  ): <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A2 | A3, never, R>\n  <A, E, R, A2, A3>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly onFailure: (error: E) => A2\n      readonly onSuccess: (value: A) => A3\n    }\n  ): Effect.Effect<A2 | A3, never, R>\n} = dual(2, <A, E, R, A2, A3>(\n  self: Effect.Effect<A, E, R>,\n  options: {\n    readonly onFailure: (error: E) => A2\n    readonly onSuccess: (value: A) => A3\n  }\n): Effect.Effect<A2 | A3, never, R> =>\n  core.matchEffect(self, {\n    onFailure: (e) => core.succeed(options.onFailure(e)),\n    onSuccess: (a) => core.succeed(options.onSuccess(a))\n  }))\n\n/* @internal */\nexport const every: {\n  <A, E, R>(\n    predicate: (a: A, i: number) => Effect.Effect<boolean, E, R>\n  ): (elements: Iterable<A>) => Effect.Effect<boolean, E, R>\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: A, i: number) => Effect.Effect<boolean, E, R>\n  ): Effect.Effect<boolean, E, R>\n} = dual(\n  2,\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: A, i: number) => Effect.Effect<boolean, E, R>\n  ): Effect.Effect<boolean, E, R> => core.suspend(() => forAllLoop(elements[Symbol.iterator](), 0, predicate))\n)\n\nconst forAllLoop = <A, E, R>(\n  iterator: Iterator<A>,\n  index: number,\n  f: (a: A, i: number) => Effect.Effect<boolean, E, R>\n): Effect.Effect<boolean, E, R> => {\n  const next = iterator.next()\n  return next.done\n    ? core.succeed(true)\n    : core.flatMap(\n      f(next.value, index),\n      (b) => b ? forAllLoop(iterator, index + 1, f) : core.succeed(b)\n    )\n}\n\n/* @internal */\nexport const forever = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<never, E, R> => {\n  const loop: Effect.Effect<never, E, R> = core.flatMap(core.flatMap(self, () => core.yieldNow()), () => loop)\n  return loop\n}\n\n/* @internal */\nexport const fiberRefs: Effect.Effect<FiberRefs.FiberRefs> = core.withFiberRuntime((state) =>\n  core.succeed(state.getFiberRefs())\n)\n\n/* @internal */\nexport const head = <A, E, R>(\n  self: Effect.Effect<Iterable<A>, E, R>\n): Effect.Effect<A, E | Cause.NoSuchElementException, R> =>\n  core.flatMap(self, (as) => {\n    const iterator = as[Symbol.iterator]()\n    const next = iterator.next()\n    if (next.done) {\n      return core.fail(new core.NoSuchElementException())\n    }\n    return core.succeed(next.value)\n  })\n\n/* @internal */\nexport const ignore = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<void, never, R> =>\n  match(self, { onFailure: constVoid, onSuccess: constVoid })\n\n/* @internal */\nexport const ignoreLogged = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<void, never, R> =>\n  core.matchCauseEffect(self, {\n    onFailure: (cause) => logDebug(cause, \"An error was silently ignored because it is not anticipated to be useful\"),\n    onSuccess: () => core.void\n  })\n\n/* @internal */\nexport const inheritFiberRefs = (childFiberRefs: FiberRefs.FiberRefs) =>\n  updateFiberRefs((parentFiberId, parentFiberRefs) => FiberRefs.joinAs(parentFiberRefs, parentFiberId, childFiberRefs))\n\n/* @internal */\nexport const isFailure = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<boolean, never, R> =>\n  match(self, { onFailure: constTrue, onSuccess: constFalse })\n\n/* @internal */\nexport const isSuccess = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<boolean, never, R> =>\n  match(self, { onFailure: constFalse, onSuccess: constTrue })\n\n/* @internal */\nexport const iterate: {\n  <A, B extends A, R, E>(\n    initial: A,\n    options: {\n      readonly while: Predicate.Refinement<A, B>\n      readonly body: (b: B) => Effect.Effect<A, E, R>\n    }\n  ): Effect.Effect<A, E, R>\n  <A, R, E>(\n    initial: A,\n    options: {\n      readonly while: Predicate.Predicate<A>\n      readonly body: (a: A) => Effect.Effect<A, E, R>\n    }\n  ): Effect.Effect<A, E, R>\n} = <A, E, R>(\n  initial: A,\n  options: {\n    readonly while: Predicate.Predicate<A>\n    readonly body: (z: A) => Effect.Effect<A, E, R>\n  }\n): Effect.Effect<A, E, R> =>\n  core.suspend<A, E, R>(() => {\n    if (options.while(initial)) {\n      return core.flatMap(options.body(initial), (z2) => iterate(z2, options))\n    }\n    return core.succeed(initial)\n  })\n\n/** @internal */\nexport const logWithLevel = (level?: LogLevel.LogLevel) =>\n(\n  ...message: ReadonlyArray<any>\n): Effect.Effect<void> => {\n  const levelOption = Option.fromNullable(level)\n  let cause: Cause.Cause<unknown> | undefined = undefined\n  for (let i = 0, len = message.length; i < len; i++) {\n    const msg = message[i]\n    if (internalCause.isCause(msg)) {\n      if (cause !== undefined) {\n        cause = internalCause.sequential(cause, msg)\n      } else {\n        cause = msg\n      }\n      message = [...message.slice(0, i), ...message.slice(i + 1)]\n      i--\n    }\n  }\n  if (cause === undefined) {\n    cause = internalCause.empty\n  }\n  return core.withFiberRuntime((fiberState) => {\n    fiberState.log(message, cause, levelOption)\n    return core.void\n  })\n}\n\n/** @internal */\nexport const log: (...message: ReadonlyArray<any>) => Effect.Effect<void, never, never> = logWithLevel()\n\n/** @internal */\nexport const logTrace: (...message: ReadonlyArray<any>) => Effect.Effect<void, never, never> = logWithLevel(\n  LogLevel.Trace\n)\n\n/** @internal */\nexport const logDebug: (...message: ReadonlyArray<any>) => Effect.Effect<void, never, never> = logWithLevel(\n  LogLevel.Debug\n)\n\n/** @internal */\nexport const logInfo: (...message: ReadonlyArray<any>) => Effect.Effect<void, never, never> = logWithLevel(\n  LogLevel.Info\n)\n\n/** @internal */\nexport const logWarning: (...message: ReadonlyArray<any>) => Effect.Effect<void, never, never> = logWithLevel(\n  LogLevel.Warning\n)\n\n/** @internal */\nexport const logError: (...message: ReadonlyArray<any>) => Effect.Effect<void, never, never> = logWithLevel(\n  LogLevel.Error\n)\n\n/** @internal */\nexport const logFatal: (...message: ReadonlyArray<any>) => Effect.Effect<void, never, never> = logWithLevel(\n  LogLevel.Fatal\n)\n\n/* @internal */\nexport const withLogSpan = dual<\n  (label: string) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(effect: Effect.Effect<A, E, R>, label: string) => Effect.Effect<A, E, R>\n>(2, (effect, label) =>\n  core.flatMap(Clock.currentTimeMillis, (now) =>\n    core.fiberRefLocallyWith(\n      effect,\n      core.currentLogSpan,\n      List.prepend(LogSpan.make(label, now))\n    )))\n\n/* @internal */\nexport const logAnnotations: Effect.Effect<HashMap.HashMap<string, unknown>> = core\n  .fiberRefGet(\n    core.currentLogAnnotations\n  )\n\n/* @internal */\nexport const loop: {\n  <A, B extends A, C, E, R>(\n    initial: A,\n    options: {\n      readonly while: Predicate.Refinement<A, B>\n      readonly step: (b: B) => A\n      readonly body: (b: B) => Effect.Effect<C, E, R>\n      readonly discard?: false | undefined\n    }\n  ): Effect.Effect<Array<C>, E, R>\n  <A, C, E, R>(\n    initial: A,\n    options: {\n      readonly while: (a: A) => boolean\n      readonly step: (a: A) => A\n      readonly body: (a: A) => Effect.Effect<C, E, R>\n      readonly discard?: false | undefined\n    }\n  ): Effect.Effect<Array<C>, E, R>\n  <A, B extends A, C, E, R>(\n    initial: A,\n    options: {\n      readonly while: Predicate.Refinement<A, B>\n      readonly step: (b: B) => A\n      readonly body: (b: B) => Effect.Effect<R, E, C>\n      readonly discard: true\n    }\n  ): Effect.Effect<void, E, R>\n  <A, C, E, R>(\n    initial: A,\n    options: {\n      readonly while: (a: A) => boolean\n      readonly step: (a: A) => A\n      readonly body: (a: A) => Effect.Effect<C, E, R>\n      readonly discard: true\n    }\n  ): Effect.Effect<void, E, R>\n} = <A, C, E, R>(\n  initial: A,\n  options: {\n    readonly while: Predicate.Predicate<A>\n    readonly step: (a: A) => A\n    readonly body: (a: A) => Effect.Effect<C, E, R>\n    readonly discard?: boolean | undefined\n  }\n): any =>\n  options.discard\n    ? loopDiscard(initial, options.while, options.step, options.body)\n    : core.map(loopInternal(initial, options.while, options.step, options.body), Arr.fromIterable)\n\nconst loopInternal = <Z, A, E, R>(\n  initial: Z,\n  cont: Predicate.Predicate<Z>,\n  inc: (z: Z) => Z,\n  body: (z: Z) => Effect.Effect<A, E, R>\n): Effect.Effect<List.List<A>, E, R> =>\n  core.suspend(() =>\n    cont(initial)\n      ? core.flatMap(body(initial), (a) =>\n        core.map(\n          loopInternal(inc(initial), cont, inc, body),\n          List.prepend(a)\n        ))\n      : core.sync(() => List.empty())\n  )\n\nconst loopDiscard = <S, X, E, R>(\n  initial: S,\n  cont: Predicate.Predicate<S>,\n  inc: (s: S) => S,\n  body: (s: S) => Effect.Effect<X, E, R>\n): Effect.Effect<void, E, R> =>\n  core.suspend(() =>\n    cont(initial)\n      ? core.flatMap(\n        body(initial),\n        () => loopDiscard(inc(initial), cont, inc, body)\n      )\n      : core.void\n  )\n\n/* @internal */\nexport const mapAccum: {\n  <S, A, B, E, R, I extends Iterable<A> = Iterable<A>>(\n    initial: S,\n    f: (state: S, a: A, i: number) => Effect.Effect<readonly [S, B], E, R>\n  ): (elements: I) => Effect.Effect<[S, Arr.ReadonlyArray.With<I, B>], E, R>\n  <A, S, B, E, R, I extends Iterable<A> = Iterable<A>>(\n    elements: I,\n    initial: S,\n    f: (state: S, a: A, i: number) => Effect.Effect<readonly [S, B], E, R>\n  ): Effect.Effect<[S, Arr.ReadonlyArray.With<I, B>], E, R>\n} = dual(3, <A, S, B, E, R, I extends Iterable<A> = Iterable<A>>(\n  elements: I,\n  initial: S,\n  f: (state: S, a: A, i: number) => Effect.Effect<readonly [S, B], E, R>\n): Effect.Effect<[S, Array<B>], E, R> =>\n  core.suspend(() => {\n    const iterator = elements[Symbol.iterator]()\n    const builder: Array<B> = []\n    let result: Effect.Effect<S, E, R> = core.succeed(initial)\n    let next: IteratorResult<A, any>\n    let i = 0\n    while (!(next = iterator.next()).done) {\n      const index = i++\n      const value = next.value\n      result = core.flatMap(result, (state) =>\n        core.map(f(state, value, index), ([z, b]) => {\n          builder.push(b)\n          return z\n        }))\n    }\n    return core.map(result, (z) => [z, builder])\n  }))\n\n/* @internal */\nexport const mapErrorCause: {\n  <E, E2>(\n    f: (cause: Cause.Cause<E>) => Cause.Cause<E2>\n  ): <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E2, R>\n  <A, E, R, E2>(self: Effect.Effect<A, E, R>, f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): Effect.Effect<A, E2, R>\n} = dual(\n  2,\n  <A, E, R, E2>(self: Effect.Effect<A, E, R>, f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): Effect.Effect<A, E2, R> =>\n    core.matchCauseEffect(self, {\n      onFailure: (c) => core.failCauseSync(() => f(c)),\n      onSuccess: core.succeed\n    })\n)\n\n/* @internal */\nexport const memoize = <A, E, R>(\n  self: Effect.Effect<A, E, R>\n): Effect.Effect<Effect.Effect<A, E, R>> =>\n  pipe(\n    core.deferredMake<[[FiberRefsPatch.FiberRefsPatch, runtimeFlagsPatch.RuntimeFlagsPatch], A], E>(),\n    core.flatMap((deferred) =>\n      pipe(\n        diffFiberRefsAndRuntimeFlags(self),\n        core.intoDeferred(deferred),\n        once,\n        core.map((complete) =>\n          core.zipRight(\n            complete,\n            pipe(\n              core.deferredAwait(deferred),\n              core.flatMap(([patch, a]) =>\n                core.as(core.zip(patchFiberRefs(patch[0]), core.updateRuntimeFlags(patch[1])), a)\n              )\n            )\n          )\n        )\n      )\n    )\n  )\n\n/* @internal */\nexport const merge = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<E | A, never, R> =>\n  core.matchEffect(self, {\n    onFailure: (e) => core.succeed(e),\n    onSuccess: core.succeed\n  })\n\n/* @internal */\nexport const negate = <E, R>(self: Effect.Effect<boolean, E, R>): Effect.Effect<boolean, E, R> =>\n  core.map(self, (b) => !b)\n\n/* @internal */\nexport const none = <A, E, R>(\n  self: Effect.Effect<Option.Option<A>, E, R>\n): Effect.Effect<void, E | Cause.NoSuchElementException, R> =>\n  core.flatMap(self, (option) => {\n    switch (option._tag) {\n      case \"None\":\n        return core.void\n      case \"Some\":\n        return core.fail(new core.NoSuchElementException())\n    }\n  })\n\n/* @internal */\nexport const once = <A, E, R>(\n  self: Effect.Effect<A, E, R>\n): Effect.Effect<Effect.Effect<void, E, R>> =>\n  core.map(\n    Ref.make(true),\n    (ref) => core.asVoid(core.whenEffect(self, Ref.getAndSet(ref, false)))\n  )\n\n/* @internal */\nexport const option = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<Option.Option<A>, never, R> =>\n  core.matchEffect(self, {\n    onFailure: () => core.succeed(Option.none()),\n    onSuccess: (a) => core.succeed(Option.some(a))\n  })\n\n/* @internal */\nexport const orElseFail = dual<\n  <E2>(evaluate: LazyArg<E2>) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E2, R>,\n  <A, E, R, E2>(self: Effect.Effect<A, E, R>, evaluate: LazyArg<E2>) => Effect.Effect<A, E2, R>\n>(2, (self, evaluate) => core.orElse(self, () => core.failSync(evaluate)))\n\n/* @internal */\nexport const orElseSucceed = dual<\n  <A2>(evaluate: LazyArg<A2>) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A | A2, never, R>,\n  <A, E, R, A2>(self: Effect.Effect<A, E, R>, evaluate: LazyArg<A2>) => Effect.Effect<A | A2, never, R>\n>(2, (self, evaluate) => core.orElse(self, () => core.sync(evaluate)))\n\n/* @internal */\nexport const parallelErrors = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<A, Array<E>, R> =>\n  core.matchCauseEffect(self, {\n    onFailure: (cause) => {\n      const errors = Arr.fromIterable(internalCause.failures(cause))\n      return errors.length === 0\n        ? core.failCause(cause as Cause.Cause<never>)\n        : core.fail(errors)\n    },\n    onSuccess: core.succeed\n  })\n\n/* @internal */\nexport const patchFiberRefs = (patch: FiberRefsPatch.FiberRefsPatch): Effect.Effect<void> =>\n  updateFiberRefs((fiberId, fiberRefs) => pipe(patch, fiberRefsPatch.patch(fiberId, fiberRefs)))\n\n/* @internal */\nexport const promise = <A>(evaluate: (signal: AbortSignal) => PromiseLike<A>): Effect.Effect<A> =>\n  evaluate.length >= 1\n    ? core.async((resolve, signal) => {\n      try {\n        evaluate(signal)\n          .then((a) => resolve(core.exitSucceed(a)), (e) => resolve(core.exitDie(e)))\n      } catch (e) {\n        resolve(core.exitDie(e))\n      }\n    })\n    : core.async((resolve) => {\n      try {\n        ;(evaluate as LazyArg<PromiseLike<A>>)()\n          .then((a) => resolve(core.exitSucceed(a)), (e) => resolve(core.exitDie(e)))\n      } catch (e) {\n        resolve(core.exitDie(e))\n      }\n    })\n\n/* @internal */\nexport const provideService = dual<\n  <I, S>(\n    tag: Context.Tag<I, S>,\n    service: Types.NoInfer<S>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, I>>,\n  <A, E, R, I, S>(\n    self: Effect.Effect<A, E, R>,\n    tag: Context.Tag<I, S>,\n    service: Types.NoInfer<S>\n  ) => Effect.Effect<A, E, Exclude<R, I>>\n>(\n  3,\n  <A, E, R, I, S>(\n    self: Effect.Effect<A, E, R>,\n    tag: Context.Tag<I, S>,\n    service: Types.NoInfer<S>\n  ): Effect.Effect<A, E, Exclude<R, I>> =>\n    core.contextWithEffect((env) =>\n      core.provideContext(\n        self as Effect.Effect<A, E, I | Exclude<R, I>>,\n        Context.add(env, tag, service)\n      )\n    )\n)\n\n/* @internal */\nexport const provideServiceEffect = dual<\n  <I, S, E1, R1>(\n    tag: Context.Tag<I, S>,\n    effect: Effect.Effect<Types.NoInfer<S>, E1, R1>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E1, R1 | Exclude<R, I>>,\n  <A, E, R, I, S, E1, R1>(\n    self: Effect.Effect<A, E, R>,\n    tag: Context.Tag<I, S>,\n    effect: Effect.Effect<Types.NoInfer<S>, E1, R1>\n  ) => Effect.Effect<A, E | E1, R1 | Exclude<R, I>>\n>(3, <A, E, R, I, S, E1, R1>(\n  self: Effect.Effect<A, E, R>,\n  tag: Context.Tag<I, S>,\n  effect: Effect.Effect<Types.NoInfer<S>, E1, R1>\n) =>\n  core.contextWithEffect((env: Context.Context<R1 | Exclude<R, I>>) =>\n    core.flatMap(\n      effect,\n      (service) => core.provideContext(self, pipe(env, Context.add(tag, service)) as Context.Context<R | R1>)\n    )\n  ))\n\n/* @internal */\nexport const random: Effect.Effect<Random.Random> = defaultServices.randomWith(core.succeed)\n\n/* @internal */\nexport const reduce = dual<\n  <Z, A, E, R>(\n    zero: Z,\n    f: (z: Z, a: A, i: number) => Effect.Effect<Z, E, R>\n  ) => (elements: Iterable<A>) => Effect.Effect<Z, E, R>,\n  <A, Z, E, R>(\n    elements: Iterable<A>,\n    zero: Z,\n    f: (z: Z, a: A, i: number) => Effect.Effect<Z, E, R>\n  ) => Effect.Effect<Z, E, R>\n>(\n  3,\n  <A, Z, E, R>(\n    elements: Iterable<A>,\n    zero: Z,\n    f: (z: Z, a: A, i: number) => Effect.Effect<Z, E, R>\n  ) =>\n    Arr.fromIterable(elements).reduce(\n      (acc, el, i) => core.flatMap(acc, (a) => f(a, el, i)),\n      core.succeed(zero) as Effect.Effect<Z, E, R>\n    )\n)\n\n/* @internal */\nexport const reduceRight = dual<\n  <A, Z, R, E>(\n    zero: Z,\n    f: (a: A, z: Z, i: number) => Effect.Effect<Z, E, R>\n  ) => (elements: Iterable<A>) => Effect.Effect<Z, E, R>,\n  <A, Z, R, E>(\n    elements: Iterable<A>,\n    zero: Z,\n    f: (a: A, z: Z, i: number) => Effect.Effect<Z, E, R>\n  ) => Effect.Effect<Z, E, R>\n>(\n  3,\n  <A, Z, R, E>(elements: Iterable<A>, zero: Z, f: (a: A, z: Z, i: number) => Effect.Effect<Z, E, R>) =>\n    Arr.fromIterable(elements).reduceRight(\n      (acc, el, i) => core.flatMap(acc, (a) => f(el, a, i)),\n      core.succeed(zero) as Effect.Effect<Z, E, R>\n    )\n)\n\n/* @internal */\nexport const reduceWhile = dual<\n  <Z, A, E, R>(\n    zero: Z,\n    options: {\n      readonly while: Predicate.Predicate<Z>\n      readonly body: (s: Z, a: A, i: number) => Effect.Effect<Z, E, R>\n    }\n  ) => (elements: Iterable<A>) => Effect.Effect<Z, E, R>,\n  <A, Z, E, R>(\n    elements: Iterable<A>,\n    zero: Z,\n    options: {\n      readonly while: Predicate.Predicate<Z>\n      readonly body: (s: Z, a: A, i: number) => Effect.Effect<Z, E, R>\n    }\n  ) => Effect.Effect<Z, E, R>\n>(3, <A, Z, E, R>(\n  elements: Iterable<A>,\n  zero: Z,\n  options: {\n    readonly while: Predicate.Predicate<Z>\n    readonly body: (s: Z, a: A, i: number) => Effect.Effect<Z, E, R>\n  }\n) =>\n  core.flatMap(\n    core.sync(() => elements[Symbol.iterator]()),\n    (iterator) => reduceWhileLoop(iterator, 0, zero, options.while, options.body)\n  ))\n\nconst reduceWhileLoop = <A, R, E, Z>(\n  iterator: Iterator<A>,\n  index: number,\n  state: Z,\n  predicate: Predicate.Predicate<Z>,\n  f: (s: Z, a: A, i: number) => Effect.Effect<Z, E, R>\n): Effect.Effect<Z, E, R> => {\n  const next = iterator.next()\n  if (!next.done && predicate(state)) {\n    return core.flatMap(\n      f(state, next.value, index),\n      (nextState) => reduceWhileLoop(iterator, index + 1, nextState, predicate, f)\n    )\n  }\n  return core.succeed(state)\n}\n\n/* @internal */\nexport const repeatN = dual<\n  (n: number) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, n: number) => Effect.Effect<A, E, R>\n>(2, (self, n) => core.suspend(() => repeatNLoop(self, n)))\n\n/* @internal */\nconst repeatNLoop = <A, E, R>(self: Effect.Effect<A, E, R>, n: number): Effect.Effect<A, E, R> =>\n  core.flatMap(self, (a) =>\n    n <= 0\n      ? core.succeed(a)\n      : core.zipRight(core.yieldNow(), repeatNLoop(self, n - 1)))\n\n/* @internal */\nexport const sandbox = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<A, Cause.Cause<E>, R> =>\n  core.matchCauseEffect(self, {\n    onFailure: core.fail,\n    onSuccess: core.succeed\n  })\n\n/* @internal */\nexport const setFiberRefs = (fiberRefs: FiberRefs.FiberRefs): Effect.Effect<void> =>\n  core.suspend(() => FiberRefs.setAll(fiberRefs))\n\n/* @internal */\nexport const sleep: (duration: Duration.DurationInput) => Effect.Effect<void> = Clock.sleep\n\n/* @internal */\nexport const succeedNone: Effect.Effect<Option.Option<never>> = core.succeed(Option.none())\n\n/* @internal */\nexport const succeedSome = <A>(value: A): Effect.Effect<Option.Option<A>> => core.succeed(Option.some(value))\n\n/* @internal */\nexport const summarized: {\n  <B, E2, R2, C>(\n    summary: Effect.Effect<B, E2, R2>,\n    f: (start: B, end: B) => C\n  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<[C, A], E2 | E, R2 | R>\n  <A, E, R, B, E2, R2, C>(\n    self: Effect.Effect<A, E, R>,\n    summary: Effect.Effect<B, E2, R2>,\n    f: (start: B, end: B) => C\n  ): Effect.Effect<[C, A], E2 | E, R2 | R>\n} = dual(\n  3,\n  <A, E, R, B, E2, R2, C>(\n    self: Effect.Effect<A, E, R>,\n    summary: Effect.Effect<B, E2, R2>,\n    f: (start: B, end: B) => C\n  ): Effect.Effect<[C, A], E2 | E, R2 | R> =>\n    core.flatMap(\n      summary,\n      (start) => core.flatMap(self, (value) => core.map(summary, (end) => [f(start, end), value]))\n    )\n)\n\n/* @internal */\nexport const tagMetrics = dual<\n  {\n    (key: string, value: string): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n    (\n      values: Record<string, string>\n    ): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  },\n  {\n    <A, E, R>(effect: Effect.Effect<A, E, R>, key: string, value: string): Effect.Effect<A, E, R>\n    <A, E, R>(effect: Effect.Effect<A, E, R>, values: Record<string, string>): Effect.Effect<A, E, R>\n  }\n>((args) => core.isEffect(args[0]), function() {\n  return labelMetrics(\n    arguments[0],\n    typeof arguments[1] === \"string\"\n      ? [metricLabel.make(arguments[1], arguments[2])]\n      : Object.entries<string>(arguments[1]).map(([k, v]) => metricLabel.make(k, v))\n  )\n})\n\n/* @internal */\nexport const labelMetrics = dual<\n  (labels: Iterable<MetricLabel.MetricLabel>) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, labels: Iterable<MetricLabel.MetricLabel>) => Effect.Effect<A, E, R>\n>(\n  2,\n  (self, labels) => core.fiberRefLocallyWith(self, core.currentMetricLabels, (old) => Arr.union(old, labels))\n)\n\n/* @internal */\nexport const takeUntil: {\n  <A, R, E>(\n    predicate: (a: Types.NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>\n  ): (elements: Iterable<A>) => Effect.Effect<Array<A>, E, R>\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: Types.NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>\n  ): Effect.Effect<Array<A>, E, R>\n} = dual(\n  2,\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: Types.NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>\n  ): Effect.Effect<Array<A>, E, R> =>\n    core.suspend(() => {\n      const iterator = elements[Symbol.iterator]()\n      const builder: Array<A> = []\n      let next: IteratorResult<A, any>\n      let effect: Effect.Effect<boolean, E, R> = core.succeed(false)\n      let i = 0\n      while ((next = iterator.next()) && !next.done) {\n        const a = next.value\n        const index = i++\n        effect = core.flatMap(effect, (bool) => {\n          if (bool) {\n            return core.succeed(true)\n          }\n          builder.push(a)\n          return predicate(a, index)\n        })\n      }\n      return core.map(effect, () => builder)\n    })\n)\n\n/* @internal */\nexport const takeWhile = dual<\n  <A, E, R>(\n    predicate: (a: Types.NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>\n  ) => (elements: Iterable<A>) => Effect.Effect<Array<A>, E, R>,\n  <A, E, R>(\n    elements: Iterable<A>,\n    predicate: (a: Types.NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>\n  ) => Effect.Effect<Array<A>, E, R>\n>(\n  2,\n  <A, E, R>(elements: Iterable<A>, predicate: (a: Types.NoInfer<A>, i: number) => Effect.Effect<boolean, E, R>) =>\n    core.suspend(() => {\n      const iterator = elements[Symbol.iterator]()\n      const builder: Array<A> = []\n      let next: IteratorResult<A, any>\n      let taking: Effect.Effect<boolean, E, R> = core.succeed(true)\n      let i = 0\n      while ((next = iterator.next()) && !next.done) {\n        const a = next.value\n        const index = i++\n        taking = core.flatMap(taking, (taking) =>\n          pipe(\n            taking ? predicate(a, index) : core.succeed(false),\n            core.map((bool) => {\n              if (bool) {\n                builder.push(a)\n              }\n              return bool\n            })\n          ))\n      }\n      return core.map(taking, () => builder)\n    })\n)\n\n/* @internal */\nexport const tapBoth = dual<\n  <E, X, E2, R2, A, X1, E3, R3>(\n    options: {\n      readonly onFailure: (e: Types.NoInfer<E>) => Effect.Effect<X, E2, R2>\n      readonly onSuccess: (a: Types.NoInfer<A>) => Effect.Effect<X1, E3, R3>\n    }\n  ) => <R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E2 | E3, R | R2 | R3>,\n  <A, E, R, X, E2, R2, X1, E3, R3>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly onFailure: (e: E) => Effect.Effect<X, E2, R2>\n      readonly onSuccess: (a: A) => Effect.Effect<X1, E3, R3>\n    }\n  ) => Effect.Effect<A, E | E2 | E3, R | R2 | R3>\n>(2, (self, { onFailure, onSuccess }) =>\n  core.matchCauseEffect(self, {\n    onFailure: (cause) => {\n      const either = internalCause.failureOrCause(cause)\n      switch (either._tag) {\n        case \"Left\": {\n          return core.zipRight(onFailure(either.left as any), core.failCause(cause))\n        }\n        case \"Right\": {\n          return core.failCause(cause)\n        }\n      }\n    },\n    onSuccess: (a) => core.as(onSuccess(a as any), a)\n  }))\n\n/* @internal */\nexport const tapDefect = dual<\n  <X, E2, R2>(\n    f: (cause: Cause.Cause<never>) => Effect.Effect<X, E2, R2>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E2, R | R2>,\n  <A, E, R, X, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (cause: Cause.Cause<never>) => Effect.Effect<X, E2, R2>\n  ) => Effect.Effect<A, E | E2, R | R2>\n>(2, (self, f) =>\n  core.catchAllCause(self, (cause) =>\n    Option.match(internalCause.keepDefects(cause), {\n      onNone: () => core.failCause(cause),\n      onSome: (a) => core.zipRight(f(a), core.failCause(cause))\n    })))\n\n/* @internal */\nexport const tapError = dual<\n  <E, X, E2, R2>(\n    f: (e: Types.NoInfer<E>) => Effect.Effect<X, E2, R2>\n  ) => <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E2, R | R2>,\n  <A, E, R, X, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (e: E) => Effect.Effect<X, E2, R2>\n  ) => Effect.Effect<A, E | E2, R | R2>\n>(2, (self, f) =>\n  core.matchCauseEffect(self, {\n    onFailure: (cause) => {\n      const either = internalCause.failureOrCause(cause)\n      switch (either._tag) {\n        case \"Left\":\n          return core.zipRight(f(either.left as any), core.failCause(cause))\n        case \"Right\":\n          return core.failCause(cause)\n      }\n    },\n    onSuccess: core.succeed\n  }))\n\n/* @internal */\nexport const tapErrorTag = dual<\n  <K extends (E extends { _tag: string } ? E[\"_tag\"] : never), E, A1, E1, R1>(\n    k: K,\n    f: (e: Extract<E, { _tag: K }>) => Effect.Effect<A1, E1, R1>\n  ) => <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E1, R | R1>,\n  <A, E, R, K extends (E extends { _tag: string } ? E[\"_tag\"] : never), A1, E1, R1>(\n    self: Effect.Effect<A, E, R>,\n    k: K,\n    f: (e: Extract<E, { _tag: K }>) => Effect.Effect<A1, E1, R1>\n  ) => Effect.Effect<A, E | E1, R | R1>\n>(3, (self, k, f) =>\n  tapError(self, (e) => {\n    if (Predicate.isTagged(e, k)) {\n      return f(e as any)\n    }\n    return core.void as any\n  }))\n\n/* @internal */\nexport const tapErrorCause = dual<\n  <E, X, E2, R2>(\n    f: (cause: Cause.Cause<Types.NoInfer<E>>) => Effect.Effect<X, E2, R2>\n  ) => <A, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E2, R | R2>,\n  <A, E, R, X, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (cause: Cause.Cause<E>) => Effect.Effect<X, E2, R2>\n  ) => Effect.Effect<A, E | E2, R | R2>\n>(2, (self, f) =>\n  core.matchCauseEffect(self, {\n    onFailure: (cause) => core.zipRight(f(cause), core.failCause(cause)),\n    onSuccess: core.succeed\n  }))\n\n/* @internal */\nexport const timed = <A, E, R>(\n  self: Effect.Effect<A, E, R>\n): Effect.Effect<[duration: Duration.Duration, result: A], E, R> => timedWith(self, Clock.currentTimeNanos)\n\n/* @internal */\nexport const timedWith = dual<\n  <E1, R1>(\n    nanoseconds: Effect.Effect<bigint, E1, R1>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<[Duration.Duration, A], E | E1, R | R1>,\n  <A, E, R, E1, R1>(\n    self: Effect.Effect<A, E, R>,\n    nanoseconds: Effect.Effect<bigint, E1, R1>\n  ) => Effect.Effect<[Duration.Duration, A], E | E1, R | R1>\n>(\n  2,\n  (self, nanos) => summarized(self, nanos, (start, end) => Duration.nanos(end - start))\n)\n\n/* @internal */\nexport const tracerWith: <A, E, R>(f: (tracer: Tracer.Tracer) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R> =\n  Tracer.tracerWith\n\n/** @internal */\nexport const tracer: Effect.Effect<Tracer.Tracer> = tracerWith(core.succeed)\n\n/* @internal */\nexport const tryPromise: {\n  <A, E>(\n    options: {\n      readonly try: (signal: AbortSignal) => PromiseLike<A>\n      readonly catch: (error: unknown) => E\n    }\n  ): Effect.Effect<A, E>\n  <A>(evaluate: (signal: AbortSignal) => PromiseLike<A>): Effect.Effect<A, Cause.UnknownException>\n} = <A, E>(\n  arg: ((signal: AbortSignal) => PromiseLike<A>) | {\n    readonly try: (signal: AbortSignal) => PromiseLike<A>\n    readonly catch: (error: unknown) => E\n  }\n): Effect.Effect<A, E | Cause.UnknownException> => {\n  let evaluate: (signal?: AbortSignal) => PromiseLike<A>\n  let catcher: ((error: unknown) => E) | undefined = undefined\n  if (typeof arg === \"function\") {\n    evaluate = arg as (signal?: AbortSignal) => PromiseLike<A>\n  } else {\n    evaluate = arg.try as (signal?: AbortSignal) => PromiseLike<A>\n    catcher = arg.catch\n  }\n  const fail = (e: unknown) =>\n    catcher\n      ? core.failSync(() => catcher(e))\n      : core.fail(new core.UnknownException(e, \"An unknown error occurred in Effect.tryPromise\"))\n\n  if (evaluate.length >= 1) {\n    return core.async((resolve, signal) => {\n      try {\n        evaluate(signal).then(\n          (a) => resolve(core.exitSucceed(a)),\n          (e) => resolve(fail(e))\n        )\n      } catch (e) {\n        resolve(fail(e))\n      }\n    })\n  }\n\n  return core.async((resolve) => {\n    try {\n      evaluate()\n        .then(\n          (a) => resolve(core.exitSucceed(a)),\n          (e) => resolve(fail(e))\n        )\n    } catch (e) {\n      resolve(fail(e))\n    }\n  })\n}\n\n/* @internal */\nexport const tryMap = dual<\n  <A, B, E1>(\n    options: {\n      readonly try: (a: A) => B\n      readonly catch: (error: unknown) => E1\n    }\n  ) => <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E | E1, R>,\n  <A, E, R, B, E1>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly try: (a: A) => B\n      readonly catch: (error: unknown) => E1\n    }\n  ) => Effect.Effect<B, E | E1, R>\n>(2, (self, options) =>\n  core.flatMap(self, (a) =>\n    try_({\n      try: () => options.try(a),\n      catch: options.catch\n    })))\n\n/* @internal */\nexport const tryMapPromise = dual<\n  <A, B, E1>(\n    options: {\n      readonly try: (a: A, signal: AbortSignal) => PromiseLike<B>\n      readonly catch: (error: unknown) => E1\n    }\n  ) => <E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<B, E | E1, R>,\n  <A, E, R, B, E1>(\n    self: Effect.Effect<A, E, R>,\n    options: {\n      readonly try: (a: A, signal: AbortSignal) => PromiseLike<B>\n      readonly catch: (error: unknown) => E1\n    }\n  ) => Effect.Effect<B, E | E1, R>\n>(2, <A, E, R, B, E1>(\n  self: Effect.Effect<A, E, R>,\n  options: {\n    readonly try: (a: A, signal: AbortSignal) => PromiseLike<B>\n    readonly catch: (error: unknown) => E1\n  }\n) =>\n  core.flatMap(self, (a) =>\n    tryPromise({\n      try: options.try.length >= 1\n        ? (signal) => options.try(a, signal)\n        : () => (options.try as (a: A) => PromiseLike<B>)(a),\n      catch: options.catch\n    })))\n\n/* @internal */\nexport const unless = dual<\n  (condition: LazyArg<boolean>) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<Option.Option<A>, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, condition: LazyArg<boolean>) => Effect.Effect<Option.Option<A>, E, R>\n>(2, (self, condition) =>\n  core.suspend(() =>\n    condition()\n      ? succeedNone\n      : asSome(self)\n  ))\n\n/* @internal */\nexport const unlessEffect = dual<\n  <E2, R2>(\n    condition: Effect.Effect<boolean, E2, R2>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<Option.Option<A>, E | E2, R | R2>,\n  <A, E, R, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    condition: Effect.Effect<boolean, E2, R2>\n  ) => Effect.Effect<Option.Option<A>, E | E2, R | R2>\n>(2, (self, condition) => core.flatMap(condition, (b) => (b ? succeedNone : asSome(self))))\n\n/* @internal */\nexport const unsandbox = <A, E, R>(self: Effect.Effect<A, Cause.Cause<E>, R>) =>\n  mapErrorCause(self, internalCause.flatten)\n\n/* @internal */\nexport const updateFiberRefs = (\n  f: (fiberId: FiberId.Runtime, fiberRefs: FiberRefs.FiberRefs) => FiberRefs.FiberRefs\n): Effect.Effect<void> =>\n  core.withFiberRuntime((state) => {\n    state.setFiberRefs(f(state.id(), state.getFiberRefs()))\n    return core.void\n  })\n\n/* @internal */\nexport const updateService = dual<\n  <I, S>(\n    tag: Context.Tag<I, S>,\n    f: (service: Types.NoInfer<S>) => Types.NoInfer<S>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R | I>,\n  <A, E, R, I, S>(\n    self: Effect.Effect<A, E, R>,\n    tag: Context.Tag<I, S>,\n    f: (service: Types.NoInfer<S>) => Types.NoInfer<S>\n  ) => Effect.Effect<A, E, R | I>\n>(3, <A, E, R, I, S>(\n  self: Effect.Effect<A, E, R>,\n  tag: Context.Tag<I, S>,\n  f: (service: Types.NoInfer<S>) => Types.NoInfer<S>\n) =>\n  core.mapInputContext(self, (context) =>\n    Context.add(\n      context,\n      tag,\n      f(Context.unsafeGet(context, tag))\n    )) as Effect.Effect<A, E, R | I>)\n\n/* @internal */\nexport const when = dual<\n  (condition: LazyArg<boolean>) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<Option.Option<A>, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, condition: LazyArg<boolean>) => Effect.Effect<Option.Option<A>, E, R>\n>(2, (self, condition) =>\n  core.suspend(() =>\n    condition()\n      ? core.map(self, Option.some)\n      : core.succeed(Option.none())\n  ))\n\n/* @internal */\nexport const whenFiberRef = dual<\n  <S>(\n    fiberRef: FiberRef.FiberRef<S>,\n    predicate: Predicate.Predicate<S>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<[S, Option.Option<A>], E, R>,\n  <A, E, R, S>(\n    self: Effect.Effect<A, E, R>,\n    fiberRef: FiberRef.FiberRef<S>,\n    predicate: Predicate.Predicate<S>\n  ) => Effect.Effect<[S, Option.Option<A>], E, R>\n>(\n  3,\n  <A, E, R, S>(\n    self: Effect.Effect<A, E, R>,\n    fiberRef: FiberRef.FiberRef<S>,\n    predicate: Predicate.Predicate<S>\n  ) =>\n    core.flatMap(core.fiberRefGet(fiberRef), (s) =>\n      predicate(s)\n        ? core.map(self, (a) => [s, Option.some(a)])\n        : core.succeed<[S, Option.Option<A>]>([s, Option.none()]))\n)\n\n/* @internal */\nexport const whenRef = dual<\n  <S>(\n    ref: Ref.Ref<S>,\n    predicate: Predicate.Predicate<S>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<[S, Option.Option<A>], E, R>,\n  <A, E, R, S>(\n    self: Effect.Effect<A, E, R>,\n    ref: Ref.Ref<S>,\n    predicate: Predicate.Predicate<S>\n  ) => Effect.Effect<[S, Option.Option<A>], E, R>\n>(\n  3,\n  <A, E, R, S>(self: Effect.Effect<A, E, R>, ref: Ref.Ref<S>, predicate: Predicate.Predicate<S>) =>\n    core.flatMap(Ref.get(ref), (s) =>\n      predicate(s)\n        ? core.map(self, (a) => [s, Option.some(a)])\n        : core.succeed<[S, Option.Option<A>]>([s, Option.none()]))\n)\n\n/* @internal */\nexport const withMetric = dual<\n  <Type, In, Out>(\n    metric: Metric.Metric<Type, In, Out>\n  ) => <A extends In, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A extends In, E, R, Type, In, Out>(\n    self: Effect.Effect<A, E, R>,\n    metric: Metric.Metric<Type, In, Out>\n  ) => Effect.Effect<A, E, R>\n>(2, (self, metric) => metric(self))\n\n/** @internal */\nexport const serviceFunctionEffect = <T extends Effect.Effect<any, any, any>, Args extends Array<any>, A, E, R>(\n  getService: T,\n  f: (_: Effect.Effect.Success<T>) => (...args: Args) => Effect.Effect<A, E, R>\n) =>\n(...args: Args): Effect.Effect<A, E | Effect.Effect.Error<T>, R | Effect.Effect.Context<T>> =>\n  core.flatMap(getService, (a) => f(a)(...args))\n\n/** @internal */\nexport const serviceFunction = <T extends Effect.Effect<any, any, any>, Args extends Array<any>, A>(\n  getService: T,\n  f: (_: Effect.Effect.Success<T>) => (...args: Args) => A\n) =>\n(...args: Args): Effect.Effect<A, Effect.Effect.Error<T>, Effect.Effect.Context<T>> =>\n  core.map(getService, (a) => f(a)(...args))\n\n/** @internal */\nexport const serviceFunctions = <S, SE, SR>(\n  getService: Effect.Effect<S, SE, SR>\n): {\n  [k in keyof S as S[k] extends (...args: Array<any>) => Effect.Effect<any, any, any> ? k : never]: S[k] extends\n    (...args: infer Args) => Effect.Effect<infer A, infer E, infer R>\n    ? (...args: Args) => Effect.Effect<A, E | SE, R | SR>\n    : never\n} =>\n  new Proxy({} as any, {\n    get(_target: any, prop: any, _receiver) {\n      return (...args: Array<any>) => core.flatMap(getService, (s: any) => s[prop](...args))\n    }\n  })\n\n/** @internal */\nexport const serviceConstants = <S, SE, SR>(\n  getService: Effect.Effect<S, SE, SR>\n): {\n  [k in { [k in keyof S]: k }[keyof S]]: S[k] extends Effect.Effect<infer A, infer E, infer R> ?\n    Effect.Effect<A, E | SE, R | SR> :\n    Effect.Effect<S[k], SE, SR>\n} =>\n  new Proxy({} as any, {\n    get(_target: any, prop: any, _receiver) {\n      return core.flatMap(getService, (s: any) => core.isEffect(s[prop]) ? s[prop] : core.succeed(s[prop]))\n    }\n  })\n\n/** @internal */\nexport const serviceMembers = <S, SE, SR>(getService: Effect.Effect<S, SE, SR>): {\n  functions: {\n    [k in keyof S as S[k] extends (...args: Array<any>) => Effect.Effect<any, any, any> ? k : never]: S[k] extends\n      (...args: infer Args) => Effect.Effect<infer A, infer E, infer R>\n      ? (...args: Args) => Effect.Effect<A, E | SE, R | SR>\n      : never\n  }\n  constants: {\n    [k in { [k in keyof S]: k }[keyof S]]: S[k] extends Effect.Effect<infer A, infer E, infer R> ?\n      Effect.Effect<A, E | SE, R | SR> :\n      Effect.Effect<S[k], SE, SR>\n  }\n} => ({\n  functions: serviceFunctions(getService) as any,\n  constants: serviceConstants(getService)\n})\n\n/** @internal */\nexport const serviceOption = <I, S>(tag: Context.Tag<I, S>) => core.map(core.context<never>(), Context.getOption(tag))\n\n/** @internal */\nexport const serviceOptional = <I, S>(tag: Context.Tag<I, S>) =>\n  core.flatMap(core.context<never>(), Context.getOption(tag))\n\n// -----------------------------------------------------------------------------\n// tracing\n// -----------------------------------------------------------------------------\n\n/* @internal */\nexport const annotateCurrentSpan: {\n  (key: string, value: unknown): Effect.Effect<void>\n  (values: Record<string, unknown>): Effect.Effect<void>\n} = function(): Effect.Effect<void> {\n  const args = arguments\n  return ignore(core.flatMap(\n    currentSpan,\n    (span) =>\n      core.sync(() => {\n        if (typeof args[0] === \"string\") {\n          span.attribute(args[0], args[1])\n        } else {\n          for (const key in args[0]) {\n            span.attribute(key, args[0][key])\n          }\n        }\n      })\n  ))\n}\n\n/* @internal */\nexport const linkSpanCurrent: {\n  (span: Tracer.AnySpan, attributes?: Readonly<Record<string, unknown>> | undefined): Effect.Effect<void>\n  (links: ReadonlyArray<Tracer.SpanLink>): Effect.Effect<void>\n} = function(): Effect.Effect<void> {\n  const args = arguments\n  const links: ReadonlyArray<Tracer.SpanLink> = Array.isArray(args[0])\n    ? args[0]\n    : [{ _tag: \"SpanLink\", span: args[0], attributes: args[1] ?? {} }]\n  return ignore(core.flatMap(\n    currentSpan,\n    (span) => core.sync(() => span.addLinks(links))\n  ))\n}\n\n/* @internal */\nexport const annotateSpans = dual<\n  {\n    (key: string, value: unknown): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n    (\n      values: Record<string, unknown>\n    ): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  },\n  {\n    <A, E, R>(effect: Effect.Effect<A, E, R>, key: string, value: unknown): Effect.Effect<A, E, R>\n    <A, E, R>(effect: Effect.Effect<A, E, R>, values: Record<string, unknown>): Effect.Effect<A, E, R>\n  }\n>(\n  (args) => core.isEffect(args[0]),\n  function<A, E, R>() {\n    const args = arguments\n    return core.fiberRefLocallyWith(\n      args[0] as Effect.Effect<A, E, R>,\n      core.currentTracerSpanAnnotations,\n      typeof args[1] === \"string\"\n        ? HashMap.set(args[1], args[2])\n        : (annotations) =>\n          Object.entries(args[1] as Record<string, unknown>).reduce(\n            (acc, [key, value]) => HashMap.set(acc, key, value),\n            annotations\n          )\n    )\n  }\n)\n\n/** @internal */\nexport const currentParentSpan: Effect.Effect<Tracer.AnySpan, Cause.NoSuchElementException> = serviceOptional(\n  internalTracer.spanTag\n)\n\n/** @internal */\nexport const currentSpan: Effect.Effect<Tracer.Span, Cause.NoSuchElementException> = core.flatMap(\n  core.context<never>(),\n  (context) => {\n    const span = context.unsafeMap.get(internalTracer.spanTag.key) as Tracer.AnySpan | undefined\n    return span !== undefined && span._tag === \"Span\"\n      ? core.succeed(span)\n      : core.fail(new core.NoSuchElementException())\n  }\n)\n\n/* @internal */\nexport const linkSpans = dual<\n  (\n    span: Tracer.AnySpan,\n    attributes?: Record<string, unknown>\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    span: Tracer.AnySpan,\n    attributes?: Record<string, unknown>\n  ) => Effect.Effect<A, E, R>\n>(\n  (args) => core.isEffect(args[0]),\n  (self, span, attributes) =>\n    core.fiberRefLocallyWith(\n      self,\n      core.currentTracerSpanLinks,\n      Chunk.append(\n        {\n          _tag: \"SpanLink\",\n          span,\n          attributes: attributes ?? {}\n        } as const\n      )\n    )\n)\n\nconst bigint0 = BigInt(0)\n\nconst filterDisablePropagation: (self: Option.Option<Tracer.AnySpan>) => Option.Option<Tracer.AnySpan> = Option.flatMap(\n  (span) =>\n    Context.get(span.context, internalTracer.DisablePropagation)\n      ? span._tag === \"Span\" ? filterDisablePropagation(span.parent) : Option.none()\n      : Option.some(span)\n)\n\n/** @internal */\nexport const unsafeMakeSpan = <XA, XE>(\n  fiber: FiberRuntime<XA, XE>,\n  name: string,\n  options: Tracer.SpanOptions\n) => {\n  const disablePropagation = !fiber.getFiberRef(core.currentTracerEnabled) ||\n    (options.context && Context.get(options.context, internalTracer.DisablePropagation))\n  const context = fiber.getFiberRef(core.currentContext)\n  const parent = options.parent\n    ? Option.some(options.parent)\n    : options.root\n    ? Option.none()\n    : filterDisablePropagation(Context.getOption(context, internalTracer.spanTag))\n\n  let span: Tracer.Span\n\n  if (disablePropagation) {\n    span = core.noopSpan({\n      name,\n      parent,\n      context: Context.add(options.context ?? Context.empty(), internalTracer.DisablePropagation, true)\n    })\n  } else {\n    const services = fiber.getFiberRef(defaultServices.currentServices)\n\n    const tracer = Context.get(services, internalTracer.tracerTag)\n    const clock = Context.get(services, Clock.Clock)\n    const timingEnabled = fiber.getFiberRef(core.currentTracerTimingEnabled)\n\n    const fiberRefs = fiber.getFiberRefs()\n    const annotationsFromEnv = FiberRefs.get(fiberRefs, core.currentTracerSpanAnnotations)\n    const linksFromEnv = FiberRefs.get(fiberRefs, core.currentTracerSpanLinks)\n\n    const links = linksFromEnv._tag === \"Some\" ?\n      options.links !== undefined ?\n        [\n          ...Chunk.toReadonlyArray(linksFromEnv.value),\n          ...(options.links ?? [])\n        ] :\n        Chunk.toReadonlyArray(linksFromEnv.value) :\n      options.links ?? Arr.empty()\n\n    span = tracer.span(\n      name,\n      parent,\n      options.context ?? Context.empty(),\n      links,\n      timingEnabled ? clock.unsafeCurrentTimeNanos() : bigint0,\n      options.kind ?? \"internal\"\n    )\n\n    if (annotationsFromEnv._tag === \"Some\") {\n      HashMap.forEach(annotationsFromEnv.value, (value, key) => span.attribute(key, value))\n    }\n    if (options.attributes !== undefined) {\n      Object.entries(options.attributes).forEach(([k, v]) => span.attribute(k, v))\n    }\n  }\n\n  if (typeof options.captureStackTrace === \"function\") {\n    internalCause.spanToTrace.set(span, options.captureStackTrace)\n  }\n\n  return span\n}\n\n/** @internal */\nexport const makeSpan = (\n  name: string,\n  options?: Tracer.SpanOptions\n): Effect.Effect<Tracer.Span> => {\n  options = internalTracer.addSpanStackTrace(options)\n  return core.withFiberRuntime((fiber) => core.succeed(unsafeMakeSpan(fiber, name, options)))\n}\n\n/* @internal */\nexport const spanAnnotations: Effect.Effect<HashMap.HashMap<string, unknown>> = core\n  .fiberRefGet(core.currentTracerSpanAnnotations)\n\n/* @internal */\nexport const spanLinks: Effect.Effect<Chunk.Chunk<Tracer.SpanLink>> = core\n  .fiberRefGet(core.currentTracerSpanLinks)\n\n/** @internal */\nexport const endSpan = <A, E>(span: Tracer.Span, exit: Exit<A, E>, clock: Clock.Clock, timingEnabled: boolean) =>\n  core.sync(() => {\n    if (span.status._tag === \"Ended\") {\n      return\n    }\n    if (core.exitIsFailure(exit) && internalCause.spanToTrace.has(span)) {\n      // https://opentelemetry.io/docs/specs/semconv/registry/attributes/code/#code-stacktrace\n      span.attribute(\"code.stacktrace\", internalCause.spanToTrace.get(span)!())\n    }\n    span.end(timingEnabled ? clock.unsafeCurrentTimeNanos() : bigint0, exit)\n  })\n\n/** @internal */\nexport const useSpan: {\n  <A, E, R>(name: string, evaluate: (span: Tracer.Span) => Effect.Effect<A, E, R>): Effect.Effect<A, E, R>\n  <A, E, R>(\n    name: string,\n    options: Tracer.SpanOptions,\n    evaluate: (span: Tracer.Span) => Effect.Effect<A, E, R>\n  ): Effect.Effect<A, E, R>\n} = <A, E, R>(\n  name: string,\n  ...args: [evaluate: (span: Tracer.Span) => Effect.Effect<A, E, R>] | [\n    options: any,\n    evaluate: (span: Tracer.Span) => Effect.Effect<A, E, R>\n  ]\n) => {\n  const options = internalTracer.addSpanStackTrace(args.length === 1 ? undefined : args[0])\n  const evaluate: (span: Tracer.Span) => Effect.Effect<A, E, R> = args[args.length - 1]\n\n  return core.withFiberRuntime<A, E, R>((fiber) => {\n    const span = unsafeMakeSpan(fiber, name, options)\n    const timingEnabled = fiber.getFiberRef(core.currentTracerTimingEnabled)\n    const clock = Context.get(fiber.getFiberRef(defaultServices.currentServices), clockTag)\n    return core.onExit(evaluate(span), (exit) => endSpan(span, exit, clock, timingEnabled))\n  })\n}\n\n/** @internal */\nexport const withParentSpan = dual<\n  (\n    span: Tracer.AnySpan\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, Tracer.ParentSpan>>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, span: Tracer.AnySpan) => Effect.Effect<A, E, Exclude<R, Tracer.ParentSpan>>\n>(2, (self, span) => provideService(self, internalTracer.spanTag, span))\n\n/** @internal */\nexport const withSpan: {\n  (\n    name: string,\n    options?: Tracer.SpanOptions | undefined\n  ): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, Tracer.ParentSpan>>\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    name: string,\n    options?: Tracer.SpanOptions | undefined\n  ): Effect.Effect<A, E, Exclude<R, Tracer.ParentSpan>>\n} = function() {\n  const dataFirst = typeof arguments[0] !== \"string\"\n  const name = dataFirst ? arguments[1] : arguments[0]\n  const options = internalTracer.addSpanStackTrace(dataFirst ? arguments[2] : arguments[1])\n  if (dataFirst) {\n    const self = arguments[0]\n    return useSpan(name, options, (span) => withParentSpan(self, span))\n  }\n  return (self: Effect.Effect<any, any, any>) => useSpan(name, options, (span) => withParentSpan(self, span))\n} as any\n\nexport const functionWithSpan = <Args extends Array<any>, Ret extends Effect.Effect<any, any, any>>(\n  options: {\n    readonly body: (...args: Args) => Ret\n    readonly options: Effect.FunctionWithSpanOptions | ((...args: Args) => Effect.FunctionWithSpanOptions)\n    readonly captureStackTrace?: boolean | undefined\n  }\n): (...args: Args) => Unify<Ret> =>\n  (function(this: any) {\n    let captureStackTrace: LazyArg<string | undefined> | boolean = options.captureStackTrace ?? false\n    if (options.captureStackTrace !== false) {\n      const limit = Error.stackTraceLimit\n      Error.stackTraceLimit = 2\n      const error = new Error()\n      Error.stackTraceLimit = limit\n      let cache: false | string = false\n      captureStackTrace = () => {\n        if (cache !== false) {\n          return cache\n        }\n        if (error.stack) {\n          const stack = error.stack.trim().split(\"\\n\")\n          cache = stack.slice(2).join(\"\\n\").trim()\n          return cache\n        }\n      }\n    }\n    return core.suspend(() => {\n      const opts = typeof options.options === \"function\"\n        ? options.options.apply(null, arguments as any)\n        : options.options\n      return withSpan(\n        core.suspend(() => internalCall(() => options.body.apply(this, arguments as any))),\n        opts.name,\n        {\n          ...opts,\n          captureStackTrace\n        }\n      )\n    })\n  }) as any\n\n// -------------------------------------------------------------------------------------\n// optionality\n// -------------------------------------------------------------------------------------\n\n/* @internal */\nexport const fromNullable = <A>(value: A): Effect.Effect<NonNullable<A>, Cause.NoSuchElementException> =>\n  value == null ? core.fail(new core.NoSuchElementException()) : core.succeed(value as NonNullable<A>)\n\n/* @internal */\nexport const optionFromOptional = <A, E, R>(\n  self: Effect.Effect<A, E, R>\n): Effect.Effect<Option.Option<A>, Exclude<E, Cause.NoSuchElementException>, R> =>\n  core.catchAll(\n    core.map(self, Option.some),\n    (error) =>\n      core.isNoSuchElementException(error) ?\n        succeedNone :\n        core.fail(error as Exclude<E, Cause.NoSuchElementException>)\n  )\n"],"names":["Arr","Chunk","Clock","Context","Duration","FiberRefs","constFalse","constTrue","constVoid","dual","identity","pipe","HashMap","HashSet","List","LogLevel","LogSpan","Option","Predicate","Ref","Tracer","internalCall","internalCause","clockTag","core","defaultServices","doNotation","fiberRefsPatch","metricLabel","runtimeFlags","internalTracer","annotateLogs","args","isEffect","arguments","fiberRefLocallyWith","currentLogAnnotations","set","annotations","Object","entries","reduce","acc","key","value","asSome","self","map","some","asSomeError","mapError","try_","arg","evaluate","onFailure","undefined","try","catch","suspend","succeed","error","fail","UnknownException","_catch","tag","options","catchAll","e","hasProperty","failure","catchAllDefect","f","catchAllCause","cause","option","find","_","isDieType","none","_tag","failCause","defect","catchSomeCause","matchCauseEffect","onSuccess","catchSomeDefect","pf","optionEffect","catchTag","length","predicate","isTagged","i","catchIf","catchTags","cases","keys","isString","includes","matchCause","empty","clockWith","clock","delay","duration","zipRight","sleep","descriptorWith","withFiberRuntime","state","status","id","interruptors","getFiberRef","currentInterruptedCause","allowInterrupt","descriptor","size","interrupt","void","diffFiberRefs","summarized","fiberRefs","diff","diffFiberRefsAndRuntimeFlags","zip","refs","flags","refsNew","flagsNew","Do","bind","flatMap","bindTo","let_","dropUntil","elements","iterator","Symbol","builder","next","dropping","done","a","index","bool","push","dropWhile","d","b","contextWith","context","eventually","orElse","yieldNow","filterMap","forEachSequential","filterOrDie","orDieWith","filterOrElse","dieSync","filterOrDieMessage","message","dieMessage","liftPredicate","orFailWith","filterOrFail","NoSuchElementException","failSync","findFirst","findLoop","result","firstSuccessOf","effects","list","fromIterable","isNonEmpty","IllegalArgumentException","tailNonEmpty","headNonEmpty","left","right","flipWith","flip","match","matchEffect","every","forAllLoop","forever","loop","getFiberRefs","head","as","ignore","ignoreLogged","logDebug","inheritFiberRefs","childFiberRefs","updateFiberRefs","parentFiberId","parentFiberRefs","joinAs","isFailure","isSuccess","iterate","initial","while","body","z2","logWithLevel","level","levelOption","fromNullable","len","msg","isCause","sequential","slice","fiberState","log","logTrace","Trace","Debug","logInfo","Info","logWarning","Warning","logError","Error","logFatal","Fatal","withLogSpan","effect","label","currentTimeMillis","now","currentLogSpan","prepend","make","logAnnotations","fiberRefGet","discard","loopDiscard","step","loopInternal","cont","inc","sync","mapAccum","z","mapErrorCause","c","failCauseSync","memoize","deferredMake","deferred","intoDeferred","once","complete","deferredAwait","patch","patchFiberRefs","updateRuntimeFlags","merge","negate","ref","asVoid","whenEffect","getAndSet","orElseFail","orElseSucceed","parallelErrors","errors","failures","fiberId","promise","async","resolve","signal","then","exitSucceed","exitDie","provideService","service","contextWithEffect","env","provideContext","add","provideServiceEffect","random","randomWith","zero","el","reduceRight","reduceWhile","reduceWhileLoop","nextState","repeatN","n","repeatNLoop","sandbox","setFiberRefs","setAll","succeedNone","succeedSome","summary","start","end","tagMetrics","labelMetrics","k","v","labels","currentMetricLabels","old","union","takeUntil","takeWhile","taking","tapBoth","either","failureOrCause","tapDefect","keepDefects","onNone","onSome","tapError","tapErrorTag","tapErrorCause","timed","timedWith","currentTimeNanos","nanos","tracerWith","tracer","tryPromise","catcher","tryMap","tryMapPromise","unless","condition","unlessEffect","unsandbox","flatten","updateService","mapInputContext","unsafeGet","when","whenFiberRef","fiberRef","s","whenRef","get","withMetric","metric","serviceFunctionEffect","getService","serviceFunction","serviceFunctions","Proxy","_target","prop","_receiver","serviceConstants","serviceMembers","functions","constants","serviceOption","getOption","serviceOptional","annotateCurrentSpan","currentSpan","span","attribute","linkSpanCurrent","links","Array","isArray","attributes","addLinks","annotateSpans","currentTracerSpanAnnotations","currentParentSpan","spanTag","unsafeMap","linkSpans","currentTracerSpanLinks","append","bigint0","BigInt","filterDisablePropagation","DisablePropagation","parent","unsafeMakeSpan","fiber","name","disablePropagation","currentTracerEnabled","currentContext","root","noopSpan","services","currentServices","tracerTag","timingEnabled","currentTracerTimingEnabled","annotationsFromEnv","linksFromEnv","toReadonlyArray","unsafeCurrentTimeNanos","kind","forEach","captureStackTrace","spanToTrace","makeSpan","addSpanStackTrace","spanAnnotations","spanLinks","endSpan","exit","exitIsFailure","has","useSpan","onExit","withParentSpan","withSpan","dataFirst","functionWithSpan","limit","stackTraceLimit","cache","stack","trim","split","join","opts","apply","optionFromOptional","isNoSuchElementException"],"mappings":"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","ignoreList":[],"debugId":null}}]
}