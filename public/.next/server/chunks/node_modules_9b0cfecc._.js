module.exports = [
"[project]/node_modules/@kinde/jwt-decoder/dist/jwt-decoder.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TokenPart",
    ()=>s,
    "jwtDecoder",
    ()=>c
]);
var s = /* @__PURE__ */ ((e)=>(e[e.header = 0] = "header", e[e.body = 1] = "body", e))(s || {});
function c(e, t) {
    if (!e) return null;
    const r = e.split(".");
    if (r.length !== 3) return null;
    const n = r[t ?? 1].replace(/-/g, "+").replace(/_/g, "/"), o = decodeURIComponent(atob(n).split("").map((l)=>"%" + ("00" + l.charCodeAt(0).toString(16)).slice(-2)).join(""));
    return JSON.parse(o);
}
;
}),
"[project]/node_modules/@kinde/js-utils/dist/main--ltuV3nd.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "$",
    ()=>K,
    "A",
    ()=>Ne,
    "B",
    ()=>De,
    "C",
    ()=>Ve,
    "D",
    ()=>pe,
    "E",
    ()=>Ye,
    "F",
    ()=>ue,
    "G",
    ()=>We,
    "H",
    ()=>he,
    "I",
    ()=>je,
    "J",
    ()=>C,
    "K",
    ()=>Be,
    "L",
    ()=>y,
    "M",
    ()=>He,
    "N",
    ()=>qe,
    "O",
    ()=>Ge,
    "P",
    ()=>S,
    "Q",
    ()=>Je,
    "R",
    ()=>Ze,
    "S",
    ()=>W,
    "T",
    ()=>Le,
    "U",
    ()=>de,
    "V",
    ()=>ge,
    "W",
    ()=>ye,
    "X",
    ()=>ve,
    "Y",
    ()=>Ue,
    "Z",
    ()=>Re,
    "_",
    ()=>Me,
    "a",
    ()=>c,
    "a0",
    ()=>G,
    "a1",
    ()=>J,
    "a2",
    ()=>ee,
    "a3",
    ()=>R,
    "a4",
    ()=>_,
    "b",
    ()=>a,
    "c",
    ()=>H,
    "d",
    ()=>N,
    "e",
    ()=>Ie,
    "f",
    ()=>Pe,
    "g",
    ()=>M,
    "h",
    ()=>Ee,
    "i",
    ()=>be,
    "j",
    ()=>x,
    "k",
    ()=>Z,
    "l",
    ()=>D,
    "m",
    ()=>ne,
    "n",
    ()=>v,
    "o",
    ()=>Qe,
    "p",
    ()=>$e,
    "q",
    ()=>ae,
    "r",
    ()=>Xe,
    "s",
    ()=>V,
    "t",
    ()=>Q,
    "u",
    ()=>le,
    "v",
    ()=>j,
    "w",
    ()=>Y,
    "x",
    ()=>ze,
    "y",
    ()=>Fe,
    "z",
    ()=>g
]);
var K = /* @__PURE__ */ ((e)=>(e.email = "email", e.profile = "profile", e.openid = "openid", e.offline_access = "offline", e))(K || {}), G = /* @__PURE__ */ ((e)=>(e.none = "none", e.create = "create", e.login = "login", e))(G || {}), J = /* @__PURE__ */ ((e)=>(e.organizationDetails = "organization_details", e.organizationMembers = "organization_members", e.organizationPlanDetails = "organization_plan_details", e.organizationPaymentDetails = "organization_payment_details", e.organizationPlanSelection = "organization_plan_selection", e.paymentDetails = "payment_details", e.planSelection = "plan_selection", e.planDetails = "plan_details", e.profile = "profile", e))(J || {}), ee = /* @__PURE__ */ ((e)=>(e.organizationDetails = "organization_details", e.organizationMembers = "organization_members", e.organizationPlanDetails = "organization_plan_details", e.organizationPaymentDetails = "organization_payment_details", e.organizationPlanSelection = "organization_plan_selection", e.profile = "profile", e))(ee || {}), R = /* @__PURE__ */ ((e)=>(e.logout = "logout", e.login = "login", e.register = "registration", e.token = "token", e.profile = "profile", e))(R || {}), _ = /* @__PURE__ */ ((e)=>(e[e.refreshToken = 0] = "refreshToken", e[e.cookie = 1] = "cookie", e))(_ || {});
const H = (e)=>{
    const r = (i)=>btoa(i).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
    if (e instanceof ArrayBuffer) {
        const i = new Uint8Array(e), s = String.fromCharCode(...i);
        return r(s);
    }
    const o = new TextEncoder().encode(e), n = String.fromCharCode(...o);
    return r(n);
}, M = (e = 28)=>{
    if (crypto) {
        const r = new Uint8Array(e / 2);
        return crypto.getRandomValues(r), Array.from(r, te).join("");
    } else return re(e);
};
function te(e) {
    return e.toString(16).padStart(2, "0");
}
function re(e = 28) {
    const r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let t = "";
    const o = r.length;
    for(let n = 0; n < e; n++)t += r.charAt(Math.floor(Math.random() * o));
    return t;
}
const Ie = (e)=>{
    e = e.split("?")[1];
    const r = new URLSearchParams(e);
    return {
        accessToken: r.get("access_token"),
        idToken: r.get("id_token"),
        expiresIn: +(r.get("expires_in") || 0)
    };
}, N = (e)=>e.replace(/\/$/, ""), ne = (e, r = !1)=>{
    const t = Array.isArray(e.audience) ? e.audience.join(" ") : e.audience || "", o = {
        login_hint: e.loginHint,
        is_create_org: e.isCreateOrg?.toString(),
        connection_id: e.connectionId,
        redirect_uri: e.redirectURL ? r ? e.redirectURL : N(e.redirectURL) : void 0,
        audience: t,
        scope: e.scope?.join(" ") || "email profile openid offline",
        prompt: e.prompt,
        lang: e.lang,
        org_code: e.orgCode,
        org_name: e.orgName,
        has_success_page: e.hasSuccessPage?.toString(),
        workflow_deployment_id: e.workflowDeploymentId,
        supports_reauth: e.supportsReauth?.toString(),
        plan_interest: e.planInterest,
        pricing_table_key: e.pricingTableKey,
        pages_mode: e.pagesMode
    };
    return Object.keys(o).forEach((n)=>o[n] === void 0 && delete o[n]), o;
}, L = (e)=>typeof e != "object" || e === null ? e : Array.isArray(e) ? e.map((r)=>L(r)) : Object.fromEntries(Object.entries(e).map(([r, t])=>[
            r.replace(/_([a-z])/g, (o, n)=>n.toUpperCase()),
            L(t)
        ])), oe = [
    // UTM tags
    "utm_source",
    "utm_medium",
    "utm_campaign",
    "utm_content",
    "utm_term",
    // Google Ads smart campaign tracking
    "gclid",
    "click_id",
    "hsa_acc",
    "hsa_cam",
    "hsa_grp",
    "hsa_ad",
    "hsa_src",
    "hsa_tgt",
    "hsa_kw",
    "hsa_mt",
    "hsa_net",
    "hsa_ver",
    // Marketing category
    "match_type",
    "keyword",
    "device",
    "ad_group_id",
    "campaign_id",
    "creative",
    "network",
    "ad_position",
    "fbclid",
    "li_fat_id",
    "msclkid",
    "twclid",
    "ttclid"
], Pe = async (e, r = R.login, t, o)=>{
    const n = `${e}/oauth2/auth`, i = S();
    if (t.reauthState) try {
        const f = L(JSON.parse(atob(t.reauthState)));
        t = {
            ...t,
            ...f
        }, delete t.reauthState;
    } catch (f) {
        const d = f instanceof Error ? f.message : "Unknown error";
        throw new Error(`Error handing reauth state: ${d}`);
    }
    if (!t.clientId) throw new Error("Error generating auth URL: Client ID missing");
    const s = {
        client_id: t.clientId,
        response_type: t.responseType || "code",
        ...ne(t, o?.disableUrlSanitization)
    };
    t.state || (t.state = M(32)), i && i.setSessionItem(c.state, t.state), s.state = t.state, t.nonce || (t.nonce = M(16)), s.nonce = t.nonce, i && i.setSessionItem(c.nonce, t.nonce);
    let l = "";
    if (t.codeChallenge) s.code_challenge = t.codeChallenge;
    else {
        const { codeVerifier: f, codeChallenge: d } = await se();
        l = f, i && i.setSessionItem(c.codeVerifier, f), s.code_challenge = d;
    }
    s.code_challenge_method = "S256", t.codeChallengeMethod && (s.code_challenge_method = t.codeChallengeMethod), !t.prompt && r === R.register && (s.prompt = G.create), t.properties && Object.keys(t.properties).forEach((f)=>{
        if (!oe.includes(f)) {
            console.warn("Unsupported Property for url generation: ", f);
            return;
        }
        const d = t.properties?.[f];
        d !== void 0 && (s[f] = d);
    });
    const u = new URLSearchParams(s).toString();
    return {
        url: new URL(`${n}?${u}`),
        state: s.state,
        nonce: s.nonce,
        codeChallenge: s.code_challenge,
        codeVerifier: l
    };
};
async function se() {
    const e = M(52), r = new TextEncoder().encode(e);
    let t = "";
    if (!crypto) t = H(btoa(e));
    else {
        const o = await crypto.subtle.digest("SHA-256", r);
        t = H(o);
    }
    return {
        codeVerifier: e,
        codeChallenge: t
    };
}
let $;
function Z(e, r) {
    if (D(), "undefined" > "u") throw new Error("setRefreshTimer requires a browser environment");
    if (e <= 0) throw new Error("Timer duration must be positive");
    $ = window.setTimeout(r, Math.min(e * 1e3 - 1e4, 864e5));
}
function D() {
    $ !== void 0 && (window.clearTimeout($), $ = void 0);
}
const v = {
    framework: "",
    frameworkVersion: "",
    sdkVersion: ""
}, q = async ()=>{
    await S()?.removeItems(c.state, c.nonce, c.codeVerifier);
}, ae = ()=>`${v.framework}/${v.sdkVersion}/${v.frameworkVersion}/Javascript`, Ee = async ({ urlParams: e, domain: r, clientId: t, redirectURL: o, autoRefresh: n = !1, onRefresh: i })=>{
    const s = e.get("state"), l = e.get("code");
    if (!s || !l) return console.error("Invalid state or code"), {
        success: !1,
        error: "Invalid state or code"
    };
    const u = S();
    if (!u) return console.error("No active storage found"), {
        success: !1,
        error: "Authentication storage is not initialized"
    };
    (!v.framework || !v.frameworkVersion) && console.warn("Framework and version not set. Please set the framework and version in the config object");
    const f = await u.getSessionItem(c.state);
    if (s !== f) return console.error("Invalid state"), {
        success: !1,
        error: `Invalid state; supplied ${s}, expected ${f}`
    };
    const d = await u.getSessionItem(c.codeVerifier);
    if (d === null) return console.error("Code verifier not found"), {
        success: !1,
        error: "Code verifier not found"
    };
    const p = {
        "Content-type": "application/x-www-form-urlencoded; charset=UTF-8"
    };
    v.framework && (p["Kinde-SDK"] = ae());
    const I = {
        method: "POST",
        ...!a.useInsecureForRefreshToken && x(r) ? {
            credentials: "include"
        } : {},
        headers: new Headers(p),
        body: new URLSearchParams({
            client_id: t,
            code: l,
            code_verifier: d,
            grant_type: "authorization_code",
            redirect_uri: o
        })
    };
    let w;
    D();
    try {
        if (w = await fetch(`${r}/oauth2/token`, I), !w?.ok) {
            const k = await w.text();
            return console.error("Token exchange failed:", w.status, k), {
                success: !1,
                error: `Token exchange failed: ${w.status} - ${k}`
            };
        }
    } catch (k) {
        return q(), console.error("Token exchange failed:", k), {
            success: !1,
            error: `Token exchange failed: ${k}`
        };
    }
    const h = await w.json(), B = y();
    B && B.setItems({
        [c.accessToken]: h.access_token,
        [c.idToken]: h.id_token,
        [c.refreshToken]: h.refresh_token
    }), (a.useInsecureForRefreshToken || !x(r)) && u.setSessionItem(c.refreshToken, h.refresh_token), n && Z(h.expires_in, async ()=>{
        C({
            domain: r,
            clientId: t,
            onRefresh: i
        });
    }), q();
    const O = ((k)=>(k.search = "", k))(new URL(window.location.toString()));
    return window.history.replaceState(window.history.state, "", O), !h.access_token || !h.id_token || !h.refresh_token ? {
        success: !1,
        error: "No access token received"
    } : {
        success: !0,
        [c.accessToken]: h.access_token,
        [c.idToken]: h.id_token,
        [c.refreshToken]: h.refresh_token
    };
};
function ie(e) {
    const t = document.cookie.split("; ").find((o)=>o.startsWith(`${e}=`));
    if (!t) return null;
    try {
        const o = t.split("=")[1];
        return o ? decodeURIComponent(o) : null;
    } catch (o) {
        return console.error(`Error parsing cookie ${e}:`, o), null;
    }
}
const ce = "_kbrte", be = async ({ domain: e, clientId: r })=>{
    if (!e) return {
        success: !1,
        error: "Domain is required for authentication check"
    };
    if (!r) return {
        success: !1,
        error: "Client ID is required for authentication check"
    };
    const t = x(e), o = a.useInsecureForRefreshToken;
    let n = null;
    return t && !o && (n = ie(ce)), await C({
        domain: e,
        clientId: r,
        refreshType: n ? _.cookie : _.refreshToken
    });
}, x = (e)=>!e.match(/^(?:https?:\/\/)?[a-zA-Z0-9][.-a-zA-Z0-9]*\.kinde\.com$/i);
function V(e, r) {
    return r <= 0 ? [] : e.match(new RegExp(`.{1,${r}}`, "g")) || [];
}
var c = /* @__PURE__ */ ((e)=>(e.accessToken = "accessToken", e.idToken = "idToken", e.refreshToken = "refreshToken", e.state = "state", e.nonce = "nonce", e.codeVerifier = "codeVerifier", e))(c || {}), z = /* @__PURE__ */ ((e)=>(e.preWarning = "preWarning", e.timeout = "timeout", e))(z || {});
class W {
    async setItems(r) {
        await Promise.all(Object.entries(r).map(([t, o])=>this.setSessionItem(t, o)));
    }
    async removeItems(...r) {
        await Promise.all(r.map((t)=>this.removeSessionItem(t)));
    }
}
class Ue extends W {
    memCache = {};
    /**
   * Clears all items from session store.
   * @returns {void}
   */ async destroySession() {
        this.memCache = {};
    }
    /**
   * Sets the provided key-value store to the memory cache.
   * @param {string} itemKey
   * @param {unknown} itemValue
   * @returns {void}
   */ async setSessionItem(r, t) {
        if (await this.removeSessionItem(r), typeof t == "string") {
            V(t, a.maxLength).forEach((o, n)=>{
                this.memCache[`${a.keyPrefix}${r}${n}`] = o;
            });
            return;
        }
        this.memCache[`${a.keyPrefix}${String(r)}0`] = t;
    }
    /**
   * Gets the item for the provided key from the memory cache.
   * @param {string} itemKey
   * @returns {unknown | null}
   */ async getSessionItem(r) {
        if (this.memCache[`${a.keyPrefix}${String(r)}0`] === void 0) return null;
        let t = "", o = 0, n = `${a.keyPrefix}${String(r)}${o}`;
        for(; this.memCache[n] !== void 0;)t += this.memCache[n], o++, n = `${a.keyPrefix}${String(r)}${o}`;
        return t;
    }
    /**
   * Removes the item for the provided key from the memory cache.
   * @param {string} itemKey
   * @returns {void}
   */ async removeSessionItem(r) {
        for(const t in this.memCache)t.startsWith(`${a.keyPrefix}${String(r)}`) && delete this.memCache[t];
    }
}
function P(e) {
    return new Promise((r, t)=>{
        chrome.storage.local.get([
            e
        ], function(o) {
            chrome.runtime.lastError ? t(void 0) : r(o[e]);
        });
    });
}
class Re extends W {
    /**
   * Clears all items from session store.
   * @returns {void}
   */ async destroySession() {
        await chrome.storage.local.clear();
    }
    /**
   * Sets the provided key-value store to the chrome.store.local.
   * @param {string} itemKey
   * @param {unknown} itemValue
   * @returns {void}
   */ async setSessionItem(r, t) {
        if (await this.removeSessionItem(r), typeof t == "string") {
            V(t, a.maxLength).forEach(async (o, n)=>{
                await chrome.storage.local.set({
                    [`${a.keyPrefix}${r}${n}`]: o
                });
            });
            return;
        }
        await chrome.storage.local.set({
            [`${a.keyPrefix}${r}0`]: t
        });
    }
    /**
   * Gets the item for the provided key from the chrome.store.local cache.
   * @param {string} itemKey
   * @returns {unknown | null}
   */ async getSessionItem(r) {
        let t = "", o = 0, n = `${a.keyPrefix}${String(r)}${o}`;
        for(; await P(`${a.keyPrefix}${String(r)}${o}`) !== void 0;)t += await P(n), o++, n = `${a.keyPrefix}${String(r)}${o}`;
        return t;
    }
    /**
   * Removes the item for the provided key from the chrome.store.local cache.
   * @param {string} itemKey
   * @returns {void}
   */ async removeSessionItem(r) {
        let t = 0;
        for(; await P(`${a.keyPrefix}${String(r)}${t}`) !== void 0;)await chrome.storage.local.remove(`${a.keyPrefix}${String(r)}${t}`), t++;
    }
}
class Me extends W {
    constructor(){
        super(), a.useInsecureForRefreshToken && console.warn("LocalStorage store should not be used in production");
    }
    internalItems = /* @__PURE__ */ new Set();
    /**
   * Clears all items from session store.
   * @returns {void}
   */ async destroySession() {
        this.internalItems.forEach((r)=>{
            this.removeSessionItem(r);
        });
    }
    /**
   * Sets the provided key-value store to the localStorage cache.
   * @param {V} itemKey
   * @param {unknown} itemValue
   * @returns {void}
   */ async setSessionItem(r, t) {
        if (await this.removeSessionItem(r), this.internalItems.add(r), typeof t == "string") {
            V(t, a.maxLength).forEach((o, n)=>{
                localStorage.setItem(`${a.keyPrefix}${r}${n}`, o);
            });
            return;
        }
        localStorage.setItem(`${a.keyPrefix}${r}0`, t);
    }
    /**
   * Gets the item for the provided key from the localStorage cache.
   * @param {string} itemKey
   * @returns {unknown | null}
   */ async getSessionItem(r) {
        if (localStorage.getItem(`${a.keyPrefix}${r}0`) === null) return null;
        let t = "", o = 0, n = `${a.keyPrefix}${String(r)}${o}`;
        for(; localStorage.getItem(n) !== null;)t += localStorage.getItem(n), o++, n = `${a.keyPrefix}${String(r)}${o}`;
        return t;
    }
    /**
   * Removes the item for the provided key from the localStorage cache.
   * @param {V} itemKey
   * @returns {void}
   */ async removeSessionItem(r) {
        let t = 0;
        for(; localStorage.getItem(`${a.keyPrefix}${String(r)}${t}`) !== null;)localStorage.removeItem(`${a.keyPrefix}${String(r)}${t}`), t++;
        this.internalItems.delete(r);
    }
}
const a = {
    /**
   * The prefix to use for the storage keys.
   */ keyPrefix: "kinde-",
    /**
   * The maximum length of the storage.
   *
   * If the length is exceeded the items will be split into multiple storage items.
   */ maxLength: 2e3,
    /**
   * Use insecure storage for refresh token.
   *
   * Warning: This should only be used when you're not using a custom domain and no backend app to authenticate on.
   */ useInsecureForRefreshToken: !1,
    /**
   * The number of minutes of inactivity before tokens are considered expired.
   *
   * When undefined, activity tracking is disabled.
   */ activityTimeoutMinutes: void 0,
    /**
   * The number of minutes of inactivity before a pre-warning is shown.
   *
   * When undefined, pre-warning is disabled.
   */ activityTimeoutPreWarningMinutes: void 0,
    /**
   * The function to call when the activity timeout is reached.
   *
   * @param timeoutType - The type of timeout that occurred.
   */ onActivityTimeout: void 0
};
let E = null, b = null;
const le = ()=>{
    const e = y() ?? S();
    if (!e) throw new Error("Session manager not found");
    if (!a.activityTimeoutMinutes) throw new Error("No activity timeout minutes set");
    if (a.activityTimeoutPreWarningMinutes !== void 0 && a.activityTimeoutPreWarningMinutes >= a.activityTimeoutMinutes) throw new Error("activityTimeoutPreWarningMinutes must be less than activityTimeoutMinutes");
    E && clearTimeout(E), b && clearTimeout(b), b = setTimeout(async ()=>{
        try {
            await e.destroySession();
        } catch (t) {
            console.error("Failed to destroy secure session:", t);
        }
        const r = S();
        if (r && r !== e) try {
            await r.destroySession();
        } catch (t) {
            console.error("Failed to destroy insecure session:", t);
        }
        a.onActivityTimeout?.(z.timeout);
    }, a.activityTimeoutMinutes * 60 * 1e3), a.activityTimeoutPreWarningMinutes && (E = setTimeout(()=>{
        a.onActivityTimeout?.(z.preWarning);
    }, a.activityTimeoutPreWarningMinutes * 60 * 1e3));
}, Q = (e)=>{
    if (!e) throw new Error("Session manager not found");
    if (!a.activityTimeoutMinutes) return e;
    if (a.activityTimeoutPreWarningMinutes !== void 0 && a.activityTimeoutPreWarningMinutes >= a.activityTimeoutMinutes) throw new Error("activityTimeoutPreWarningMinutes must be less than activityTimeoutMinutes");
    const r = {
        get (t, o) {
            le();
            const n = t[o];
            return typeof n == "function" ? n.bind(t) : n;
        }
    };
    return new Proxy(e, r);
}, X = (e, r)=>{
    if (Array.isArray(e) && Array.isArray(r)) return Array.from(/* @__PURE__ */ new Set([
        ...e,
        ...r
    ]));
    if (e && typeof e == "object" && r && typeof r == "object") {
        const t = {
            ...e
        };
        for (const o of Object.keys(r))o in t ? t[o] = X(t[o], r[o]) : t[o] = r[o];
        return t;
    }
    return r;
};
async function F(e) {
    const r = y();
    if (!r) throw new Error("No active storage found.");
    const t = await r.getSessionItem(c.accessToken);
    if (!t) throw new Error("Authentication token not found.");
    const o = await j("iss");
    if (!o?.value) throw new Error("Domain (iss claim) not found.");
    let n;
    try {
        n = await fetch(`${o.value}/${e}`, {
            method: "GET",
            headers: {
                Authorization: `Bearer ${t}`,
                "Content-Type": "application/json"
            }
        });
    } catch (s) {
        throw new Error(`Failed to fetch from ${o.value}/${e}: ${s}`);
    }
    if (!n.ok) throw new Error(`API request failed with status ${n.status}`);
    return await n.json();
}
const T = async ({ url: e })=>{
    let r = [], t = await F(e);
    if (r = t.data, t.metadata?.has_more) {
        let o = t.metadata.next_page_starting_after;
        for(; t.metadata.has_more;)t = await F(`${e}?starting_after=${o}`), r = X(r, t.data), o = t.metadata.next_page_starting_after;
    }
    return r;
}, ue = async (e)=>{
    if (e?.forceApi) {
        const n = await T({
            url: "account_api/v1/permissions"
        });
        return {
            orgCode: n.org_code,
            permissions: n.permissions?.map((i)=>i.key) || []
        };
    }
    const r = await g();
    if (!r) return {
        orgCode: null,
        permissions: []
    };
    const t = r.permissions || r["x-hasura-permissions"] || [];
    return {
        orgCode: r.org_code || r["x-hasura-org-code"],
        permissions: t
    };
}, fe = (e)=>typeof e == "object" && e !== null && "permission" in e && "condition" in e, de = async (e)=>{
    if (!e || !e.permissions || e?.permissions?.length === 0) return !0;
    const { permissions: r } = e;
    let t;
    try {
        t = await ue({
            forceApi: e.forceApi
        });
    } catch (n) {
        return console.error("[hasPermissions] Error getting permissions", n), !1;
    }
    return (await Promise.all(r.map(async (n)=>fe(n) ? t.permissions.find((s)=>s === n.permission) ? await n.condition({
            permissionKey: n.permission,
            orgCode: t.orgCode
        }) : !1 : !!t.permissions.find((s)=>s === n)))).every((n)=>n === !0);
}, he = async (e)=>{
    const r = await j("roles");
    if (e?.forceApi || !r?.value) return (await T({
        url: "account_api/v1/roles"
    })).roles?.map((n)=>({
            id: n.id,
            name: n.name,
            key: n.key
        })) || [];
    const t = await g();
    return t ? !t.roles && !t["x-hasura-roles"] ? (console.warn("No roles found in token, ensure roles have been included in the token customisation within the application settings"), []) : t.roles || t["x-hasura-roles"] : [];
}, me = (e)=>typeof e == "object" && e !== null && "role" in e && "condition" in e, ge = async (e)=>{
    if (!e || !e.roles || e?.roles?.length === 0) return !0;
    const { roles: r } = e;
    let t;
    try {
        t = await he({
            forceApi: e.forceApi
        });
    } catch (n) {
        return console.error("[hasRoles] Error getting roles", n), !1;
    }
    return (await Promise.all(r.map(async (n)=>{
        if (me(n)) {
            const i = t.find((l)=>l.key === n.role);
            return i ? await n.condition(i) : !1;
        } else return t.map((s)=>s.key).includes(n);
    }))).every((n)=>n === !0);
}, we = async (e)=>{
    if (e?.forceApi) return (await T({
        url: "account_api/v1/feature_flags"
    })).feature_flags?.map((n)=>({
            key: n.key,
            value: n.value,
            type: n.type
        })) || [];
    const r = await g();
    if (!r) return null;
    const t = r.feature_flags || r["x-hasura-feature-flags"];
    return t ? Object.entries(t).map(([o, n])=>({
            key: o,
            value: n.v,
            type: n.t
        })) : null;
}, ke = (e)=>typeof e == "object" && e !== null && "flag" in e && "value" in e, ye = async (e)=>{
    if (!e || !e.featureFlags || e?.featureFlags?.length === 0) return !0;
    const { featureFlags: r } = e;
    let t;
    try {
        t = await we({
            forceApi: e.forceApi
        });
    } catch (n) {
        return console.error("[hasFeatureFlags] Error getting feature flags", n), !1;
    }
    return r.map((n)=>{
        if (ke(n)) {
            const i = t?.find((s)=>s.key === n.flag);
            return i !== void 0 && i.value === n.value;
        } else return t?.find((s)=>s.key === n) !== void 0;
    }).every((n)=>n === !0);
}, pe = async ()=>{
    const e = await T({
        url: "account_api/v1/entitlements"
    });
    return {
        orgCode: e.org_code,
        plans: e.plans?.map((r)=>({
                key: r.key,
                subscribedOn: r.subscribed_on
            })) || [],
        entitlements: e.entitlements?.map((r)=>({
                id: r.id,
                fixedCharge: r.fixed_charge,
                priceName: r.price_name,
                unitAmount: r.unit_amount,
                featureKey: r.feature_key,
                featureName: r.feature_name,
                entitlementLimitMax: r.entitlement_limit_max,
                entitlementLimitMin: r.entitlement_limit_min
            })) || []
    };
}, _e = (e)=>typeof e == "object" && e !== null && "entitlement" in e && "condition" in e, ve = async (e)=>{
    if (!e || !e.billingEntitlements || e?.billingEntitlements?.length === 0) return !0;
    const { billingEntitlements: r } = e;
    let t;
    try {
        t = await pe();
    } catch (n) {
        return console.error("[hasBillingEntitlements] Error getting entitlements", n), !1;
    }
    return (await Promise.all(r.map(async (n)=>{
        if (_e(n)) {
            const i = t.entitlements.find((s)=>s.priceName === n.entitlement);
            return i ? await n.condition(i) : !1;
        } else return t.entitlements.map((s)=>s.priceName).includes(n);
    }))).every((n)=>n === !0);
}, U = (e)=>e !== void 0 && typeof e == "object", Le = async (e)=>{
    const r = [];
    return e.roles && r.push(ge({
        roles: e.roles,
        forceApi: U(e.forceApi) ? e.forceApi.roles : e.forceApi
    })), e.permissions && r.push(de({
        permissions: e.permissions,
        forceApi: U(e.forceApi) ? e.forceApi.permissions : e.forceApi
    })), e.featureFlags && r.push(ye({
        featureFlags: e.featureFlags,
        forceApi: U(e.forceApi) ? e.forceApi.featureFlags : e.forceApi
    })), e.billingEntitlements && r.push(ve({
        billingEntitlements: e.billingEntitlements
    })), (await Promise.all(r)).every(Boolean);
};
function Se(e, r) {
    if (!e) return null;
    const t = e.split(".");
    if (t.length !== 3) return null;
    const o = t[1].replace(/-/g, "+").replace(/_/g, "/"), n = decodeURIComponent(atob(o).split("").map((i)=>"%" + ("00" + i.charCodeAt(0).toString(16)).slice(-2)).join(""));
    return JSON.parse(n);
}
const g = async (e = c.accessToken)=>{
    const r = y();
    if (!r) return null;
    const t = await r.getSessionItem(e === "accessToken" ? c.accessToken : c.idToken);
    if (!t) return null;
    const o = Se(t);
    return o || console.warn("No decoded token found"), o;
}, Y = async (e = "accessToken")=>g(e), j = async (e, r = "accessToken")=>{
    const t = await Y(r);
    return t ? {
        name: e,
        value: t[e]
    } : null;
}, ze = async ()=>{
    const e = await g();
    return e ? e.org_code || e["x-hasura-org-code"] : null;
}, Fe = async (e = c.accessToken)=>{
    const r = y();
    if (!r) return null;
    const t = await r.getSessionItem(e === "accessToken" ? c.accessToken : c.idToken);
    return t || null;
}, Ne = async (e, r)=>{
    if (r?.forceApi) {
        const s = (await T({
            url: "account_api/v1/feature_flags"
        })).feature_flags.find((l)=>l.name === e);
        return s ? s.value : null;
    }
    const t = await g();
    if (!t) return null;
    const o = t.feature_flags || t["x-hasura-feature-flags"];
    return o ? o[e]?.v ?? null : null;
}, De = async ()=>{
    const e = await Y("idToken");
    if (!e) return null;
    const { sub: r } = e;
    return r ? {
        id: e.sub,
        givenName: e.given_name,
        familyName: e.family_name,
        email: e.email,
        picture: e.picture
    } : (console.error("No sub in idToken"), null);
}, Ve = async (e, r)=>{
    if (r?.forceApi) return F(`account_api/v1/permission/${encodeURIComponent(e)}`);
    const t = await g();
    if (!t) return {
        permissionKey: e,
        orgCode: null,
        isGranted: !1
    };
    const o = t.permissions || [];
    return {
        permissionKey: e,
        orgCode: t.org_code,
        isGranted: !!o.includes(e)
    };
}, We = async ()=>{
    const e = await g("idToken");
    return e ? !e.org_codes && !e["x-hasura-org-codes"] ? (console.warn("Org codes not found in token, ensure org codes have been included in the token customisation within the application settings"), null) : e.org_codes || e["x-hasura-org-codes"] : null;
}, je = async (e)=>{
    try {
        const r = await g("accessToken");
        if (!r) return !1;
        if (!r.exp) return console.error("Token does not have an expiry"), !1;
        const t = r.exp < Math.floor(Date.now() / 1e3);
        return t && e?.useRefreshToken ? (await C({
            domain: e.domain,
            clientId: e.clientId
        })).success : !t;
    } catch (r) {
        return console.error("Error checking authentication:", r), !1;
    }
}, C = async ({ domain: e, clientId: r, refreshType: t = _.refreshToken, onRefresh: o })=>{
    const n = (l)=>(o && o(l), l);
    if (!e) return n({
        success: !1,
        error: "Domain is required for token refresh"
    });
    if (!r) return n({
        success: !1,
        error: "Client ID is required for token refresh"
    });
    let i = "", s;
    if (a.useInsecureForRefreshToken || !x(e) ? s = S() : s = y(), t === _.refreshToken) {
        if (!s) return n({
            success: !1,
            error: "No active storage found"
        });
        if (i = await s.getSessionItem(c.refreshToken), !i) return n({
            success: !1,
            error: "No refresh token found"
        });
    }
    D();
    try {
        const l = await fetch(`${N(e)}/oauth2/token`, {
            method: "POST",
            ...t === _.cookie && {
                credentials: "include"
            },
            headers: {
                "Content-type": "application/x-www-form-urlencoded; charset=UTF-8"
            },
            body: new URLSearchParams({
                ...t === _.refreshToken && {
                    refresh_token: i
                },
                grant_type: "refresh_token",
                client_id: r
            }).toString()
        });
        if (!l.ok) return n({
            success: !1,
            error: "Failed to refresh token"
        });
        const u = await l.json();
        if (u.access_token) {
            const f = y();
            return f ? (Z(u.expires_in, async ()=>{
                C({
                    domain: e,
                    clientId: r,
                    refreshType: t,
                    onRefresh: o
                });
            }), s && (await f.setSessionItem(c.accessToken, u.access_token), u.id_token && await f.setSessionItem(c.idToken, u.id_token), u.refresh_token && await s.setSessionItem(c.refreshToken, u.refresh_token)), n({
                success: !0,
                [c.accessToken]: u.access_token,
                [c.idToken]: u.id_token,
                [c.refreshToken]: u.refresh_token
            })) : n({
                success: !1,
                error: "No active storage found"
            });
        }
    } catch (l) {
        return n({
            success: !1,
            error: `No access token received: ${l}`
        });
    }
    return n({
        success: !1,
        error: "No access token received"
    });
}, m = {
    secure: null,
    insecure: null
}, Be = (e)=>{
    if (a.activityTimeoutMinutes) {
        m.secure = Q(e);
        return;
    }
    m.secure = e;
}, y = ()=>m.secure || null, He = ()=>m.secure !== null, qe = ()=>{
    m.secure = null;
}, Ge = (e)=>{
    if (a.activityTimeoutMinutes) {
        m.insecure = Q(e);
        return;
    }
    m.insecure = e;
}, S = ()=>m.insecure || m.secure || null, Je = ()=>m.insecure !== null, Ze = ()=>{
    m.insecure = null;
}, Qe = async (e)=>(console.warn("Warning: generateProfileUrl is deprecated. Please use generatePortalUrl instead."), $e({
        domain: e.domain,
        returnUrl: e.returnUrl,
        subNav: e.subNav
    }));
function Te(e, r = []) {
    try {
        const t = new URL(e);
        return !r.includes(t.protocol) && !!t.host;
    } catch  {
        return !1;
    }
}
const $e = async ({ domain: e, returnUrl: r, subNav: t })=>{
    const o = y();
    if (!o) throw new Error("generatePortalUrl: Active storage not found");
    const n = await o.getSessionItem(c.accessToken);
    if (!n) throw new Error("generatePortalUrl: Access Token not found");
    if (!e || typeof e != "string") {
        const u = await j("iss");
        if (!u?.value || typeof u.value != "string") throw new Error("generatePortalUrl: Unable to determine domain from access token");
        e = u.value;
    }
    if (!Te(r, [
        "ftp:",
        "ws:"
    ])) throw new Error("generatePortalUrl: returnUrl must be an absolute URL");
    const i = new URLSearchParams({
        subnav: t || J.profile,
        return_url: r
    }), s = await fetch(`${N(e)}/account_api/v1/portal_link?${i.toString()}`, {
        headers: {
            Authorization: `Bearer ${n}`
        }
    });
    if (!s.ok) throw new Error(`Failed to fetch profile URL: ${s.status} ${s.statusText}`);
    const l = await s.json();
    if (!l.url || typeof l.url != "string") throw new Error("Invalid URL received from API");
    try {
        return {
            url: new URL(l.url)
        };
    } catch (u) {
        throw console.error(u), new Error(`Invalid URL format received from API: ${l.url}`);
    }
}, xe = ()=>window.self !== window.top, Xe = async ({ url: e, popupOptions: r = {}, handleResult: t, forcePopup: o = !1 })=>{
    xe() || o ? await Ce({
        url: e,
        popupOptions: r,
        handleResult: t
    }) : document.location = e;
}, Ce = async ({ url: e, popupOptions: r = {}, handleResult: t })=>{
    const { width: o = 500, height: n = 600, left: i = (window.screen.width - o) / 2, top: s = (window.screen.height - n) / 2 } = r, l = window.open(e, "kinde_auth_popup", `width=${o},height=${n},left=${i},top=${s},scrollbars=yes,resizable=yes,toolbar=no,menubar=no,location=no,status=no`);
    if (!l) throw new Error("Popup was blocked by the browser");
    const u = ()=>new Promise((f)=>{
            const d = (p)=>{
                if (p.origin === window.location.origin && p.data && p.data.type === "KINDE_AUTH_RESULT") {
                    window.removeEventListener("message", d);
                    const A = new URLSearchParams();
                    Object.entries(p.data.result).forEach(([I, w])=>{
                        A.append(I, w);
                    }), t?.(A).then(()=>f());
                }
            };
            window.addEventListener("message", d);
        });
    try {
        await u();
    } catch (f) {
        throw new Error("Popup authentication failed: " + f);
    }
    return l;
}, Ye = {
    __esModule: !0,
    default: async ()=>(await import(/* webpackIgnore: true */ "./expoSecureStore-BTi2p58Y.js")).ExpoSecureStore
};
;
}),
"[project]/node_modules/@kinde/js-utils/dist/main--ltuV3nd.js [app-route] (ecmascript) <export s as splitString>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "splitString",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d2d$ltuV3nd$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["s"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d2d$ltuV3nd$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kinde/js-utils/dist/main--ltuV3nd.js [app-route] (ecmascript)");
}),
"[project]/node_modules/@kinde/js-utils/dist/main--ltuV3nd.js [app-route] (ecmascript) <export p as generatePortalUrl>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "generatePortalUrl",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d2d$ltuV3nd$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["p"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d2d$ltuV3nd$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kinde/js-utils/dist/main--ltuV3nd.js [app-route] (ecmascript)");
}),
"[project]/node_modules/@kinde/js-utils/dist/main--ltuV3nd.js [app-route] (ecmascript) <export Y as MemoryStorage>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "MemoryStorage",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d2d$ltuV3nd$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Y"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d2d$ltuV3nd$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kinde/js-utils/dist/main--ltuV3nd.js [app-route] (ecmascript)");
}),
"[project]/node_modules/@kinde/js-utils/dist/main--ltuV3nd.js [app-route] (ecmascript) <export K as setActiveStorage>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "setActiveStorage",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d2d$ltuV3nd$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["K"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d2d$ltuV3nd$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kinde/js-utils/dist/main--ltuV3nd.js [app-route] (ecmascript)");
}),
"[project]/node_modules/@kinde/js-utils/dist/main--ltuV3nd.js [app-route] (ecmascript) <export a as StorageKeys>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "StorageKeys",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d2d$ltuV3nd$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["a"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d2d$ltuV3nd$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kinde/js-utils/dist/main--ltuV3nd.js [app-route] (ecmascript)");
}),
"[project]/node_modules/@kinde/js-utils/dist/main--ltuV3nd.js [app-route] (ecmascript) <export D as getEntitlements>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getEntitlements",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d2d$ltuV3nd$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["D"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d2d$ltuV3nd$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kinde/js-utils/dist/main--ltuV3nd.js [app-route] (ecmascript)");
}),
"[project]/node_modules/@kinde/js-utils/dist/main--ltuV3nd.js [app-route] (ecmascript) <export N as clearActiveStorage>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "clearActiveStorage",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d2d$ltuV3nd$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["N"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d2d$ltuV3nd$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kinde/js-utils/dist/main--ltuV3nd.js [app-route] (ecmascript)");
}),
"[project]/node_modules/@kinde/js-utils/dist/main--ltuV3nd.js [app-route] (ecmascript) <export a1 as PortalPage>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PortalPage",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d2d$ltuV3nd$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["a1"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kinde$2f$js$2d$utils$2f$dist$2f$main$2d2d$ltuV3nd$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kinde/js-utils/dist/main--ltuV3nd.js [app-route] (ecmascript)");
}),
"[project]/node_modules/destr/dist/index.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>destr,
    "destr",
    ()=>destr,
    "safeDestr",
    ()=>safeDestr
]);
const suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
const suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
const JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(key, value) {
    if (key === "__proto__" || key === "constructor" && value && typeof value === "object" && "prototype" in value) {
        warnKeyDropped(key);
        return;
    }
    return value;
}
function warnKeyDropped(key) {
    console.warn(`[destr] Dropping "${key}" key to prevent prototype pollution.`);
}
function destr(value, options = {}) {
    if (typeof value !== "string") {
        return value;
    }
    if (value[0] === '"' && value[value.length - 1] === '"' && value.indexOf("\\") === -1) {
        return value.slice(1, -1);
    }
    const _value = value.trim();
    if (_value.length <= 9) {
        switch(_value.toLowerCase()){
            case "true":
                {
                    return true;
                }
            case "false":
                {
                    return false;
                }
            case "undefined":
                {
                    return void 0;
                }
            case "null":
                {
                    return null;
                }
            case "nan":
                {
                    return Number.NaN;
                }
            case "infinity":
                {
                    return Number.POSITIVE_INFINITY;
                }
            case "-infinity":
                {
                    return Number.NEGATIVE_INFINITY;
                }
        }
    }
    if (!JsonSigRx.test(value)) {
        if (options.strict) {
            throw new SyntaxError("[destr] Invalid JSON");
        }
        return value;
    }
    try {
        if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
            if (options.strict) {
                throw new Error("[destr] Possible prototype pollution");
            }
            return JSON.parse(value, jsonParseTransform);
        }
        return JSON.parse(value);
    } catch (error) {
        if (options.strict) {
            throw error;
        }
        return value;
    }
}
function safeDestr(value, options = {}) {
    return destr(value, {
        ...options,
        strict: true
    });
}
;
}),
"[project]/node_modules/cookie/dist/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parse = parse;
exports.serialize = serialize;
/**
 * RegExp to match cookie-name in RFC 6265 sec 4.1.1
 * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2
 * which has been replaced by the token definition in RFC 7230 appendix B.
 *
 * cookie-name       = token
 * token             = 1*tchar
 * tchar             = "!" / "#" / "$" / "%" / "&" / "'" /
 *                     "*" / "+" / "-" / "." / "^" / "_" /
 *                     "`" / "|" / "~" / DIGIT / ALPHA
 *
 * Note: Allowing more characters - https://github.com/jshttp/cookie/issues/191
 * Allow same range as cookie value, except `=`, which delimits end of name.
 */ const cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
/**
 * RegExp to match cookie-value in RFC 6265 sec 4.1.1
 *
 * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
 * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
 *                     ; US-ASCII characters excluding CTLs,
 *                     ; whitespace DQUOTE, comma, semicolon,
 *                     ; and backslash
 *
 * Allowing more characters: https://github.com/jshttp/cookie/issues/191
 * Comma, backslash, and DQUOTE are not part of the parsing algorithm.
 */ const cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
/**
 * RegExp to match domain-value in RFC 6265 sec 4.1.1
 *
 * domain-value      = <subdomain>
 *                     ; defined in [RFC1034], Section 3.5, as
 *                     ; enhanced by [RFC1123], Section 2.1
 * <subdomain>       = <label> | <subdomain> "." <label>
 * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]
 *                     Labels must be 63 characters or less.
 *                     'let-dig' not 'letter' in the first char, per RFC1123
 * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>
 * <let-dig-hyp>     = <let-dig> | "-"
 * <let-dig>         = <letter> | <digit>
 * <letter>          = any one of the 52 alphabetic characters A through Z in
 *                     upper case and a through z in lower case
 * <digit>           = any one of the ten digits 0 through 9
 *
 * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173
 *
 * > (Note that a leading %x2E ("."), if present, is ignored even though that
 * character is not permitted, but a trailing %x2E ("."), if present, will
 * cause the user agent to ignore the attribute.)
 */ const domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
/**
 * RegExp to match path-value in RFC 6265 sec 4.1.1
 *
 * path-value        = <any CHAR except CTLs or ";">
 * CHAR              = %x01-7F
 *                     ; defined in RFC 5234 appendix B.1
 */ const pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
const __toString = Object.prototype.toString;
const NullObject = /* @__PURE__ */ (()=>{
    const C = function() {};
    C.prototype = Object.create(null);
    return C;
})();
/**
 * Parse a cookie header.
 *
 * Parse the given cookie header string into an object
 * The object has the various cookies as keys(names) => values
 */ function parse(str, options) {
    const obj = new NullObject();
    const len = str.length;
    // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.
    if (len < 2) return obj;
    const dec = options?.decode || decode;
    let index = 0;
    do {
        const eqIdx = str.indexOf("=", index);
        if (eqIdx === -1) break; // No more cookie pairs.
        const colonIdx = str.indexOf(";", index);
        const endIdx = colonIdx === -1 ? len : colonIdx;
        if (eqIdx > endIdx) {
            // backtrack on prior semicolon
            index = str.lastIndexOf(";", eqIdx - 1) + 1;
            continue;
        }
        const keyStartIdx = startIndex(str, index, eqIdx);
        const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
        const key = str.slice(keyStartIdx, keyEndIdx);
        // only assign once
        if (obj[key] === undefined) {
            let valStartIdx = startIndex(str, eqIdx + 1, endIdx);
            let valEndIdx = endIndex(str, endIdx, valStartIdx);
            const value = dec(str.slice(valStartIdx, valEndIdx));
            obj[key] = value;
        }
        index = endIdx + 1;
    }while (index < len)
    return obj;
}
function startIndex(str, index, max) {
    do {
        const code = str.charCodeAt(index);
        if (code !== 0x20 /*   */  && code !== 0x09 /* \t */ ) return index;
    }while (++index < max)
    return max;
}
function endIndex(str, index, min) {
    while(index > min){
        const code = str.charCodeAt(--index);
        if (code !== 0x20 /*   */  && code !== 0x09 /* \t */ ) return index + 1;
    }
    return min;
}
/**
 * Serialize data into a cookie header.
 *
 * Serialize a name value pair into a cookie string suitable for
 * http headers. An optional options object specifies cookie parameters.
 *
 * serialize('foo', 'bar', { httpOnly: true })
 *   => "foo=bar; httpOnly"
 */ function serialize(name, val, options) {
    const enc = options?.encode || encodeURIComponent;
    if (!cookieNameRegExp.test(name)) {
        throw new TypeError(`argument name is invalid: ${name}`);
    }
    const value = enc(val);
    if (!cookieValueRegExp.test(value)) {
        throw new TypeError(`argument val is invalid: ${val}`);
    }
    let str = name + "=" + value;
    if (!options) return str;
    if (options.maxAge !== undefined) {
        if (!Number.isInteger(options.maxAge)) {
            throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);
        }
        str += "; Max-Age=" + options.maxAge;
    }
    if (options.domain) {
        if (!domainValueRegExp.test(options.domain)) {
            throw new TypeError(`option domain is invalid: ${options.domain}`);
        }
        str += "; Domain=" + options.domain;
    }
    if (options.path) {
        if (!pathValueRegExp.test(options.path)) {
            throw new TypeError(`option path is invalid: ${options.path}`);
        }
        str += "; Path=" + options.path;
    }
    if (options.expires) {
        if (!isDate(options.expires) || !Number.isFinite(options.expires.valueOf())) {
            throw new TypeError(`option expires is invalid: ${options.expires}`);
        }
        str += "; Expires=" + options.expires.toUTCString();
    }
    if (options.httpOnly) {
        str += "; HttpOnly";
    }
    if (options.secure) {
        str += "; Secure";
    }
    if (options.partitioned) {
        str += "; Partitioned";
    }
    if (options.priority) {
        const priority = typeof options.priority === "string" ? options.priority.toLowerCase() : undefined;
        switch(priority){
            case "low":
                str += "; Priority=Low";
                break;
            case "medium":
                str += "; Priority=Medium";
                break;
            case "high":
                str += "; Priority=High";
                break;
            default:
                throw new TypeError(`option priority is invalid: ${options.priority}`);
        }
    }
    if (options.sameSite) {
        const sameSite = typeof options.sameSite === "string" ? options.sameSite.toLowerCase() : options.sameSite;
        switch(sameSite){
            case true:
            case "strict":
                str += "; SameSite=Strict";
                break;
            case "lax":
                str += "; SameSite=Lax";
                break;
            case "none":
                str += "; SameSite=None";
                break;
            default:
                throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);
        }
    }
    return str;
}
/**
 * URL-decode string value. Optimized to skip native call when no %.
 */ function decode(str) {
    if (str.indexOf("%") === -1) return str;
    try {
        return decodeURIComponent(str);
    } catch (e) {
        return str;
    }
}
/**
 * Determine if value is a Date.
 */ function isDate(val) {
    return __toString.call(val) === "[object Date]";
} //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@kinde/jwt-validator/dist/jwt-validator.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "validateToken",
    ()=>v
]);
const d = /* @__PURE__ */ new Map();
function b() {
    return "undefined" < "u" ? window.crypto : globalThis.crypto;
}
async function A(e) {
    let t = 0;
    for(; t < 3;){
        const n = new AbortController(), a = setTimeout(()=>n.abort(), 5e3);
        try {
            const o = await fetch(`${e}/.well-known/jwks.json`, {
                signal: n.signal
            });
            if (clearTimeout(a), !o.ok) throw new Error(`Failed to fetch JWKS: ${o.status} ${o.statusText}`);
            return await o.json();
        } catch (o) {
            t++, console.error(`Attempt ${t} - Error fetching JWKS:`, o);
        }
    }
    throw new Error("Failed to fetch JWKS after multiple retries");
}
async function S(e, r, t) {
    t && d.delete(r);
    let n = d.get(r);
    n || (n = await A(r), d.set(r, n));
    try {
        return await E(e, JSON.stringify(n)), {
            valid: !0,
            message: "Token is valid"
        };
    } catch (a) {
        return t ? {
            valid: !1,
            message: a instanceof Error ? a.message : "Unknown Error"
        } : S(e, r, !0);
    }
}
async function E(e, r) {
    const [t, n, a] = e.split("."), k = JSON.parse(atob(t)).kid, i = J(r, k);
    if (!i || i.kty !== "RSA" || !i.n || !i.e || i.use !== "sig") throw new Error("Invalid JWK RSA key");
    const c = b();
    if (c != null && c.subtle) {
        const l = m(i.n), u = m(i.e), f = {
            name: "RSASSA-PKCS1-v1_5",
            hash: {
                name: "SHA-256"
            }
        };
        try {
            const s = {
                kty: "RSA",
                n: p(l),
                e: p(u),
                alg: "RS256"
            }, w = await c.subtle.importKey("jwk", s, f, !0, [
                "verify"
            ]), h = t + "." + n, g = j(a), y = await c.subtle.verify(f, w, g, new TextEncoder().encode(h));
            if (!y) throw new Error("Signature verification failed");
            return y;
        } catch (s) {
            throw s;
        }
    } else {
        const { KJUR: l, KEYUTIL: u, b64utoutf8: f } = await __turbopack_context__.A("[project]/node_modules/@kinde/jwt-validator/dist/jsrsasign-B2gZIJhY.js [app-route] (ecmascript, async loader)").then((g)=>g.j), s = JSON.parse(f(t));
        if (s.alg !== "RS256") throw new Error("Unsupported signature algorithm: " + s);
        const w = u.getKey(i);
        if (!l.jws.JWS.verifyJWT(e, w, {
            alg: [
                "RS256"
            ]
        })) throw new Error("Signature verification failed");
        return !0;
    }
}
function p(e) {
    let r = e.toString(16);
    r.length % 2 !== 0 && (r = "0" + r);
    const t = new Uint8Array(r.match(/.{1,2}/g).map((a)=>parseInt(a, 16)));
    return btoa(String.fromCharCode.apply(null, Array.from(t))).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
function J(e, r) {
    const t = JSON.parse(e);
    for (const n of t.keys)if (n.kid === r) return n;
    throw new Error(`JWK not found${r ? ` for kid ${r}` : ""}`);
}
function m(e) {
    e = e.replace(/[^A-Za-z0-9\-_]/g, ""), e += Array.from({
        length: (4 - e.length % 4) % 4
    }, ()=>"=").join("");
    const r = e.replace(/-/g, "+").replace(/_/g, "/");
    let t;
    try {
        t = atob(r);
    } catch (o) {
        throw new Error("Invalid Base64 string: " + o.message);
    }
    const n = Array.from(t, (o)=>o.charCodeAt(0).toString(16).padStart(2, "0")).join("");
    if (n.toLowerCase() === "ffffffffffffffff" || n.toLowerCase() === "7ff0000000000000") throw new Error("Decoded value represents NaN or Infinity");
    const a = n.replace(/^0+/, "");
    return BigInt("0x" + a || "0");
}
function j(e) {
    return Uint8Array.from(atob(e.replace(/-/g, "+").replace(/_/g, "/")), (r)=>r.charCodeAt(0));
}
const v = async (e)=>e.token ? e.domain ? e.token.split(".").length !== 3 ? {
        valid: !1,
        message: "Invalid JWT format"
    } : await S(e.token, e.domain) : {
        valid: !1,
        message: "Domain is required"
    } : {
        valid: !1,
        message: "Token is required"
    };
;
}),
"[project]/node_modules/uncrypto/dist/crypto.node.mjs [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>_crypto,
    "getRandomValues",
    ()=>getRandomValues,
    "randomUUID",
    ()=>randomUUID,
    "subtle",
    ()=>subtle
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:crypto [external] (node:crypto, cjs)");
;
const subtle = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__["default"].webcrypto?.subtle || {};
const randomUUID = ()=>{
    return __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__["default"].randomUUID();
};
const getRandomValues = (array)=>{
    return __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$crypto__$5b$external$5d$__$28$node$3a$crypto$2c$__cjs$29$__["default"].webcrypto.getRandomValues(array);
};
const _crypto = {
    randomUUID,
    getRandomValues,
    subtle
};
;
}),
];

//# sourceMappingURL=node_modules_9b0cfecc._.js.map