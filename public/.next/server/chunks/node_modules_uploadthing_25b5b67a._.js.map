{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/uploadthing/dist/package-DpScpvTA.js","sources":["file:///D:/840%20G3/7th%20semester/FSPM/Trackly/Trackly/node_modules/uploadthing/package.json"],"sourcesContent":["{\n  \"name\": \"uploadthing\",\n  \"version\": \"7.7.4\",\n  \"type\": \"module\",\n  \"sideEffects\": false,\n  \"engines\": {\n    \"node\": \">=18.13.0\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"github:pingdotgg/uploadthing\",\n    \"directory\": \"packages/uploadthing\"\n  },\n  \"license\": \"MIT\",\n  \"exports\": {\n    \"./package.json\": \"./package.json\",\n    \"./client\": {\n      \"import\": {\n        \"types\": \"./client/index.d.ts\",\n        \"default\": \"./client/index.js\"\n      },\n      \"require\": {\n        \"types\": \"./client/index.d.cts\",\n        \"default\": \"./client/index.cjs\"\n      }\n    },\n    \"./client-future\": {\n      \"import\": {\n        \"types\": \"./client-future/index.d.ts\",\n        \"default\": \"./client-future/index.js\"\n      },\n      \"require\": {\n        \"types\": \"./client-future/index.d.cts\",\n        \"default\": \"./client-future/index.cjs\"\n      }\n    },\n    \"./server\": {\n      \"import\": {\n        \"types\": \"./server/index.d.ts\",\n        \"default\": \"./server/index.js\"\n      },\n      \"require\": {\n        \"types\": \"./server/index.d.cts\",\n        \"default\": \"./server/index.cjs\"\n      }\n    },\n    \"./next\": {\n      \"import\": {\n        \"types\": \"./next/index.d.ts\",\n        \"default\": \"./next/index.js\"\n      },\n      \"require\": {\n        \"types\": \"./next/index.d.cts\",\n        \"default\": \"./next/index.cjs\"\n      }\n    },\n    \"./next-legacy\": {\n      \"import\": {\n        \"types\": \"./next-legacy/index.d.ts\",\n        \"default\": \"./next-legacy/index.js\"\n      },\n      \"require\": {\n        \"types\": \"./next-legacy/index.d.cts\",\n        \"default\": \"./next-legacy/index.cjs\"\n      }\n    },\n    \"./effect-platform\": {\n      \"import\": {\n        \"types\": \"./effect-platform/index.d.ts\",\n        \"default\": \"./effect-platform/index.js\"\n      },\n      \"require\": {\n        \"types\": \"./effect-platform/index.d.cts\",\n        \"default\": \"./effect-platform/index.cjs\"\n      }\n    },\n    \"./tw\": {\n      \"browser\": \"./tw/index.browser.js\",\n      \"import\": {\n        \"types\": \"./tw/index.d.ts\",\n        \"default\": \"./tw/index.js\"\n      },\n      \"require\": {\n        \"types\": \"./tw/index.d.cts\",\n        \"default\": \"./tw/index.cjs\"\n      }\n    },\n    \"./tw/v4\": \"./tw/v4.css\",\n    \"./fastify\": {\n      \"import\": {\n        \"types\": \"./fastify/index.d.ts\",\n        \"default\": \"./fastify/index.js\"\n      },\n      \"require\": {\n        \"types\": \"./fastify/index.d.cts\",\n        \"default\": \"./fastify/index.cjs\"\n      }\n    },\n    \"./express\": {\n      \"import\": {\n        \"types\": \"./express/index.d.ts\",\n        \"default\": \"./express/index.js\"\n      },\n      \"require\": {\n        \"types\": \"./express/index.d.cts\",\n        \"default\": \"./express/index.cjs\"\n      }\n    },\n    \"./h3\": {\n      \"import\": {\n        \"types\": \"./h3/index.d.ts\",\n        \"default\": \"./h3/index.js\"\n      },\n      \"require\": {\n        \"types\": \"./h3/index.d.cts\",\n        \"default\": \"./h3/index.cjs\"\n      }\n    },\n    \"./remix\": {\n      \"import\": {\n        \"types\": \"./remix/index.d.ts\",\n        \"default\": \"./remix/index.js\"\n      },\n      \"require\": {\n        \"types\": \"./remix/index.d.cts\",\n        \"default\": \"./remix/index.cjs\"\n      }\n    },\n    \"./types\": {\n      \"types\": \"./types/index.d.ts\",\n      \"default\": \"./types/index.js\"\n    }\n  },\n  \"files\": [\n    \"client\",\n    \"client-future\",\n    \"dist\",\n    \"effect-platform\",\n    \"express\",\n    \"fastify\",\n    \"h3\",\n    \"next\",\n    \"next-legacy\",\n    \"remix\",\n    \"server\",\n    \"types\",\n    \"tw\"\n  ],\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"scripts\": {\n    \"lint\": \"eslint src test --max-warnings 0\",\n    \"build\": \"tsdown\",\n    \"clean\": \"git clean -xdf client express fastify h3 internal next next-legacy server tw node_modules\",\n    \"dev\": \"tsdown --no-clean\",\n    \"prepack\": \"bun ../../.github/replace-workspace-protocol.ts\",\n    \"test\": \"vitest run\",\n    \"typecheck\": \"tsc --noEmit\"\n  },\n  \"dependencies\": {\n    \"@effect/platform\": \"0.90.3\",\n    \"@standard-schema/spec\": \"1.0.0-beta.4\",\n    \"@uploadthing/mime-types\": \"workspace:*\",\n    \"@uploadthing/shared\": \"workspace:*\",\n    \"effect\": \"3.17.7\"\n  },\n  \"devDependencies\": {\n    \"@effect/vitest\": \"0.25.1\",\n    \"@remix-run/server-runtime\": \"^2.12.0\",\n    \"@types/body-parser\": \"^1.19.5\",\n    \"@types/express\": \"^5.0.0\",\n    \"@types/express-serve-static-core\": \"^5.0.3\",\n    \"@types/react\": \"19.1.2\",\n    \"@uploadthing/eslint-config\": \"workspace:*\",\n    \"@uploadthing/tsconfig\": \"workspace:*\",\n    \"@uploadthing/vitest-config\": \"workspace:*\",\n    \"@vitest/coverage-istanbul\": \"3.2.4\",\n    \"body-parser\": \"^1.20.2\",\n    \"eslint\": \"9.25.1\",\n    \"express\": \"^5.0.1\",\n    \"fastify\": \"^5.2.0\",\n    \"h3\": \"^1.13.0\",\n    \"msw\": \"2.7.5\",\n    \"next\": \"15.3.1\",\n    \"solid-js\": \"^1.9.3\",\n    \"tailwindcss\": \"^3.4.16\",\n    \"tsdown\": \"0.14.1\",\n    \"typescript\": \"5.8.3\",\n    \"valibot\": \"1.0.0-beta.9\",\n    \"vitest\": \"3.2.4\",\n    \"vue\": \"^3.4.21\",\n    \"wait-on\": \"^8.0.1\",\n    \"zod\": \"^3.24.1\"\n  },\n  \"peerDependencies\": {\n    \"express\": \"*\",\n    \"h3\": \"*\",\n    \"tailwindcss\": \"^3.0.0 || ^4.0.0-beta.0\"\n  },\n  \"peerDependenciesMeta\": {\n    \"next\": {\n      \"optional\": true\n    },\n    \"express\": {\n      \"optional\": true\n    },\n    \"fastify\": {\n      \"optional\": true\n    },\n    \"h3\": {\n      \"optional\": true\n    },\n    \"tailwindcss\": {\n      \"optional\": true\n    }\n  }\n}\n"],"names":[],"mappings":";;;;;cAEa","debugId":null}},
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/uploadthing/dist/deprecations-pLmw6Ytd.js","sources":["file:///D:/840%20G3/7th%20semester/FSPM/Trackly/Trackly/node_modules/uploadthing/src/_internal/deprecations.ts"],"sourcesContent":["export const logDeprecationWarning = (message: string) => {\n  // eslint-disable-next-line no-console\n  console.warn(`⚠️ [uploadthing][deprecated] ${message}`);\n};\n"],"names":["message: string"],"mappings":";;;;;AAAA,MAAa,wBAAwB,CAACA,YAAoB;IAExD,QAAQ,IAAA,CAAK,CAAC,6BAA6B,EAAE,SAAS,CAAC;AACxD","debugId":null}},
    {"offset": {"line": 30, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/uploadthing/dist/shared-schemas-BmG5ARoX.js","sources":["file:///D:/840%20G3/7th%20semester/FSPM/Trackly/Trackly/node_modules/uploadthing/src/_internal/shared-schemas.ts"],"sourcesContent":["import * as S from \"effect/Schema\";\n\nimport type { Json } from \"@uploadthing/shared\";\nimport { ValidACLs, ValidContentDispositions } from \"@uploadthing/shared\";\n\nexport const ContentDispositionSchema = S.Literal(...ValidContentDispositions);\nexport const ACLSchema = S.Literal(...ValidACLs);\n\n/**\n * Valid options for the `?actionType` query param\n */\nexport const ActionType = S.Literal(\"upload\");\n\n/**\n * Valid options for the `uploadthing-hook` header\n * for requests coming from UT server\n */\nexport const UploadThingHook = S.Literal(\"callback\", \"error\");\n\n/**\n * =============================================================================\n * =========================== Configuration ===================================\n * =============================================================================\n */\nconst DecodeString = S.transform(S.Uint8ArrayFromSelf, S.String, {\n  decode: (data) => new TextDecoder().decode(data),\n  encode: (data) => new TextEncoder().encode(data),\n});\n\nexport const ParsedToken = S.Struct({\n  apiKey: S.Redacted(S.String.pipe(S.startsWith(\"sk_\"))),\n  appId: S.String,\n  regions: S.NonEmptyArray(S.String),\n  ingestHost: S.String.pipe(\n    S.optionalWith({ default: () => \"ingest.uploadthing.com\" }),\n  ),\n});\n\nexport const UploadThingToken = S.Uint8ArrayFromBase64.pipe(\n  S.compose(DecodeString),\n  S.compose(S.parseJson(ParsedToken)),\n);\n\n/**\n * =============================================================================\n * ======================== File Type Hierarchy ===============================\n * =============================================================================\n */\n\n/**\n * Properties from the web File object, this is what the client sends when initiating an upload\n */\nexport class FileUploadData extends S.Class<FileUploadData>(\"FileUploadData\")({\n  name: S.String,\n  size: S.Number,\n  type: S.String,\n  lastModified: S.Number.pipe(S.optional),\n}) {}\n\n/**\n * `.middleware()` can add a customId to the incoming file data\n */\nexport class FileUploadDataWithCustomId extends FileUploadData.extend<FileUploadDataWithCustomId>(\n  \"FileUploadDataWithCustomId\",\n)({\n  customId: S.NullOr(S.String),\n}) {}\n\n/**\n * When files are uploaded, we get back\n * - a key\n * - URLs for the file\n * - the hash (md5-hex) of the uploaded file's contents\n */\nexport class UploadedFileData extends FileUploadDataWithCustomId.extend<UploadedFileData>(\n  \"UploadedFileData\",\n)({\n  key: S.String,\n  /**\n   * @deprecated\n   * This field will be removed in uploadthing v9. Use `ufsUrl` instead.\n   */\n  url: S.String,\n  /**\n   * @deprecated\n   * This field will be removed in uploadthing v9. Use `ufsUrl` instead.\n   */\n  appUrl: S.String,\n  ufsUrl: S.String,\n  fileHash: S.String,\n}) {}\n\n/**\n * When the client has uploaded a file and polled for data returned by `.onUploadComplete()`\n */\nexport interface ClientUploadedFileData<T> extends UploadedFileData {\n  /**\n   * Matches what's returned from the serverside `onUploadComplete` callback\n   */\n  readonly serverData: T;\n}\n\n/**\n * =============================================================================\n * ======================== Server Response Schemas ============================\n * =============================================================================\n */\n\nexport class NewPresignedUrl extends S.Class<NewPresignedUrl>(\n  \"NewPresignedUrl\",\n)({\n  url: S.String,\n  key: S.String,\n  customId: S.NullOr(S.String),\n  name: S.String,\n}) {}\n\nexport class MetadataFetchStreamPart extends S.Class<MetadataFetchStreamPart>(\n  \"MetadataFetchStreamPart\",\n)({\n  payload: S.String,\n  signature: S.String,\n  hook: UploadThingHook,\n}) {}\n\nexport class MetadataFetchResponse extends S.Class<MetadataFetchResponse>(\n  \"MetadataFetchResponse\",\n)({\n  ok: S.Boolean,\n}) {}\n\nexport class CallbackResultResponse extends S.Class<CallbackResultResponse>(\n  \"CallbackResultResponse\",\n)({\n  ok: S.Boolean,\n}) {}\n\n/**\n * =============================================================================\n * ======================== Client Action Payloads ============================\n * =============================================================================\n */\n\nexport class UploadActionPayload extends S.Class<UploadActionPayload>(\n  \"UploadActionPayload\",\n)({\n  files: S.Array(FileUploadData),\n  input: S.Unknown as S.Schema<Json>,\n}) {}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAKA,MAAa,2BAA2B,EAAE,yMAAA,CAAQ,GAAG,sLAAA,CAAyB;AAC9E,MAAa,YAAY,EAAE,yMAAA,CAAQ,GAAG,uKAAA,CAAU;;;GAKhD,MAAa,aAAa,EAAE,yMAAA,CAAQ,SAAS;;;;GAM7C,MAAa,kBAAkB,EAAE,yMAAA,CAAQ,YAAY,QAAQ;;;;;GAO7D,MAAM,eAAe,EAAE,2MAAA,CAAU,EAAE,oNAAA,EAAoB,EAAE,wMAAA,EAAQ;IAC/D,QAAQ,CAAC,OAAS,IAAI,cAAc,MAAA,CAAO,KAAK;IAChD,QAAQ,CAAC,OAAS,IAAI,cAAc,MAAA,CAAO,KAAK;AACjD,EAAC;AAEF,MAAa,cAAc,EAAE,wMAAA,CAAO;IAClC,QAAQ,EAAE,0MAAA,CAAS,EAAE,wMAAA,CAAO,IAAA,CAAK,EAAE,4MAAA,CAAW,MAAM,CAAC,CAAC;IACtD,OAAO,EAAE,wMAAA;IACT,SAAS,EAAE,+MAAA,CAAc,EAAE,wMAAA,CAAO;IAClC,YAAY,EAAE,wMAAA,CAAO,IAAA,CACnB,EAAE,8MAAA,CAAa;QAAE,SAAS,IAAM;IAA0B,EAAC,CAC5D;AACF,EAAC;AAEF,MAAa,mBAAmB,EAAE,sNAAA,CAAqB,IAAA,CACrD,EAAE,yMAAA,CAAQ,aAAa,EACvB,EAAE,yMAAA,CAAQ,EAAE,2MAAA,CAAU,YAAY,CAAC,CACpC;;;;;;;GAWD,IAAa,iBAAb,cAAoC,EAAE,uMAAA,CAAsB,iBAAiB,CAAC;IAC5E,MAAM,EAAE,wMAAA;IACR,MAAM,EAAE,wMAAA;IACR,MAAM,EAAE,wMAAA;IACR,cAAc,EAAE,wMAAA,CAAO,IAAA,CAAK,EAAE,0MAAA,CAAS;AACxC,EAAC,CAAC;AAAE;;;GAKL,IAAa,6BAAb,cAAgD,eAAe,MAAA,CAC7D,6BACD,CAAC;IACA,UAAU,EAAE,wMAAA,CAAO,EAAE,wMAAA,CAAO;AAC7B,EAAC,CAAC;AAAE;;;;;;GAQL,IAAa,mBAAb,cAAsC,2BAA2B,MAAA,CAC/D,mBACD,CAAC;IACA,KAAK,EAAE,wMAAA;IAKP,KAAK,EAAE,wMAAA;IAKP,QAAQ,EAAE,wMAAA;IACV,QAAQ,EAAE,wMAAA;IACV,UAAU,EAAE,wMAAA;AACb,EAAC,CAAC;AAAE;AA2BL,IAAa,0BAAb,cAA6C,EAAE,uMAAA,CAC7C,0BACD,CAAC;IACA,SAAS,EAAE,wMAAA;IACX,WAAW,EAAE,wMAAA;IACb,MAAM;AACP,EAAC,CAAC;AAAE;AAEL,IAAa,wBAAb,cAA2C,EAAE,uMAAA,CAC3C,wBACD,CAAC;IACA,IAAI,EAAE,yMAAA;AACP,EAAC,CAAC;AAAE;AAEL,IAAa,yBAAb,cAA4C,EAAE,uMAAA,CAC5C,yBACD,CAAC;IACA,IAAI,EAAE,yMAAA;AACP,EAAC,CAAC;AAAE;;;;;GAQL,IAAa,sBAAb,cAAyC,EAAE,uMAAA,CACzC,sBACD,CAAC;IACA,OAAO,EAAE,uMAAA,CAAM,eAAe;IAC9B,OAAO,EAAE,yMAAA;AACV,EAAC,CAAC;AAAE","debugId":null}},
    {"offset": {"line": 140, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/uploadthing/dist/upload-builder-BlFOAnsv.js","sources":["file:///D:/840%20G3/7th%20semester/FSPM/Trackly/Trackly/node_modules/uploadthing/src/_internal/config.ts","file:///D:/840%20G3/7th%20semester/FSPM/Trackly/Trackly/node_modules/uploadthing/src/_internal/error-formatter.ts","file:///D:/840%20G3/7th%20semester/FSPM/Trackly/Trackly/node_modules/uploadthing/src/_internal/jsonl.ts","file:///D:/840%20G3/7th%20semester/FSPM/Trackly/Trackly/node_modules/uploadthing/src/_internal/logger.ts","file:///D:/840%20G3/7th%20semester/FSPM/Trackly/Trackly/node_modules/uploadthing/src/_internal/parser.ts","file:///D:/840%20G3/7th%20semester/FSPM/Trackly/Trackly/node_modules/uploadthing/src/_internal/route-config.ts","file:///D:/840%20G3/7th%20semester/FSPM/Trackly/Trackly/node_modules/uploadthing/src/_internal/runtime.ts","file:///D:/840%20G3/7th%20semester/FSPM/Trackly/Trackly/node_modules/uploadthing/src/_internal/types.ts","file:///D:/840%20G3/7th%20semester/FSPM/Trackly/Trackly/node_modules/uploadthing/src/_internal/handler.ts","file:///D:/840%20G3/7th%20semester/FSPM/Trackly/Trackly/node_modules/uploadthing/src/_internal/upload-builder.ts"],"sourcesContent":["import * as Config from \"effect/Config\";\nimport * as ConfigProvider from \"effect/ConfigProvider\";\nimport * as Effect from \"effect/Effect\";\nimport * as S from \"effect/Schema\";\n\nimport {\n  filterDefinedObjectValues,\n  UploadThingError,\n} from \"@uploadthing/shared\";\n\nimport { UploadThingToken } from \"./shared-schemas\";\n\nexport { version as UPLOADTHING_VERSION } from \"../../package.json\";\n\n/**\n * Merge in `import.meta.env` to the built-in `process.env` provider\n * Prefix keys with `UPLOADTHING_` so we can reference just the name.\n * @example\n * process.env.UPLOADTHING_TOKEN = \"foo\"\n * Config.string(\"token\"); // Config<\"foo\">\n */\nconst envProvider = ConfigProvider.fromEnv().pipe(\n  ConfigProvider.orElse(() =>\n    ConfigProvider.fromMap(\n      new Map(\n        Object.entries(\n          filterDefinedObjectValues(\n            // fuck this I give up. import.meta is a mistake, someone else can fix it\n            (\n              import.meta as unknown as\n                | { env: Record<string, string> }\n                | undefined\n            )?.env ?? {},\n          ),\n        ),\n      ),\n      {\n        pathDelim: \"_\",\n      },\n    ),\n  ),\n  ConfigProvider.nested(\"uploadthing\"),\n  ConfigProvider.constantCase,\n);\n\n/**\n * Config provider that merges the options from the object\n * and environment variables prefixed with `UPLOADTHING_`.\n * @remarks Options take precedence over environment variables.\n */\nexport const configProvider = (options: unknown) =>\n  ConfigProvider.fromJson(options ?? {}).pipe(\n    ConfigProvider.orElse(() => envProvider),\n  );\n\nexport const IsDevelopment = Config.boolean(\"isDev\").pipe(\n  Config.orElse(() =>\n    Config.succeed(\n      typeof process !== \"undefined\" ? process.env.NODE_ENV : undefined,\n    ).pipe(Config.map((_) => _ === \"development\")),\n  ),\n  Config.withDefault(false),\n);\n\nexport const UTToken = S.Config(\"token\", UploadThingToken).pipe(\n  Effect.catchTags({\n    ConfigError: (e) =>\n      new UploadThingError({\n        code: e._op === \"InvalidData\" ? \"INVALID_SERVER_CONFIG\" : \"MISSING_ENV\",\n        message:\n          e._op === \"InvalidData\"\n            ? \"Invalid token. A token is a base64 encoded JSON object matching { apiKey: string, appId: string, regions: string[] }.\"\n            : \"Missing token. Please set the `UPLOADTHING_TOKEN` environment variable or provide a token manually through config.\",\n        cause: e,\n      }),\n  }),\n);\n\nexport const ApiUrl = Config.string(\"apiUrl\").pipe(\n  Config.withDefault(\"https://api.uploadthing.com\"),\n  Config.mapAttempt((_) => new URL(_)),\n  Config.map((url) => url.href.replace(/\\/$/, \"\")),\n);\n\nexport const IngestUrl = Effect.fn(function* (\n  preferredRegion: string | undefined,\n) {\n  const { regions, ingestHost } = yield* UTToken;\n\n  const region = preferredRegion\n    ? (regions.find((r) => r === preferredRegion) ?? regions[0])\n    : regions[0];\n\n  return yield* Config.string(\"ingestUrl\").pipe(\n    Config.withDefault(`https://${region}.${ingestHost}`),\n    Config.mapAttempt((_) => new URL(_)),\n    Config.map((url) => url.href.replace(/\\/$/, \"\")),\n  );\n});\n\nexport const UtfsHost = Config.string(\"utfsHost\").pipe(\n  Config.withDefault(\"utfs.io\"),\n);\n\nexport const UfsHost = Config.string(\"ufsHost\").pipe(\n  Config.withDefault(\"ufs.sh\"),\n);\n\nexport const UfsAppIdLocation = Config.literal(\n  \"subdomain\",\n  \"path\",\n)(\"ufsAppIdLocation\").pipe(Config.withDefault(\"subdomain\"));\n","import type { UploadThingError } from \"@uploadthing/shared\";\n\nimport type { FileRouter, inferErrorShape } from \"../types\";\n\nexport function defaultErrorFormatter(error: UploadThingError) {\n  return {\n    message: error.message,\n  };\n}\n\nexport function formatError(\n  error: UploadThingError,\n  router: FileRouter,\n): inferErrorShape<FileRouter[string]> {\n  const firstSlug = Object.keys(router)[0];\n  const errorFormatter = firstSlug\n    ? (router[firstSlug]?.errorFormatter ?? defaultErrorFormatter)\n    : defaultErrorFormatter;\n\n  return errorFormatter(error);\n}\n","import * as Effect from \"effect/Effect\";\nimport * as S from \"effect/Schema\";\nimport * as Stream from \"effect/Stream\";\n\nexport const handleJsonLineStream =\n  <TChunk>(\n    schema: S.Schema<TChunk>,\n    onChunk: (chunk: TChunk) => Effect.Effect<void>,\n  ) =>\n  <E, R>(stream: Stream.Stream<Uint8Array, E, R>) => {\n    let buf = \"\";\n\n    return stream.pipe(\n      Stream.decodeText(),\n      Stream.mapEffect((chunk) =>\n        Effect.gen(function* () {\n          buf += chunk;\n\n          // Scan buffer for newlines\n          const parts = buf.split(\"\\n\");\n          const validChunks: unknown[] = [];\n\n          for (const part of parts) {\n            try {\n              // Attempt to parse chunk as JSON\n              validChunks.push(JSON.parse(part) as unknown);\n              // Advance buffer if parsing succeeded\n              buf = buf.slice(part.length + 1);\n            } catch {\n              //\n            }\n          }\n\n          yield* Effect.logDebug(\"Received chunks\").pipe(\n            Effect.annotateLogs(\"chunk\", chunk),\n            Effect.annotateLogs(\"parsedChunks\", validChunks),\n            Effect.annotateLogs(\"buf\", buf),\n          );\n\n          return validChunks;\n        }),\n      ),\n      Stream.mapEffect(S.decodeUnknown(S.Array(schema))),\n      Stream.mapEffect(Effect.forEach((part) => onChunk(part))),\n      Stream.runDrain,\n      Effect.withLogSpan(\"handleJsonLineStream\"),\n    );\n  };\n","import type * as HttpBody from \"@effect/platform/HttpBody\";\nimport type * as HttpClientError from \"@effect/platform/HttpClientError\";\nimport type * as HttpClientResponse from \"@effect/platform/HttpClientResponse\";\nimport * as Config from \"effect/Config\";\nimport * as ConfigError from \"effect/ConfigError\";\nimport * as Effect from \"effect/Effect\";\nimport * as Either from \"effect/Either\";\nimport * as Layer from \"effect/Layer\";\nimport * as Logger from \"effect/Logger\";\nimport * as LogLevel from \"effect/LogLevel\";\n\nimport { UploadThingError } from \"@uploadthing/shared\";\n\nimport { IsDevelopment } from \"./config\";\n\n/**\n * Config.logLevel counter-intuitively accepts LogLevel[\"label\"]\n * instead of a literal, ripping it and changing to accept literal\n * Effect 4.0 will change this to accept a literal and then we can\n * remove this and go back to the built-in validator.\n */\nconst ConfigLogLevel = (name?: string): Config.Config<LogLevel.LogLevel> => {\n  const config = Config.mapOrFail(Config.string(), (literal) => {\n    const level = LogLevel.allLevels.find((level) => level._tag === literal);\n    return level === undefined\n      ? Either.left(\n          ConfigError.InvalidData(\n            [],\n            `Expected a log level but received ${literal}`,\n          ),\n        )\n      : Either.right(level);\n  });\n  return name === undefined ? config : Config.nested(config, name);\n};\n\nexport const withMinimalLogLevel = ConfigLogLevel(\"logLevel\").pipe(\n  Config.withDefault(LogLevel.Info),\n  Effect.andThen((level) => Logger.minimumLogLevel(level)),\n  Effect.tapError((e) =>\n    Effect.logError(\"Invalid log level\").pipe(Effect.annotateLogs(\"error\", e)),\n  ),\n  Effect.catchTag(\n    \"ConfigError\",\n    (e) =>\n      new UploadThingError({\n        code: \"INVALID_SERVER_CONFIG\",\n        message: \"Invalid server configuration\",\n        cause: e,\n      }),\n  ),\n  Layer.unwrapEffect,\n);\n\nexport const LogFormat = Config.literal(\n  \"json\",\n  \"logFmt\",\n  \"structured\",\n  \"pretty\",\n)(\"logFormat\");\nexport type LogFormat = Config.Config.Success<typeof LogFormat>;\n\nexport const withLogFormat = Effect.gen(function* () {\n  const isDev = yield* IsDevelopment;\n  const logFormat = yield* LogFormat.pipe(\n    Config.withDefault(isDev ? \"pretty\" : \"json\"),\n  );\n  return Logger[logFormat];\n}).pipe(\n  Effect.catchTag(\n    \"ConfigError\",\n    (e) =>\n      new UploadThingError({\n        code: \"INVALID_SERVER_CONFIG\",\n        message: \"Invalid server configuration\",\n        cause: e,\n      }),\n  ),\n  Layer.unwrapEffect,\n);\n\ntype HttpClientResponseMixinMethod = \"json\" | \"text\" | \"arrayBuffer\" | \"None\";\n\nexport const logHttpClientResponse = (\n  message: string,\n  opts?: {\n    /** Level to log on, default \"Debug\" */\n    level?: LogLevel.Literal;\n    /** What body mixin to use to get the response body, default \"json\" */\n    mixin?: HttpClientResponseMixinMethod;\n  },\n) => {\n  const mixin = opts?.mixin ?? \"json\";\n  const level = LogLevel.fromLiteral(opts?.level ?? \"Debug\");\n\n  return (response: HttpClientResponse.HttpClientResponse) =>\n    Effect.flatMap(mixin !== \"None\" ? response[mixin] : Effect.void, () =>\n      Effect.logWithLevel(level, `${message} (${response.status})`).pipe(\n        Effect.annotateLogs(\"response\", response),\n      ),\n    );\n};\n\nexport const logHttpClientError =\n  (message: string) =>\n  (err: HttpClientError.HttpClientError | HttpBody.HttpBodyError) =>\n    err._tag === \"ResponseError\"\n      ? logHttpClientResponse(message, { level: \"Error\" })(err.response)\n      : Effect.logError(message).pipe(Effect.annotateLogs(\"error\", err));\n","import type * as Standard from \"@standard-schema/spec\";\nimport * as Cause from \"effect/Cause\";\nimport * as Data from \"effect/Data\";\nimport * as Runtime from \"effect/Runtime\";\nimport * as Schema from \"effect/Schema\";\n\nimport type { Json } from \"@uploadthing/shared\";\n\nexport type ParseFn<TType> = (input: unknown) => Promise<TType>;\n\nexport type ParserZodEsque<TInput extends Json, TParsedInput> = {\n  _input: TInput;\n  _output: TParsedInput; // if using .transform etc\n  parseAsync: ParseFn<TParsedInput>;\n};\n\n// In case we add support for more parsers later\nexport type JsonParser<In extends Json, Out = In> =\n  | ParserZodEsque<In, Out>\n  | Standard.StandardSchemaV1<In, Out>\n  | Schema.Schema<Out, In>;\n\nexport class ParserError extends Data.TaggedError(\"ParserError\")<{\n  cause: unknown;\n}> {\n  message =\n    \"Input validation failed. The original error with it's validation issues is in the error cause.\";\n}\n\nexport function getParseFn<\n  TOut extends Json,\n  TParser extends JsonParser<any, TOut>,\n>(parser: TParser): ParseFn<TOut> {\n  if (\"parseAsync\" in parser && typeof parser.parseAsync === \"function\") {\n    /**\n     * Zod\n     * TODO (next major): Consider wrapping ZodError in ParserError\n     */\n    return parser.parseAsync;\n  }\n\n  if (Schema.isSchema(parser)) {\n    /**\n     * Effect Schema\n     */\n    return (value) =>\n      Schema.decodeUnknownPromise(parser as Schema.Schema<any, TOut>)(\n        value,\n      ).catch((error) => {\n        throw new ParserError({\n          cause: Cause.squash(\n            (error as Runtime.FiberFailure)[Runtime.FiberFailureCauseId],\n          ),\n        });\n      });\n  }\n\n  if (\"~standard\" in parser) {\n    /**\n     * Standard Schema\n     * TODO (next major): Consider moving this to the top of the function\n     */\n    return async (value) => {\n      const result = await parser[\"~standard\"].validate(value);\n      if (result.issues) {\n        throw new ParserError({ cause: result.issues });\n      }\n      return result.value;\n    };\n  }\n\n  throw new Error(\"Invalid parser\");\n}\n","import * as Data from \"effect/Data\";\nimport * as Effect from \"effect/Effect\";\nimport type * as S from \"effect/Schema\";\n\nimport type {\n  ExpandedRouteConfig,\n  FileRouterInputKey,\n  FileSize,\n  InvalidFileSizeError,\n  InvalidFileTypeError,\n  UnknownFileTypeError,\n} from \"@uploadthing/shared\";\nimport {\n  bytesToFileSize,\n  fileSizeToBytes,\n  fillInputRouteConfig,\n  InvalidRouteConfigError,\n  matchFileType,\n  objectKeys,\n  UploadThingError,\n} from \"@uploadthing/shared\";\n\nimport type { FileRouter } from \"../types\";\nimport type { UploadActionPayload } from \"./shared-schemas\";\n\nclass FileSizeMismatch extends Data.Error<{\n  reason: string;\n}> {\n  readonly _tag = \"FileSizeMismatch\";\n  readonly name = \"FileSizeMismatchError\";\n  constructor(type: FileRouterInputKey, max: FileSize, actual: number) {\n    const reason = `You uploaded a ${type} file that was ${bytesToFileSize(actual)}, but the limit for that type is ${max}`;\n    super({ reason });\n  }\n}\n\nclass FileCountMismatch extends Data.Error<{\n  reason: string;\n}> {\n  readonly _tag = \"FileCountMismatch\";\n  readonly name = \"FileCountMismatchError\";\n  constructor(\n    type: FileRouterInputKey,\n    boundtype: \"minimum\" | \"maximum\",\n    bound: number,\n    actual: number,\n  ) {\n    const reason = `You uploaded ${actual} file(s) of type '${type}', but the ${boundtype} for that type is ${bound}`;\n\n    super({ reason });\n  }\n}\n\n// Verify that the uploaded files doesn't violate the route config,\n// e.g. uploading more videos than allowed, or a file that is larger than allowed.\n// This is double-checked on infra side, but we want to fail early to avoid network latency.\nexport const assertFilesMeetConfig = (\n  files: S.Schema.Type<typeof UploadActionPayload>[\"files\"],\n  routeConfig: ExpandedRouteConfig,\n): Effect.Effect<\n  null,\n  | UploadThingError\n  | FileSizeMismatch\n  | FileCountMismatch\n  | InvalidRouteConfigError\n  | UnknownFileTypeError\n  | InvalidFileTypeError\n  | InvalidFileSizeError\n> =>\n  Effect.gen(function* () {\n    const counts: Record<string, number> = {};\n\n    for (const file of files) {\n      const type = yield* matchFileType(file, objectKeys(routeConfig));\n      counts[type] = (counts[type] ?? 0) + 1;\n\n      const sizeLimit = routeConfig[type]?.maxFileSize;\n      if (!sizeLimit) {\n        return yield* new InvalidRouteConfigError(type, \"maxFileSize\");\n      }\n      const sizeLimitBytes = yield* fileSizeToBytes(sizeLimit);\n\n      if (file.size > sizeLimitBytes) {\n        return yield* new FileSizeMismatch(type, sizeLimit, file.size);\n      }\n    }\n\n    for (const _key in counts) {\n      const key = _key as FileRouterInputKey;\n      const config = routeConfig[key];\n      if (!config) return yield* new InvalidRouteConfigError(key);\n\n      const count = counts[key];\n      const min = config.minFileCount;\n      const max = config.maxFileCount;\n\n      if (min > max) {\n        return yield* new UploadThingError({\n          code: \"BAD_REQUEST\",\n          message:\n            \"Invalid config during file count - minFileCount > maxFileCount\",\n          cause: `minFileCount must be less than maxFileCount for key ${key}. got: ${min} > ${max}`,\n        });\n      }\n\n      if (count != null && count < min) {\n        return yield* new FileCountMismatch(key, \"minimum\", min, count);\n      }\n      if (count != null && count > max) {\n        return yield* new FileCountMismatch(key, \"maximum\", max, count);\n      }\n    }\n\n    return null;\n  });\n\nexport const extractRouterConfig = <TRouter extends FileRouter>(\n  router: TRouter,\n) =>\n  Effect.forEach(objectKeys(router), (slug) =>\n    Effect.map(fillInputRouteConfig(router[slug]!.routerConfig), (config) => ({\n      slug,\n      config,\n    })),\n  );\n","import * as FetchHttpClient from \"@effect/platform/FetchHttpClient\";\nimport * as Headers from \"@effect/platform/Headers\";\nimport * as FiberRef from \"effect/FiberRef\";\nimport * as Layer from \"effect/Layer\";\nimport * as ManagedRuntime from \"effect/ManagedRuntime\";\n\nimport type { FetchEsque } from \"@uploadthing/shared\";\n\nimport { configProvider } from \"./config\";\nimport { withLogFormat, withMinimalLogLevel } from \"./logger\";\n\nexport const makeRuntime = (fetch: FetchEsque, config: unknown) => {\n  const fetchHttpClient = Layer.provideMerge(\n    FetchHttpClient.layer,\n    Layer.succeed(FetchHttpClient.Fetch, fetch as typeof globalThis.fetch),\n  );\n\n  const withRedactedHeaders = Layer.effectDiscard(\n    FiberRef.update(Headers.currentRedactedNames, (_) =>\n      _.concat([\"x-uploadthing-api-key\"]),\n    ),\n  );\n\n  const layer = Layer.provide(\n    Layer.mergeAll(\n      withLogFormat,\n      withMinimalLogLevel,\n      fetchHttpClient,\n      withRedactedHeaders,\n    ),\n    Layer.setConfigProvider(configProvider(config)),\n  );\n  return ManagedRuntime.make(layer);\n};\n","import type { Schema } from \"effect/Schema\";\n\nimport type {\n  ErrorMessage,\n  FileRouterInputConfig,\n  Json,\n  JsonObject,\n  MaybePromise,\n  RouteOptions,\n  Simplify,\n  UploadThingError,\n} from \"@uploadthing/shared\";\n\nimport type { JsonParser } from \"./parser\";\nimport type {\n  FileUploadDataWithCustomId,\n  NewPresignedUrl,\n  UploadActionPayload,\n  UploadedFileData,\n} from \"./shared-schemas\";\n\nexport type UTRegionAlias =\n  | \"bom1\"\n  | \"icn1\"\n  | \"syd1\"\n  | \"can1\"\n  | \"fra1\"\n  | \"zrh1\"\n  | \"dub1\"\n  | \"cle1\"\n  | \"sfo1\"\n  | \"sea1\";\n\n/**\n * Marker used to select the region based on the incoming request\n */\nexport const UTRegion = Symbol(\"uploadthing-region-symbol\");\n\n/**\n * Marker used to append a `customId` to the incoming file data in `.middleware()`\n * @example\n * ```ts\n * .middleware((opts) => {\n *   return {\n *     [UTFiles]: opts.files.map((file) => ({\n *       ...file,\n *       customId: generateId(),\n *     }))\n *   };\n * })\n * ```\n */\nexport const UTFiles = Symbol(\"uploadthing-custom-id-symbol\");\n\nexport type UnsetMarker = \"unsetMarker\" & {\n  __brand: \"unsetMarker\";\n};\n\nexport type ValidMiddlewareObject = {\n  [UTRegion]?: UTRegionAlias;\n  [UTFiles]?: Partial<FileUploadDataWithCustomId>[];\n  [key: string]: unknown;\n};\n\nexport interface AnyParams {\n  _routeOptions: any;\n  _input: {\n    in: any;\n    out: any;\n  };\n  _metadata: any; // imaginary field used to bind metadata return type to an Upload resolver\n  _adapterFnArgs: Record<string, unknown>;\n  _errorShape: any;\n  _errorFn: any; // used for onUploadError\n  _output: any;\n}\n\ntype MiddlewareFn<\n  TInput extends Json | UnsetMarker,\n  TOutput extends ValidMiddlewareObject,\n  TArgs extends Record<string, unknown>,\n> = (\n  opts: TArgs & {\n    files: Schema.Type<typeof UploadActionPayload>[\"files\"];\n    input: TInput extends UnsetMarker ? undefined : TInput;\n  },\n) => MaybePromise<TOutput>;\n\ntype UploadCompleteFn<\n  TMetadata,\n  TOutput extends JsonObject | void,\n  TArgs extends Record<string, unknown>,\n> = (\n  opts: TArgs & {\n    metadata: TMetadata;\n    file: UploadedFileData;\n  },\n) => MaybePromise<TOutput>;\n\ntype UploadErrorFn<TArgs extends Record<string, unknown>> = (\n  input: TArgs & {\n    error: UploadThingError;\n    fileKey: string;\n  },\n) => MaybePromise<void>;\n\nexport interface UploadBuilder<TParams extends AnyParams> {\n  input: <TIn extends Json, TOut>(\n    parser: TParams[\"_input\"][\"in\"] extends UnsetMarker\n      ? JsonParser<TIn, TOut>\n      : ErrorMessage<\"input is already set\">,\n  ) => UploadBuilder<{\n    _routeOptions: TParams[\"_routeOptions\"];\n    _input: { in: TIn; out: TOut };\n    _metadata: TParams[\"_metadata\"];\n    _adapterFnArgs: TParams[\"_adapterFnArgs\"];\n    _errorShape: TParams[\"_errorShape\"];\n    _errorFn: TParams[\"_errorFn\"];\n    _output: UnsetMarker;\n  }>;\n  middleware: <TOutput extends ValidMiddlewareObject>(\n    fn: TParams[\"_metadata\"] extends UnsetMarker\n      ? MiddlewareFn<\n          TParams[\"_input\"][\"out\"],\n          TOutput,\n          TParams[\"_adapterFnArgs\"]\n        >\n      : ErrorMessage<\"middleware is already set\">,\n  ) => UploadBuilder<{\n    _routeOptions: TParams[\"_routeOptions\"];\n    _input: TParams[\"_input\"];\n    _metadata: TOutput;\n    _adapterFnArgs: TParams[\"_adapterFnArgs\"];\n    _errorShape: TParams[\"_errorShape\"];\n    _errorFn: TParams[\"_errorFn\"];\n    _output: UnsetMarker;\n  }>;\n  onUploadError: (\n    fn: TParams[\"_errorFn\"] extends UnsetMarker\n      ? UploadErrorFn<TParams[\"_adapterFnArgs\"]>\n      : ErrorMessage<\"onUploadError is already set\">,\n  ) => UploadBuilder<{\n    _routeOptions: TParams[\"_routeOptions\"];\n    _input: TParams[\"_input\"];\n    _metadata: TParams[\"_metadata\"];\n    _adapterFnArgs: TParams[\"_adapterFnArgs\"];\n    _errorShape: TParams[\"_errorShape\"];\n    _errorFn: UploadErrorFn<TParams[\"_adapterFnArgs\"]>;\n    _output: UnsetMarker;\n  }>;\n  onUploadComplete: <TOutput extends JsonObject | void>(\n    fn: UploadCompleteFn<\n      Simplify<\n        TParams[\"_metadata\"] extends UnsetMarker\n          ? undefined\n          : Omit<TParams[\"_metadata\"], typeof UTFiles | typeof UTRegion>\n      >,\n      TOutput,\n      TParams[\"_adapterFnArgs\"]\n    >,\n  ) => FileRoute<{\n    input: TParams[\"_input\"][\"in\"] extends UnsetMarker\n      ? undefined\n      : TParams[\"_input\"][\"in\"];\n    output: TParams[\"_routeOptions\"][\"awaitServerData\"] extends false\n      ? null\n      : TOutput extends void | undefined // JSON serialization\n        ? null\n        : TOutput;\n    errorShape: TParams[\"_errorShape\"];\n  }>;\n}\n\nexport type AnyBuiltUploaderTypes = {\n  input: any;\n  output: any;\n  errorShape: any;\n};\n\nexport interface FileRoute<TTypes extends AnyBuiltUploaderTypes> {\n  $types: TTypes;\n  routerConfig: FileRouterInputConfig;\n  routeOptions: RouteOptions;\n  inputParser: JsonParser<any>;\n  middleware: MiddlewareFn<any, ValidMiddlewareObject, any>;\n  onUploadError: UploadErrorFn<any>;\n  errorFormatter: (err: UploadThingError) => any;\n  onUploadComplete: UploadCompleteFn<any, any, any>;\n}\nexport type AnyFileRoute = FileRoute<AnyBuiltUploaderTypes>;\n\n/**\n * Map actionType to the required payload for that action\n * @todo Look into using @effect/rpc :thinking:\n */\nexport type UTEvents = {\n  upload: {\n    in: UploadActionPayload;\n    out: ReadonlyArray<NewPresignedUrl>;\n  };\n};\n\n/**\n * Result from the PUT request to the UploadThing Ingest server\n */\nexport type UploadPutResult<TServerOutput = unknown> = {\n  ufsUrl: string;\n  /**\n   * @deprecated\n   * This field will be removed in uploadthing v9. Use `ufsUrl` instead.\n   */\n  url: string;\n  /**\n   * @deprecated\n   * This field will be removed in uploadthing v9. Use `ufsUrl` instead.\n   */\n  appUrl: string;\n  fileHash: string;\n  serverData: TServerOutput;\n};\n","import * as HttpApp from \"@effect/platform/HttpApp\";\nimport * as HttpBody from \"@effect/platform/HttpBody\";\nimport * as HttpClient from \"@effect/platform/HttpClient\";\nimport type * as HttpClientError from \"@effect/platform/HttpClientError\";\nimport * as HttpClientRequest from \"@effect/platform/HttpClientRequest\";\nimport * as HttpClientResponse from \"@effect/platform/HttpClientResponse\";\nimport * as HttpRouter from \"@effect/platform/HttpRouter\";\nimport * as HttpServerRequest from \"@effect/platform/HttpServerRequest\";\nimport * as HttpServerResponse from \"@effect/platform/HttpServerResponse\";\nimport * as Config from \"effect/Config\";\nimport * as Context from \"effect/Context\";\nimport * as Effect from \"effect/Effect\";\nimport * as Match from \"effect/Match\";\nimport * as Redacted from \"effect/Redacted\";\nimport * as Schema from \"effect/Schema\";\n\nimport {\n  fillInputRouteConfig,\n  generateKey,\n  generateSignedURL,\n  getStatusCodeFromError,\n  matchFileType,\n  objectKeys,\n  UploadThingError,\n  verifySignature,\n} from \"@uploadthing/shared\";\n\nimport * as pkgJson from \"../../package.json\";\nimport type { FileRouter, RouteHandlerOptions } from \"../types\";\nimport { IngestUrl, IsDevelopment, UTToken } from \"./config\";\nimport { logDeprecationWarning } from \"./deprecations\";\nimport { formatError } from \"./error-formatter\";\nimport { handleJsonLineStream } from \"./jsonl\";\nimport { logHttpClientError, logHttpClientResponse } from \"./logger\";\nimport { getParseFn } from \"./parser\";\nimport { assertFilesMeetConfig, extractRouterConfig } from \"./route-config\";\nimport { makeRuntime } from \"./runtime\";\nimport {\n  ActionType,\n  CallbackResultResponse,\n  MetadataFetchResponse,\n  MetadataFetchStreamPart,\n  UploadActionPayload,\n  UploadedFileData,\n  UploadThingHook,\n} from \"./shared-schemas\";\nimport { UTFiles, UTRegion } from \"./types\";\nimport type { AnyFileRoute, UTEvents } from \"./types\";\n\nexport class AdapterArguments extends Context.Tag(\n  \"uploadthing/AdapterArguments\",\n)<AdapterArguments, Record<string, unknown>>() {}\n\n/**\n * Create a request handler adapter for any framework or server library.\n * Refer to the existing adapters for examples on how to use this function.\n * @public\n *\n * @param makeAdapterArgs - Function that takes the args from your framework and returns an Effect that resolves to the adapter args.\n * These args are passed to the `.middleware`, `.onUploadComplete`, and `.onUploadError` hooks.\n * @param toRequest - Function that takes the args from your framework and returns an Effect that resolves to a web Request object.\n * @param opts - The router config and other options that are normally passed to `createRequestHandler` of official adapters\n * @param beAdapter - [Optional] The adapter name of the adapter, used for telemetry purposes\n * @returns A function that takes the args from your framework and returns a promise that resolves to a Response object.\n */\nexport const makeAdapterHandler = <\n  Args extends any[],\n  AdapterArgs extends Record<string, unknown>,\n>(\n  makeAdapterArgs: (...args: Args) => Effect.Effect<AdapterArgs>,\n  toRequest: (...args: Args) => Effect.Effect<Request>,\n  opts: RouteHandlerOptions<FileRouter>,\n  beAdapter?: string,\n): ((...args: Args) => Promise<Response>) => {\n  const managed = makeRuntime(\n    opts.config?.fetch as typeof globalThis.fetch,\n    opts.config,\n  );\n  const handle = Effect.promise(() =>\n    managed.runtime().then(HttpApp.toWebHandlerRuntime),\n  );\n\n  const app = (...args: Args) =>\n    Effect.map(\n      Effect.promise(() =>\n        managed.runPromise(createRequestHandler(opts, beAdapter ?? \"custom\")),\n      ),\n      Effect.provideServiceEffect(AdapterArguments, makeAdapterArgs(...args)),\n    );\n\n  return async (...args: Args) => {\n    const result = await handle.pipe(\n      Effect.ap(app(...args)),\n      Effect.ap(toRequest(...args)),\n      Effect.withLogSpan(\"requestHandler\"),\n      managed.runPromise,\n    );\n\n    return result;\n  };\n};\n\nexport const createRequestHandler = <TRouter extends FileRouter>(\n  opts: RouteHandlerOptions<TRouter>,\n  beAdapter: string,\n) =>\n  Effect.gen(function* () {\n    const isDevelopment = yield* IsDevelopment;\n    const routerConfig = yield* extractRouterConfig(opts.router);\n\n    const handleDaemon = (() => {\n      if (opts.config?.handleDaemonPromise) {\n        return opts.config.handleDaemonPromise;\n      }\n      return isDevelopment ? \"void\" : \"await\";\n    })();\n    if (isDevelopment && handleDaemon === \"await\") {\n      return yield* new UploadThingError({\n        code: \"INVALID_SERVER_CONFIG\",\n        message: 'handleDaemonPromise: \"await\" is forbidden in development.',\n      });\n    }\n\n    const GET = Effect.gen(function* () {\n      return yield* HttpServerResponse.json(routerConfig);\n    });\n\n    const POST = Effect.gen(function* () {\n      const {\n        \"uploadthing-hook\": uploadthingHook,\n        \"x-uploadthing-package\": fePackage,\n        \"x-uploadthing-version\": clientVersion,\n      } = yield* HttpServerRequest.schemaHeaders(\n        Schema.Struct({\n          \"uploadthing-hook\": UploadThingHook.pipe(Schema.optional),\n          \"x-uploadthing-package\": Schema.String.pipe(\n            Schema.optionalWith({ default: () => \"unknown\" }),\n          ),\n          \"x-uploadthing-version\": Schema.String.pipe(\n            Schema.optionalWith({ default: () => pkgJson.version }),\n          ),\n        }),\n      );\n\n      if (clientVersion !== pkgJson.version) {\n        const serverVersion = pkgJson.version;\n        yield* Effect.logWarning(\n          \"Client version mismatch. Things may not work as expected, please sync your versions to ensure compatibility.\",\n        ).pipe(Effect.annotateLogs({ clientVersion, serverVersion }));\n      }\n\n      const { slug, actionType } = yield* HttpRouter.schemaParams(\n        Schema.Struct({\n          actionType: ActionType.pipe(Schema.optional),\n          slug: Schema.String,\n        }),\n      );\n\n      const uploadable = opts.router[slug];\n      if (!uploadable) {\n        const msg = `No file route found for slug ${slug}`;\n        yield* Effect.logError(msg);\n        return yield* new UploadThingError({\n          code: \"NOT_FOUND\",\n          message: msg,\n        });\n      }\n\n      const { body, fiber } = yield* Match.value({\n        actionType,\n        uploadthingHook,\n      }).pipe(\n        Match.when({ actionType: \"upload\", uploadthingHook: undefined }, () =>\n          handleUploadAction({\n            uploadable,\n            fePackage,\n            beAdapter,\n            slug,\n          }),\n        ),\n        Match.when({ actionType: undefined, uploadthingHook: \"callback\" }, () =>\n          handleCallbackRequest({ uploadable, fePackage, beAdapter }),\n        ),\n        Match.when({ actionType: undefined, uploadthingHook: \"error\" }, () =>\n          handleErrorRequest({ uploadable }),\n        ),\n        Match.orElse(() => Effect.succeed({ body: null, fiber: null })),\n      );\n\n      if (fiber) {\n        yield* Effect.logDebug(\"Running fiber as daemon\").pipe(\n          Effect.annotateLogs(\"handleDaemon\", handleDaemon),\n        );\n        if (handleDaemon === \"void\") {\n          // noop\n        } else if (handleDaemon === \"await\") {\n          yield* fiber.await;\n        } else if (typeof handleDaemon === \"function\") {\n          handleDaemon(Effect.runPromise(fiber.await));\n        }\n      }\n\n      yield* Effect.logDebug(\"Sending response\").pipe(\n        Effect.annotateLogs(\"body\", body),\n      );\n\n      return yield* HttpServerResponse.json(body);\n    }).pipe(\n      Effect.catchTags({\n        ParseError: (e) =>\n          HttpServerResponse.json(\n            formatError(\n              new UploadThingError({\n                code: \"BAD_REQUEST\",\n                message: \"Invalid input\",\n                cause: e.message,\n              }),\n              opts.router,\n            ),\n            { status: 400 },\n          ),\n        UploadThingError: (e) =>\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n          HttpServerResponse.json(formatError(e, opts.router), {\n            status: getStatusCodeFromError(e),\n          }),\n      }),\n    );\n\n    const appendResponseHeaders = Effect.map(\n      HttpServerResponse.setHeader(\"x-uploadthing-version\", pkgJson.version),\n    );\n\n    return HttpRouter.empty.pipe(\n      HttpRouter.get(\"*\", GET),\n      HttpRouter.post(\"*\", POST),\n      HttpRouter.use(appendResponseHeaders),\n    );\n  }).pipe(Effect.withLogSpan(\"createRequestHandler\"));\n\nconst handleErrorRequest = (opts: { uploadable: AnyFileRoute }) =>\n  Effect.gen(function* () {\n    const { uploadable } = opts;\n    const request = yield* HttpServerRequest.HttpServerRequest;\n    const { apiKey } = yield* UTToken;\n    const verified = yield* verifySignature(\n      yield* request.text,\n      request.headers[\"x-uploadthing-signature\"] ?? null,\n      apiKey,\n    );\n    yield* Effect.logDebug(`Signature verified: ${verified}`);\n    if (!verified) {\n      yield* Effect.logError(\"Invalid signature\");\n      return yield* new UploadThingError({\n        code: \"BAD_REQUEST\",\n        message: \"Invalid signature\",\n      });\n    }\n\n    const requestInput = yield* HttpServerRequest.schemaBodyJson(\n      Schema.Struct({\n        fileKey: Schema.String,\n        error: Schema.String,\n      }),\n    );\n    yield* Effect.logDebug(\"Handling error callback request with input:\").pipe(\n      Effect.annotateLogs(\"json\", requestInput),\n    );\n\n    const adapterArgs = yield* AdapterArguments;\n    const fiber = yield* Effect.tryPromise({\n      try: async () =>\n        uploadable.onUploadError({\n          ...adapterArgs,\n          error: new UploadThingError({\n            code: \"UPLOAD_FAILED\",\n            message: `Upload failed for ${requestInput.fileKey}: ${requestInput.error}`,\n          }),\n          fileKey: requestInput.fileKey,\n        }),\n      catch: (error) =>\n        new UploadThingError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to run onUploadError\",\n          cause: error,\n        }),\n    })\n      .pipe(\n        Effect.tapError((error) =>\n          Effect.logError(\n            \"Failed to run onUploadError. You probably shouldn't be throwing errors here.\",\n          ).pipe(Effect.annotateLogs(\"error\", error)),\n        ),\n      )\n      .pipe(Effect.ignoreLogged, Effect.forkDaemon);\n\n    return {\n      body: null,\n      fiber,\n    };\n  }).pipe(Effect.withLogSpan(\"handleErrorRequest\"));\n\nconst handleCallbackRequest = (opts: {\n  uploadable: AnyFileRoute;\n  fePackage: string;\n  beAdapter: string;\n}) =>\n  Effect.gen(function* () {\n    const { uploadable, fePackage, beAdapter } = opts;\n    const request = yield* HttpServerRequest.HttpServerRequest;\n    const { apiKey } = yield* UTToken;\n    const verified = yield* verifySignature(\n      yield* request.text,\n      request.headers[\"x-uploadthing-signature\"] ?? null,\n      apiKey,\n    );\n    yield* Effect.logDebug(`Signature verified: ${verified}`);\n    if (!verified) {\n      yield* Effect.logError(\"Invalid signature\");\n      return yield* new UploadThingError({\n        code: \"BAD_REQUEST\",\n        message: \"Invalid signature\",\n      });\n    }\n\n    const requestInput = yield* HttpServerRequest.schemaBodyJson(\n      Schema.Struct({\n        status: Schema.String,\n        file: UploadedFileData,\n        origin: Schema.String,\n        metadata: Schema.Record({ key: Schema.String, value: Schema.Unknown }),\n      }),\n    );\n    yield* Effect.logDebug(\"Handling callback request with input:\").pipe(\n      Effect.annotateLogs(\"json\", requestInput),\n    );\n\n    /**\n     * Run `.onUploadComplete` as a daemon to prevent the\n     * request from UT to potentially timeout.\n     */\n    const fiber = yield* Effect.gen(function* () {\n      const adapterArgs = yield* AdapterArguments;\n      const serverData = yield* Effect.tryPromise({\n        try: async () =>\n          uploadable.onUploadComplete({\n            ...adapterArgs,\n            file: {\n              ...requestInput.file,\n              get url() {\n                logDeprecationWarning(\n                  \"`file.url` is deprecated and will be removed in uploadthing v9. Use `file.ufsUrl` instead.\",\n                );\n                return requestInput.file.url;\n              },\n              get appUrl() {\n                logDeprecationWarning(\n                  \"`file.appUrl` is deprecated and will be removed in uploadthing v9. Use `file.ufsUrl` instead.\",\n                );\n                return requestInput.file.appUrl;\n              },\n            },\n            metadata: requestInput.metadata,\n          }) as Promise<unknown>,\n        catch: (error) =>\n          new UploadThingError({\n            code: \"INTERNAL_SERVER_ERROR\",\n            message:\n              \"Failed to run onUploadComplete. You probably shouldn't be throwing errors here.\",\n            cause: error,\n          }),\n      });\n      const payload = {\n        fileKey: requestInput.file.key,\n        callbackData: serverData ?? null,\n      };\n      yield* Effect.logDebug(\n        \"'onUploadComplete' callback finished. Sending response to UploadThing:\",\n      ).pipe(Effect.annotateLogs(\"callbackData\", payload));\n\n      const httpClient = (yield* HttpClient.HttpClient).pipe(\n        HttpClient.filterStatusOk,\n      );\n\n      yield* HttpClientRequest.post(`/callback-result`).pipe(\n        HttpClientRequest.prependUrl(requestInput.origin),\n        HttpClientRequest.setHeaders({\n          \"x-uploadthing-api-key\": Redacted.value(apiKey),\n          \"x-uploadthing-version\": pkgJson.version,\n          \"x-uploadthing-be-adapter\": beAdapter,\n          \"x-uploadthing-fe-package\": fePackage,\n        }),\n        HttpClientRequest.bodyJson(payload),\n        Effect.flatMap(httpClient.execute),\n        Effect.tapError(\n          logHttpClientError(\"Failed to register callback result\"),\n        ),\n        Effect.flatMap(\n          HttpClientResponse.schemaBodyJson(CallbackResultResponse),\n        ),\n        Effect.tap(Effect.log(\"Sent callback result to UploadThing\")),\n        Effect.scoped,\n      );\n    }).pipe(Effect.ignoreLogged, Effect.forkDaemon);\n\n    return { body: null, fiber };\n  }).pipe(Effect.withLogSpan(\"handleCallbackRequest\"));\n\nconst runRouteMiddleware = (opts: {\n  json: typeof UploadActionPayload.Type;\n  uploadable: AnyFileRoute;\n}) =>\n  Effect.gen(function* () {\n    const {\n      json: { files, input },\n      uploadable,\n    } = opts;\n\n    yield* Effect.logDebug(\"Running middleware\");\n    const adapterArgs = yield* AdapterArguments;\n    const metadata = yield* Effect.tryPromise({\n      try: async () =>\n        uploadable.middleware({\n          ...adapterArgs,\n          input,\n          files,\n        }),\n      catch: (error) =>\n        error instanceof UploadThingError\n          ? error\n          : new UploadThingError({\n              code: \"INTERNAL_SERVER_ERROR\",\n              message: \"Failed to run middleware\",\n              cause: error,\n            }),\n    });\n\n    if (metadata[UTFiles] && metadata[UTFiles].length !== files.length) {\n      const msg = `Expected files override to have the same length as original files, got ${metadata[UTFiles].length} but expected ${files.length}`;\n      yield* Effect.logError(msg);\n      return yield* new UploadThingError({\n        code: \"BAD_REQUEST\",\n        message: \"Files override must have the same length as files\",\n        cause: msg,\n      });\n    }\n\n    // Attach customIds from middleware to the files\n    const filesWithCustomIds = yield* Effect.forEach(files, (file, idx) =>\n      Effect.gen(function* () {\n        const theirs = metadata[UTFiles]?.[idx];\n        if (theirs && theirs.size !== file.size) {\n          yield* Effect.logWarning(\n            \"File size mismatch. Reverting to original size\",\n          );\n        }\n        return {\n          name: theirs?.name ?? file.name,\n          size: file.size,\n          type: file.type,\n          customId: theirs?.customId,\n          lastModified: theirs?.lastModified ?? Date.now(),\n        };\n      }),\n    );\n\n    return {\n      metadata,\n      filesWithCustomIds,\n      preferredRegion: metadata[UTRegion],\n    };\n  }).pipe(Effect.withLogSpan(\"runRouteMiddleware\"));\n\nconst handleUploadAction = (opts: {\n  uploadable: AnyFileRoute;\n  fePackage: string;\n  beAdapter: string;\n  slug: string;\n}) =>\n  Effect.gen(function* () {\n    const httpClient = (yield* HttpClient.HttpClient).pipe(\n      HttpClient.filterStatusOk,\n    );\n    const { uploadable, fePackage, beAdapter, slug } = opts;\n    const json = yield* HttpServerRequest.schemaBodyJson(UploadActionPayload);\n    yield* Effect.logDebug(\"Handling upload request\").pipe(\n      Effect.annotateLogs(\"json\", json),\n    );\n\n    // validate the input\n    yield* Effect.logDebug(\"Parsing user input\");\n    const parsedInput = yield* Effect.tryPromise({\n      try: () => getParseFn(uploadable.inputParser)(json.input),\n      catch: (error) =>\n        new UploadThingError({\n          code: \"BAD_REQUEST\",\n          message: \"Invalid input\",\n          cause: error,\n        }),\n    });\n    yield* Effect.logDebug(\"Input parsed successfully\").pipe(\n      Effect.annotateLogs(\"input\", parsedInput),\n    );\n\n    const { metadata, filesWithCustomIds, preferredRegion } =\n      yield* runRouteMiddleware({\n        json: { input: parsedInput, files: json.files },\n        uploadable,\n      });\n\n    yield* Effect.logDebug(\"Parsing route config\").pipe(\n      Effect.annotateLogs(\"routerConfig\", uploadable.routerConfig),\n    );\n    const parsedConfig = yield* fillInputRouteConfig(\n      uploadable.routerConfig,\n    ).pipe(\n      Effect.catchTag(\n        \"InvalidRouteConfig\",\n        (err) =>\n          new UploadThingError({\n            code: \"BAD_REQUEST\",\n            message: \"Invalid route config\",\n            cause: err,\n          }),\n      ),\n    );\n    yield* Effect.logDebug(\"Route config parsed successfully\").pipe(\n      Effect.annotateLogs(\"routeConfig\", parsedConfig),\n    );\n\n    yield* Effect.logDebug(\n      \"Validating files meet the config requirements\",\n    ).pipe(Effect.annotateLogs(\"files\", json.files));\n    yield* assertFilesMeetConfig(json.files, parsedConfig).pipe(\n      Effect.mapError(\n        (e) =>\n          new UploadThingError({\n            code: \"BAD_REQUEST\",\n            message: `Invalid config: ${e._tag}`,\n            cause: \"reason\" in e ? e.reason : e.message,\n          }),\n      ),\n    );\n    yield* Effect.logDebug(\"Files validated.\");\n\n    const fileUploadRequests = yield* Effect.forEach(\n      filesWithCustomIds,\n      (file) =>\n        Effect.map(matchFileType(file, objectKeys(parsedConfig)), (type) => ({\n          name: file.name,\n          size: file.size,\n          type: file.type || type,\n          lastModified: file.lastModified,\n          customId: file.customId,\n          contentDisposition:\n            parsedConfig[type]?.contentDisposition ?? \"inline\",\n          acl: parsedConfig[type]?.acl,\n        })),\n    ).pipe(\n      Effect.catchTags({\n        /** Shouldn't happen since config is validated above so just dying is fine I think */\n        InvalidFileType: (e) => Effect.die(e),\n        UnknownFileType: (e) => Effect.die(e),\n      }),\n    );\n\n    const routeOptions = uploadable.routeOptions;\n    const { apiKey, appId } = yield* UTToken;\n    const ingestUrl = yield* IngestUrl(preferredRegion);\n    const isDev = yield* IsDevelopment;\n\n    yield* Effect.logDebug(\"Generating presigned URLs\").pipe(\n      Effect.annotateLogs(\"fileUploadRequests\", fileUploadRequests),\n      Effect.annotateLogs(\"ingestUrl\", ingestUrl),\n    );\n    const presignedUrls = yield* Effect.forEach(\n      fileUploadRequests,\n      (file) =>\n        Effect.gen(function* () {\n          const key = yield* generateKey(\n            file,\n            appId,\n            routeOptions.getFileHashParts,\n          );\n\n          const url = yield* generateSignedURL(`${ingestUrl}/${key}`, apiKey, {\n            ttlInSeconds: routeOptions.presignedURLTTL,\n            data: {\n              \"x-ut-identifier\": appId,\n              \"x-ut-file-name\": file.name,\n              \"x-ut-file-size\": file.size,\n              \"x-ut-file-type\": file.type,\n              \"x-ut-slug\": slug,\n              \"x-ut-custom-id\": file.customId,\n              \"x-ut-content-disposition\": file.contentDisposition,\n              \"x-ut-acl\": file.acl,\n            },\n          });\n          return { url, key };\n        }),\n      { concurrency: \"unbounded\" },\n    );\n\n    const serverReq = yield* HttpServerRequest.HttpServerRequest;\n    const requestUrl = yield* HttpServerRequest.toURL(serverReq);\n\n    const devHookRequest = yield* Config.string(\"callbackUrl\").pipe(\n      Config.withDefault(requestUrl.origin + requestUrl.pathname),\n      Effect.map((url) =>\n        HttpClientRequest.post(url).pipe(\n          HttpClientRequest.appendUrlParam(\"slug\", slug),\n        ),\n      ),\n    );\n\n    const metadataRequest = HttpClientRequest.post(\"/route-metadata\").pipe(\n      HttpClientRequest.prependUrl(ingestUrl),\n      HttpClientRequest.setHeaders({\n        \"x-uploadthing-api-key\": Redacted.value(apiKey),\n        \"x-uploadthing-version\": pkgJson.version,\n        \"x-uploadthing-be-adapter\": beAdapter,\n        \"x-uploadthing-fe-package\": fePackage,\n      }),\n      HttpClientRequest.bodyJson({\n        fileKeys: presignedUrls.map(({ key }) => key),\n        metadata: metadata,\n        isDev,\n        callbackUrl: devHookRequest.url,\n        callbackSlug: slug,\n        awaitServerData: routeOptions.awaitServerData ?? true,\n      }),\n      Effect.flatMap(httpClient.execute),\n    );\n\n    const handleDevStreamError = Effect.fn(\"handleDevStreamError\")(function* (\n      err: HttpClientError.ResponseError,\n      chunk: string,\n    ) {\n      const schema = Schema.parseJson(\n        Schema.Struct({ file: UploadedFileData }),\n      );\n      const parsedChunk = yield* Schema.decodeUnknown(schema)(chunk);\n      const key = parsedChunk.file.key;\n\n      yield* Effect.logError(\n        \"Failed to forward callback request from dev stream\",\n      ).pipe(Effect.annotateLogs({ fileKey: key, error: err.message }));\n\n      const httpResponse = yield* HttpClientRequest.post(\n        \"/callback-result\",\n      ).pipe(\n        HttpClientRequest.prependUrl(ingestUrl),\n        HttpClientRequest.setHeaders({\n          \"x-uploadthing-api-key\": Redacted.value(apiKey),\n          \"x-uploadthing-version\": pkgJson.version,\n          \"x-uploadthing-be-adapter\": beAdapter,\n          \"x-uploadthing-fe-package\": fePackage,\n        }),\n        HttpClientRequest.bodyJson({\n          fileKey: key,\n          error: `Failed to forward callback request from dev stream: ${err.message}`,\n        }),\n        Effect.flatMap(httpClient.execute),\n      );\n\n      yield* logHttpClientResponse(\"Reported callback error to UploadThing\")(\n        httpResponse,\n      );\n    });\n\n    // Send metadata to UT server (non blocking as a daemon)\n    // In dev, keep the stream open and simulate the callback requests as\n    // files complete uploading\n    const fiber = yield* Effect.if(isDev, {\n      onTrue: () =>\n        metadataRequest.pipe(\n          Effect.tapBoth({\n            onSuccess: logHttpClientResponse(\"Registered metadata\", {\n              mixin: \"None\", // We're reading the stream so can't call a body mixin\n            }),\n            onFailure: logHttpClientError(\"Failed to register metadata\"),\n          }),\n          HttpClientResponse.stream,\n          handleJsonLineStream(MetadataFetchStreamPart, (chunk) =>\n            devHookRequest.pipe(\n              HttpClientRequest.setHeaders({\n                \"uploadthing-hook\": chunk.hook,\n                \"x-uploadthing-signature\": chunk.signature,\n              }),\n              HttpClientRequest.setBody(\n                HttpBody.text(chunk.payload, \"application/json\"),\n              ),\n              httpClient.execute,\n              Effect.tap(\n                logHttpClientResponse(\n                  \"Successfully forwarded callback request from dev stream\",\n                ),\n              ),\n              Effect.catchTag(\"ResponseError\", (err) =>\n                handleDevStreamError(err, chunk.payload),\n              ),\n              Effect.annotateLogs(chunk),\n              Effect.asVoid,\n              Effect.ignoreLogged,\n              Effect.scoped,\n            ),\n          ),\n        ),\n      onFalse: () =>\n        metadataRequest.pipe(\n          Effect.tapBoth({\n            onSuccess: logHttpClientResponse(\"Registered metadata\"),\n            onFailure: logHttpClientError(\"Failed to register metadata\"),\n          }),\n          Effect.flatMap(\n            HttpClientResponse.schemaBodyJson(MetadataFetchResponse),\n          ),\n          Effect.scoped,\n        ),\n    }).pipe(Effect.forkDaemon);\n\n    const presigneds = presignedUrls.map((p, i) => ({\n      url: p.url,\n      key: p.key,\n      name: fileUploadRequests[i]!.name,\n      customId: fileUploadRequests[i]!.customId ?? null,\n    }));\n\n    yield* Effect.logInfo(\"Sending presigned URLs to client\").pipe(\n      Effect.annotateLogs(\"presignedUrls\", presigneds),\n    );\n\n    return {\n      body: presigneds satisfies UTEvents[\"upload\"][\"out\"],\n      fiber,\n    };\n  }).pipe(Effect.withLogSpan(\"handleUploadAction\"));\n","import type {\n  FileRouterInputConfig,\n  Json,\n  RouteOptions,\n  UploadThingError,\n} from \"@uploadthing/shared\";\n\nimport { defaultErrorFormatter } from \"./error-formatter\";\nimport type {\n  AnyBuiltUploaderTypes,\n  AnyFileRoute,\n  UnsetMarker,\n  UploadBuilder,\n} from \"./types\";\n\nfunction internalCreateBuilder<\n  TAdapterFnArgs extends Record<string, unknown>,\n  TRouteOptions extends RouteOptions,\n  TErrorShape extends Json = { message: string },\n>(\n  initDef: Partial<AnyFileRoute> = {},\n): UploadBuilder<{\n  _routeOptions: TRouteOptions;\n  _input: { in: UnsetMarker; out: UnsetMarker };\n  _metadata: UnsetMarker;\n  _adapterFnArgs: TAdapterFnArgs;\n  _errorShape: TErrorShape;\n  _errorFn: UnsetMarker;\n  _output: UnsetMarker;\n}> {\n  const _def: AnyFileRoute = {\n    $types: {} as AnyBuiltUploaderTypes,\n    // Default router config\n    routerConfig: {\n      image: {\n        maxFileSize: \"4MB\",\n      },\n    },\n    routeOptions: {\n      awaitServerData: true,\n    },\n\n    inputParser: {\n      parseAsync: () => Promise.resolve(undefined),\n      _input: undefined,\n      _output: undefined,\n    },\n\n    middleware: () => ({}),\n    onUploadError: () => {\n      // noop\n    },\n    onUploadComplete: () => undefined,\n\n    errorFormatter: initDef.errorFormatter ?? defaultErrorFormatter,\n\n    // Overload with properties passed in\n    ...initDef,\n  };\n\n  return {\n    input(userParser) {\n      return internalCreateBuilder({\n        ..._def,\n        inputParser: userParser,\n      }) as UploadBuilder<any>;\n    },\n    middleware(userMiddleware) {\n      return internalCreateBuilder({\n        ..._def,\n        middleware: userMiddleware,\n      }) as UploadBuilder<any>;\n    },\n    onUploadComplete(userUploadComplete) {\n      return {\n        ..._def,\n        onUploadComplete: userUploadComplete,\n      } as AnyFileRoute;\n    },\n    onUploadError(userOnUploadError) {\n      return internalCreateBuilder({\n        ..._def,\n        onUploadError: userOnUploadError,\n      }) as UploadBuilder<any>;\n    },\n  };\n}\n\nexport type CreateBuilderOptions<TErrorShape extends Json> = {\n  errorFormatter: (err: UploadThingError) => TErrorShape;\n};\n\n/**\n * Create a builder for your backend adapter.\n * Refer to the existing adapters for examples on how to use this function.\n * @public\n *\n * @param opts - Options for the builder\n * @returns A file route builder for making UploadThing file routes\n */\nexport function createBuilder<\n  TAdapterFnArgs extends Record<string, unknown>,\n  TErrorShape extends Json = { message: string },\n>(opts?: CreateBuilderOptions<TErrorShape>) {\n  return <TRouteOptions extends RouteOptions>(\n    input: FileRouterInputConfig,\n    config?: TRouteOptions,\n  ): UploadBuilder<{\n    _routeOptions: TRouteOptions;\n    _input: { in: UnsetMarker; out: UnsetMarker };\n    _metadata: UnsetMarker;\n    _adapterFnArgs: TAdapterFnArgs;\n    _errorShape: TErrorShape;\n    _errorFn: UnsetMarker;\n    _output: UnsetMarker;\n  }> => {\n    return internalCreateBuilder<TAdapterFnArgs, TRouteOptions, TErrorShape>({\n      routerConfig: input,\n      routeOptions: config ?? {},\n      ...opts,\n    });\n  };\n}\n"],"names":["options: unknown","preferredRegion: string | undefined","error: UploadThingError","router: FileRouter","schema: S.Schema<TChunk>","onChunk: (chunk: TChunk) => Effect.Effect<void>","stream: Stream.Stream<Uint8Array, E, R>","validChunks: unknown[]","name?: string","level","Either","message: string","opts?: {\n    /** Level to log on, default \"Debug\" */\n    level?: LogLevel.Literal;\n    /** What body mixin to use to get the response body, default \"json\" */\n    mixin?: HttpClientResponseMixinMethod;\n  }","response: HttpClientResponse.HttpClientResponse","err: HttpClientError.HttpClientError | HttpBody.HttpBodyError","parser: TParser","Schema","type: FileRouterInputKey","max: FileSize","actual: number","boundtype: \"minimum\" | \"maximum\"","bound: number","files: S.Schema.Type<typeof UploadActionPayload>[\"files\"]","routeConfig: ExpandedRouteConfig","counts: Record<string, number>","router: TRouter","fetch: FetchEsque","config: unknown","makeAdapterArgs: (...args: Args) => Effect.Effect<AdapterArgs>","toRequest: (...args: Args) => Effect.Effect<Request>","opts: RouteHandlerOptions<FileRouter>","beAdapter?: string","opts: RouteHandlerOptions<TRouter>","beAdapter: string","Schema","opts: { uploadable: AnyFileRoute }","opts: {\n  uploadable: AnyFileRoute;\n  fePackage: string;\n  beAdapter: string;\n}","opts: {\n  json: typeof UploadActionPayload.Type;\n  uploadable: AnyFileRoute;\n}","opts: {\n  uploadable: AnyFileRoute;\n  fePackage: string;\n  beAdapter: string;\n  slug: string;\n}","err: HttpClientError.ResponseError","chunk: string","initDef: Partial<AnyFileRoute>","_def: AnyFileRoute","opts?: CreateBuilderOptions<TErrorShape>","input: FileRouterInputConfig","config?: TRouteOptions"],"mappings":"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","debugId":null}},
    {"offset": {"line": 930, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/uploadthing/next/index.js","sources":["file:///D:/840%20G3/7th%20semester/FSPM/Trackly/Trackly/node_modules/uploadthing/src/next.ts"],"sourcesContent":["import type { NextRequest } from \"next/server\";\nimport * as Effect from \"effect/Effect\";\n\nimport type { Json } from \"@uploadthing/shared\";\n\nimport { makeAdapterHandler } from \"./_internal/handler\";\nimport type { CreateBuilderOptions } from \"./_internal/upload-builder\";\nimport { createBuilder } from \"./_internal/upload-builder\";\nimport type { FileRouter, RouteHandlerOptions } from \"./types\";\n\nexport type { FileRouter };\nexport {\n  UTFiles,\n  /**\n   * This is an experimental feature.\n   * You need to be feature flagged on our backend to use this\n   */\n  UTRegion as experimental_UTRegion,\n} from \"./_internal/types\";\n\ntype AdapterArgs = {\n  req: NextRequest;\n};\n\nexport const createUploadthing = <TErrorShape extends Json>(\n  opts?: CreateBuilderOptions<TErrorShape>,\n) => createBuilder<AdapterArgs, TErrorShape>(opts);\n\nexport const createRouteHandler = <TRouter extends FileRouter>(\n  opts: RouteHandlerOptions<TRouter>,\n) => {\n  const handler = makeAdapterHandler<[NextRequest], AdapterArgs>(\n    (req) => Effect.succeed({ req }),\n    (req) => Effect.succeed(req),\n    opts,\n    \"nextjs-app\",\n  );\n  return { POST: handler, GET: handler };\n};\n"],"names":["opts?: CreateBuilderOptions<TErrorShape>","opts: RouteHandlerOptions<TRouter>"],"mappings":";;;;;;;;;;;;;;AAwBA,MAAa,oBAAoB,CAC/BA,WACG,uLAAA,EAAwC,KAAK;AAElD,MAAa,qBAAqB,CAChCC,SACG;IACH,MAAM,cAAU,4LAAA,EACd,CAAC,MAAQ,OAAO,oLAAA,CAAQ;YAAE;QAAK,EAAC,EAChC,CAAC,MAAQ,OAAO,oLAAA,CAAQ,IAAI,EAC5B,MACA,aACD;IACD,OAAO;QAAE,MAAM;QAAS,KAAK;IAAS;AACvC","debugId":null}}]
}