{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/uploadthing/node_modules/effect/dist/esm/internal/sink.js","sources":["file:///D:/840%20G3/7th%20semester/FSPM/Trackly/Trackly/node_modules/uploadthing/node_modules/effect/src/internal/sink.ts"],"sourcesContent":["import * as Arr from \"../Array.js\"\nimport * as Cause from \"../Cause.js\"\nimport type * as Channel from \"../Channel.js\"\nimport * as Chunk from \"../Chunk.js\"\nimport * as Clock from \"../Clock.js\"\nimport type * as Context from \"../Context.js\"\nimport * as Duration from \"../Duration.js\"\nimport * as Effect from \"../Effect.js\"\nimport * as Either from \"../Either.js\"\nimport * as Exit from \"../Exit.js\"\nimport { constTrue, dual, identity, pipe } from \"../Function.js\"\nimport type { LazyArg } from \"../Function.js\"\nimport * as HashMap from \"../HashMap.js\"\nimport * as HashSet from \"../HashSet.js\"\nimport type * as MergeDecision from \"../MergeDecision.js\"\nimport * as Option from \"../Option.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport { hasProperty, type Predicate, type Refinement } from \"../Predicate.js\"\nimport * as PubSub from \"../PubSub.js\"\nimport * as Queue from \"../Queue.js\"\nimport * as Ref from \"../Ref.js\"\nimport * as Scope from \"../Scope.js\"\nimport type * as Sink from \"../Sink.js\"\nimport type * as Types from \"../Types.js\"\nimport * as channel from \"./channel.js\"\nimport * as mergeDecision from \"./channel/mergeDecision.js\"\nimport * as core from \"./core-stream.js\"\n\n/** @internal */\nexport const SinkTypeId: Sink.SinkTypeId = Symbol.for(\"effect/Sink\") as Sink.SinkTypeId\n\nconst sinkVariance = {\n  /* c8 ignore next */\n  _A: (_: never) => _,\n  /* c8 ignore next */\n  _In: (_: unknown) => _,\n  /* c8 ignore next */\n  _L: (_: never) => _,\n  /* c8 ignore next */\n  _E: (_: never) => _,\n  /* c8 ignore next */\n  _R: (_: never) => _\n}\n\n/** @internal */\nexport class SinkImpl<out A, in In = unknown, out L = never, out E = never, out R = never>\n  implements Sink.Sink<A, In, L, E, R>\n{\n  readonly [SinkTypeId] = sinkVariance\n  constructor(\n    readonly channel: Channel.Channel<Chunk.Chunk<L>, Chunk.Chunk<In>, E, never, A, unknown, R>\n  ) {\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const isSink = (u: unknown): u is Sink.Sink<unknown, unknown, unknown, unknown, unknown> =>\n  hasProperty(u, SinkTypeId)\n\n/** @internal */\nexport const suspend = <A, In, L, E, R>(evaluate: LazyArg<Sink.Sink<A, In, L, E, R>>): Sink.Sink<A, In, L, E, R> =>\n  new SinkImpl(core.suspend(() => toChannel(evaluate())))\n\n/** @internal */\nexport const as = dual<\n  <A2>(a: A2) => <A, In, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A2, In, L, E, R>,\n  <A, In, L, E, R, A2>(self: Sink.Sink<A, In, L, E, R>, a: A2) => Sink.Sink<A2, In, L, E, R>\n>(\n  2,\n  (self, a) => pipe(self, map(() => a))\n)\n\n/** @internal */\nexport const collectAll = <In>(): Sink.Sink<Chunk.Chunk<In>, In> => new SinkImpl(collectAllLoop(Chunk.empty()))\n\n/** @internal */\nconst collectAllLoop = <In>(\n  acc: Chunk.Chunk<In>\n): Channel.Channel<never, Chunk.Chunk<In>, never, never, Chunk.Chunk<In>, unknown> =>\n  core.readWithCause({\n    onInput: (chunk: Chunk.Chunk<In>) => collectAllLoop(pipe(acc, Chunk.appendAll(chunk))),\n    onFailure: core.failCause,\n    onDone: () => core.succeed(acc)\n  })\n\n/** @internal */\nexport const collectAllN = <In>(n: number): Sink.Sink<Chunk.Chunk<In>, In, In> =>\n  suspend(() => fromChannel(collectAllNLoop(n, Chunk.empty())))\n\n/** @internal */\nconst collectAllNLoop = <In>(\n  n: number,\n  acc: Chunk.Chunk<In>\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, never, never, Chunk.Chunk<In>, unknown> =>\n  core.readWithCause({\n    onInput: (chunk: Chunk.Chunk<In>) => {\n      const [collected, leftovers] = Chunk.splitAt(chunk, n)\n      if (collected.length < n) {\n        return collectAllNLoop(n - collected.length, Chunk.appendAll(acc, collected))\n      }\n      if (Chunk.isEmpty(leftovers)) {\n        return core.succeed(Chunk.appendAll(acc, collected))\n      }\n      return core.flatMap(core.write(leftovers), () => core.succeed(Chunk.appendAll(acc, collected)))\n    },\n    onFailure: core.failCause,\n    onDone: () => core.succeed(acc)\n  })\n\n/** @internal */\nexport const collectAllFrom = <A, In, L extends In, E, R>(\n  self: Sink.Sink<A, In, L, E, R>\n): Sink.Sink<Chunk.Chunk<A>, In, L, E, R> =>\n  collectAllWhileWith(self, {\n    initial: Chunk.empty<A>(),\n    while: constTrue,\n    body: (chunk, a) => pipe(chunk, Chunk.append(a))\n  })\n\n/** @internal */\nexport const collectAllToMap = <In, K>(\n  key: (input: In) => K,\n  merge: (x: In, y: In) => In\n): Sink.Sink<HashMap.HashMap<K, In>, In> => {\n  return foldLeftChunks(HashMap.empty<K, In>(), (map, chunk) =>\n    pipe(\n      chunk,\n      Chunk.reduce(map, (map, input) => {\n        const k: K = key(input)\n        const v: In = pipe(map, HashMap.has(k)) ?\n          merge(pipe(map, HashMap.unsafeGet(k)), input) :\n          input\n        return pipe(map, HashMap.set(k, v))\n      })\n    ))\n}\n\n/** @internal */\nexport const collectAllToMapN = <In, K>(\n  n: number,\n  key: (input: In) => K,\n  merge: (x: In, y: In) => In\n): Sink.Sink<HashMap.HashMap<K, In>, In, In> => {\n  return foldWeighted<HashMap.HashMap<K, In>, In>({\n    initial: HashMap.empty(),\n    maxCost: n,\n    cost: (acc, input) => pipe(acc, HashMap.has(key(input))) ? 0 : 1,\n    body: (acc, input) => {\n      const k: K = key(input)\n      const v: In = pipe(acc, HashMap.has(k)) ?\n        merge(pipe(acc, HashMap.unsafeGet(k)), input) :\n        input\n      return pipe(acc, HashMap.set(k, v))\n    }\n  })\n}\n\n/** @internal */\nexport const collectAllToSet = <In>(): Sink.Sink<HashSet.HashSet<In>, In> =>\n  foldLeftChunks<HashSet.HashSet<In>, In>(\n    HashSet.empty(),\n    (acc, chunk) => pipe(chunk, Chunk.reduce(acc, (acc, input) => pipe(acc, HashSet.add(input))))\n  )\n\n/** @internal */\nexport const collectAllToSetN = <In>(n: number): Sink.Sink<HashSet.HashSet<In>, In, In> =>\n  foldWeighted<HashSet.HashSet<In>, In>({\n    initial: HashSet.empty(),\n    maxCost: n,\n    cost: (acc, input) => HashSet.has(acc, input) ? 0 : 1,\n    body: (acc, input) => HashSet.add(acc, input)\n  })\n\n/** @internal */\nexport const collectAllUntil = <In>(p: Predicate<In>): Sink.Sink<Chunk.Chunk<In>, In, In> => {\n  return pipe(\n    fold<[Chunk.Chunk<In>, boolean], In>(\n      [Chunk.empty(), true],\n      (tuple) => tuple[1],\n      ([chunk, _], input) => [pipe(chunk, Chunk.append(input)), !p(input)]\n    ),\n    map((tuple) => tuple[0])\n  )\n}\n\n/** @internal */\nexport const collectAllUntilEffect = <In, E, R>(p: (input: In) => Effect.Effect<boolean, E, R>) => {\n  return pipe(\n    foldEffect<[Chunk.Chunk<In>, boolean], In, E, R>(\n      [Chunk.empty(), true],\n      (tuple) => tuple[1],\n      ([chunk, _], input) => pipe(p(input), Effect.map((bool) => [pipe(chunk, Chunk.append(input)), !bool]))\n    ),\n    map((tuple) => tuple[0])\n  )\n}\n\n/** @internal */\nexport const collectAllWhile: {\n  <In, Out extends In>(refinement: Refinement<In, Out>): Sink.Sink<Chunk.Chunk<Out>, In, In>\n  <In>(predicate: Predicate<In>): Sink.Sink<Chunk.Chunk<In>, In, In>\n} = <In>(predicate: Predicate<In>): Sink.Sink<Chunk.Chunk<In>, In, In> =>\n  fromChannel(collectAllWhileReader(predicate, Chunk.empty()))\n\n/** @internal */\nconst collectAllWhileReader = <In>(\n  predicate: Predicate<In>,\n  done: Chunk.Chunk<In>\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, never, never, Chunk.Chunk<In>, unknown> =>\n  core.readWith({\n    onInput: (input: Chunk.Chunk<In>) => {\n      const [collected, leftovers] = pipe(Chunk.toReadonlyArray(input), Arr.span(predicate))\n      if (leftovers.length === 0) {\n        return collectAllWhileReader(\n          predicate,\n          pipe(done, Chunk.appendAll(Chunk.unsafeFromArray(collected)))\n        )\n      }\n      return pipe(\n        core.write(Chunk.unsafeFromArray(leftovers)),\n        channel.zipRight(core.succeed(pipe(done, Chunk.appendAll(Chunk.unsafeFromArray(collected)))))\n      )\n    },\n    onFailure: core.fail,\n    onDone: () => core.succeed(done)\n  })\n\n/** @internal */\nexport const collectAllWhileEffect = <In, E, R>(\n  predicate: (input: In) => Effect.Effect<boolean, E, R>\n): Sink.Sink<Chunk.Chunk<In>, In, In, E, R> => fromChannel(collectAllWhileEffectReader(predicate, Chunk.empty()))\n\n/** @internal */\nconst collectAllWhileEffectReader = <In, R, E>(\n  predicate: (input: In) => Effect.Effect<boolean, E, R>,\n  done: Chunk.Chunk<In>\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, E, never, Chunk.Chunk<In>, unknown, R> =>\n  core.readWith({\n    onInput: (input: Chunk.Chunk<In>) =>\n      pipe(\n        core.fromEffect(pipe(input, Effect.takeWhile(predicate), Effect.map(Chunk.unsafeFromArray))),\n        core.flatMap((collected) => {\n          const leftovers = pipe(input, Chunk.drop(collected.length))\n          if (Chunk.isEmpty(leftovers)) {\n            return collectAllWhileEffectReader(predicate, pipe(done, Chunk.appendAll(collected)))\n          }\n          return pipe(core.write(leftovers), channel.zipRight(core.succeed(pipe(done, Chunk.appendAll(collected)))))\n        })\n      ),\n    onFailure: core.fail,\n    onDone: () => core.succeed(done)\n  })\n\n/** @internal */\nexport const collectAllWhileWith: {\n  <A, S>(\n    options: {\n      readonly initial: S\n      readonly while: Predicate<A>\n      readonly body: (s: S, a: A) => S\n    }\n  ): <In, L extends In, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<S, In, L, E, R>\n  <A, In, L extends In, E, R, S>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly initial: S\n      readonly while: Predicate<A>\n      readonly body: (s: S, a: A) => S\n    }\n  ): Sink.Sink<S, In, L, E, R>\n} = dual(\n  2,\n  <A, In, L extends In, E, R, S>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly initial: S\n      readonly while: Predicate<A>\n      readonly body: (s: S, a: A) => S\n    }\n  ): Sink.Sink<S, In, L, E, R> => {\n    const refs = pipe(\n      Ref.make(Chunk.empty<In>()),\n      Effect.zip(Ref.make(false))\n    )\n    const newChannel = pipe(\n      core.fromEffect(refs),\n      core.flatMap(([leftoversRef, upstreamDoneRef]) => {\n        const upstreamMarker: Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, never, never, unknown, unknown> = core\n          .readWith({\n            onInput: (input) => pipe(core.write(input), core.flatMap(() => upstreamMarker)),\n            onFailure: core.fail,\n            onDone: (done) => pipe(core.fromEffect(Ref.set(upstreamDoneRef, true)), channel.as(done))\n          })\n        return pipe(\n          upstreamMarker,\n          core.pipeTo(channel.bufferChunk(leftoversRef)),\n          core.pipeTo(\n            collectAllWhileWithLoop(self, leftoversRef, upstreamDoneRef, options.initial, options.while, options.body)\n          )\n        )\n      })\n    )\n    return new SinkImpl(newChannel)\n  }\n)\n\nconst collectAllWhileWithLoop = <Z, In, L extends In, E, R, S>(\n  self: Sink.Sink<Z, In, L, E, R>,\n  leftoversRef: Ref.Ref<Chunk.Chunk<In>>,\n  upstreamDoneRef: Ref.Ref<boolean>,\n  currentResult: S,\n  p: Predicate<Z>,\n  f: (s: S, z: Z) => S\n): Channel.Channel<Chunk.Chunk<L>, Chunk.Chunk<In>, E, never, S, unknown, R> => {\n  return pipe(\n    toChannel(self),\n    channel.doneCollect,\n    channel.foldChannel({\n      onFailure: core.fail,\n      onSuccess: ([leftovers, doneValue]) =>\n        p(doneValue)\n          ? pipe(\n            core.fromEffect(\n              Ref.set(leftoversRef, Chunk.flatten(leftovers as Chunk.Chunk<Chunk.Chunk<In>>))\n            ),\n            core.flatMap(() =>\n              pipe(\n                core.fromEffect(Ref.get(upstreamDoneRef)),\n                core.flatMap((upstreamDone) => {\n                  const accumulatedResult = f(currentResult, doneValue)\n                  return upstreamDone\n                    ? pipe(core.write(Chunk.flatten(leftovers)), channel.as(accumulatedResult))\n                    : collectAllWhileWithLoop(self, leftoversRef, upstreamDoneRef, accumulatedResult, p, f)\n                })\n              )\n            )\n          )\n          : pipe(core.write(Chunk.flatten(leftovers)), channel.as(currentResult))\n    })\n  )\n}\n\n/** @internal */\nexport const collectLeftover = <A, In, L, E, R>(\n  self: Sink.Sink<A, In, L, E, R>\n): Sink.Sink<[A, Chunk.Chunk<L>], In, never, E, R> =>\n  new SinkImpl(pipe(core.collectElements(toChannel(self)), channel.map(([chunks, z]) => [z, Chunk.flatten(chunks)])))\n\n/** @internal */\nexport const mapInput = dual<\n  <In0, In>(f: (input: In0) => In) => <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In0, L, E, R>,\n  <A, In, L, E, R, In0>(self: Sink.Sink<A, In, L, E, R>, f: (input: In0) => In) => Sink.Sink<A, In0, L, E, R>\n>(\n  2,\n  <A, In, L, E, R, In0>(self: Sink.Sink<A, In, L, E, R>, f: (input: In0) => In): Sink.Sink<A, In0, L, E, R> =>\n    pipe(self, mapInputChunks(Chunk.map(f)))\n)\n\n/** @internal */\nexport const mapInputEffect = dual<\n  <In0, In, E2, R2>(\n    f: (input: In0) => Effect.Effect<In, E2, R2>\n  ) => <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In0, L, E2 | E, R2 | R>,\n  <A, In, L, E, R, In0, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (input: In0) => Effect.Effect<In, E2, R2>\n  ) => Sink.Sink<A, In0, L, E2 | E, R2 | R>\n>(\n  2,\n  <A, In, L, E, R, In0, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (input: In0) => Effect.Effect<In, E2, R2>\n  ): Sink.Sink<A, In0, L, E | E2, R | R2> =>\n    mapInputChunksEffect(\n      self,\n      (chunk) =>\n        Effect.map(\n          Effect.forEach(chunk, (v) => f(v)),\n          Chunk.unsafeFromArray\n        )\n    )\n)\n\n/** @internal */\nexport const mapInputChunks = dual<\n  <In0, In>(\n    f: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>\n  ) => <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In0, L, E, R>,\n  <A, In, L, E, R, In0>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>\n  ) => Sink.Sink<A, In0, L, E, R>\n>(\n  2,\n  <A, In, L, E, R, In0>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>\n  ): Sink.Sink<A, In0, L, E, R> => {\n    const loop: Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In0>, never, never, unknown, unknown, R> = core.readWith({\n      onInput: (chunk) => pipe(core.write(f(chunk)), core.flatMap(() => loop)),\n      onFailure: core.fail,\n      onDone: core.succeed\n    })\n    return new SinkImpl(pipe(loop, core.pipeTo(toChannel(self))))\n  }\n)\n\n/** @internal */\nexport const mapInputChunksEffect = dual<\n  <In0, In, E2, R2>(\n    f: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>\n  ) => <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In0, L, E2 | E, R2 | R>,\n  <A, In, L, E, R, In0, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>\n  ) => Sink.Sink<A, In0, L, E2 | E, R2 | R>\n>(\n  2,\n  <A, In, L, E, R, In0, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>\n  ): Sink.Sink<A, In0, L, E | E2, R | R2> => {\n    const loop: Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In0>, E2, never, unknown, unknown, R | R2> = core\n      .readWith({\n        onInput: (chunk) => pipe(core.fromEffect(f(chunk)), core.flatMap(core.write), core.flatMap(() => loop)),\n        onFailure: core.fail,\n        onDone: core.succeed\n      })\n    return new SinkImpl(pipe(loop, channel.pipeToOrFail(toChannel(self))))\n  }\n)\n\n/** @internal */\nexport const die = (defect: unknown): Sink.Sink<never, unknown> => failCause(Cause.die(defect))\n\n/** @internal */\nexport const dieMessage = (message: string): Sink.Sink<never, unknown> =>\n  failCause(Cause.die(new Cause.RuntimeException(message)))\n\n/** @internal */\nexport const dieSync = (evaluate: LazyArg<unknown>): Sink.Sink<never, unknown> =>\n  failCauseSync(() => Cause.die(evaluate()))\n\n/** @internal */\nexport const dimap = dual<\n  <In0, In, A, A2>(\n    options: {\n      readonly onInput: (input: In0) => In\n      readonly onDone: (a: A) => A2\n    }\n  ) => <L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A2, In0, L, E, R>,\n  <A, In, L, E, R, In0, A2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly onInput: (input: In0) => In\n      readonly onDone: (a: A) => A2\n    }\n  ) => Sink.Sink<A2, In0, L, E, R>\n>(\n  2,\n  <A, In, L, E, R, In0, A2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly onInput: (input: In0) => In\n      readonly onDone: (a: A) => A2\n    }\n  ): Sink.Sink<A2, In0, L, E, R> => map(mapInput(self, options.onInput), options.onDone)\n)\n\n/** @internal */\nexport const dimapEffect = dual<\n  <In0, In, E2, R2, A, A2, E3, R3>(\n    options: {\n      readonly onInput: (input: In0) => Effect.Effect<In, E2, R2>\n      readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>\n    }\n  ) => <L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A2, In0, L, E2 | E3 | E, R2 | R3 | R>,\n  <A, In, L, E, R, In0, E2, R2, A2, E3, R3>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly onInput: (input: In0) => Effect.Effect<In, E2, R2>\n      readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>\n    }\n  ) => Sink.Sink<A2, In0, L, E2 | E3 | E, R2 | R3 | R>\n>(\n  2,\n  (self, options) =>\n    mapEffect(\n      mapInputEffect(self, options.onInput),\n      options.onDone\n    )\n)\n\n/** @internal */\nexport const dimapChunks = dual<\n  <In0, In, A, A2>(\n    options: {\n      readonly onInput: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>\n      readonly onDone: (a: A) => A2\n    }\n  ) => <L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A2, In0, L, E, R>,\n  <A, In, L, E, R, In0, A2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly onInput: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>\n      readonly onDone: (a: A) => A2\n    }\n  ) => Sink.Sink<A2, In0, L, E, R>\n>(\n  2,\n  (self, options) =>\n    map(\n      mapInputChunks(self, options.onInput),\n      options.onDone\n    )\n)\n\n/** @internal */\nexport const dimapChunksEffect = dual<\n  <In0, In, E2, R2, A, A2, E3, R3>(\n    options: {\n      readonly onInput: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>\n      readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>\n    }\n  ) => <L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A2, In0, L, E2 | E3 | E, R2 | R3 | R>,\n  <A, In, L, E, R, In0, E2, R2, A2, E3, R3>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly onInput: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>\n      readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>\n    }\n  ) => Sink.Sink<A2, In0, L, E2 | E3 | E, R2 | R3 | R>\n>(\n  2,\n  (self, options) => mapEffect(mapInputChunksEffect(self, options.onInput), options.onDone)\n)\n\n/** @internal */\nexport const drain: Sink.Sink<void, unknown> = new SinkImpl(\n  channel.drain(channel.identityChannel())\n)\n\n/** @internal */\nexport const drop = <In>(n: number): Sink.Sink<unknown, In, In> => suspend(() => new SinkImpl(dropLoop(n)))\n\n/** @internal */\nconst dropLoop = <In>(\n  n: number\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, never, never, unknown, unknown> =>\n  core.readWith({\n    onInput: (input: Chunk.Chunk<In>) => {\n      const dropped = pipe(input, Chunk.drop(n))\n      const leftover = Math.max(n - input.length, 0)\n      const more = Chunk.isEmpty(input) || leftover > 0\n      if (more) {\n        return dropLoop(leftover)\n      }\n      return pipe(\n        core.write(dropped),\n        channel.zipRight(channel.identityChannel<Chunk.Chunk<In>, never, unknown>())\n      )\n    },\n    onFailure: core.fail,\n    onDone: () => core.void\n  })\n\n/** @internal */\nexport const dropUntil = <In>(predicate: Predicate<In>): Sink.Sink<unknown, In, In> =>\n  new SinkImpl(\n    pipe(toChannel(dropWhile((input: In) => !predicate(input))), channel.pipeToOrFail(toChannel(drop<In>(1))))\n  )\n\n/** @internal */\nexport const dropUntilEffect = <In, E, R>(\n  predicate: (input: In) => Effect.Effect<boolean, E, R>\n): Sink.Sink<unknown, In, In, E, R> => suspend(() => new SinkImpl(dropUntilEffectReader(predicate)))\n\n/** @internal */\nconst dropUntilEffectReader = <In, R, E>(\n  predicate: (input: In) => Effect.Effect<boolean, E, R>\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, E, E, unknown, unknown, R> =>\n  core.readWith({\n    onInput: (input: Chunk.Chunk<In>) =>\n      pipe(\n        input,\n        Effect.dropUntil(predicate),\n        Effect.map((leftover) => {\n          const more = leftover.length === 0\n          return more ?\n            dropUntilEffectReader(predicate) :\n            pipe(\n              core.write(Chunk.unsafeFromArray(leftover)),\n              channel.zipRight(channel.identityChannel<Chunk.Chunk<In>, E, unknown>())\n            )\n        }),\n        channel.unwrap\n      ),\n    onFailure: core.fail,\n    onDone: () => core.void\n  })\n\n/** @internal */\nexport const dropWhile = <In>(predicate: Predicate<In>): Sink.Sink<unknown, In, In> =>\n  new SinkImpl(dropWhileReader(predicate))\n\n/** @internal */\nconst dropWhileReader = <In>(\n  predicate: Predicate<In>\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, never, never, unknown, unknown> =>\n  core.readWith({\n    onInput: (input: Chunk.Chunk<In>) => {\n      const out = pipe(input, Chunk.dropWhile(predicate))\n      if (Chunk.isEmpty(out)) {\n        return dropWhileReader(predicate)\n      }\n      return pipe(core.write(out), channel.zipRight(channel.identityChannel<Chunk.Chunk<In>, never, unknown>()))\n    },\n    onFailure: core.fail,\n    onDone: core.succeedNow\n  })\n\n/** @internal */\nexport const dropWhileEffect = <In, E, R>(\n  predicate: (input: In) => Effect.Effect<boolean, E, R>\n): Sink.Sink<unknown, In, In, E, R> => suspend(() => new SinkImpl(dropWhileEffectReader(predicate)))\n\n/** @internal */\nconst dropWhileEffectReader = <In, R, E>(\n  predicate: (input: In) => Effect.Effect<boolean, E, R>\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, E, E, unknown, unknown, R> =>\n  core.readWith({\n    onInput: (input: Chunk.Chunk<In>) =>\n      pipe(\n        input,\n        Effect.dropWhile(predicate),\n        Effect.map((leftover) => {\n          const more = leftover.length === 0\n          return more ?\n            dropWhileEffectReader(predicate) :\n            pipe(\n              core.write(Chunk.unsafeFromArray(leftover)),\n              channel.zipRight(channel.identityChannel<Chunk.Chunk<In>, E, unknown>())\n            )\n        }),\n        channel.unwrap\n      ),\n    onFailure: core.fail,\n    onDone: () => core.void\n  })\n\n/** @internal */\nexport const ensuring = dual<\n  <X, R2>(\n    finalizer: Effect.Effect<X, never, R2>\n  ) => <A, In, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In, L, E, R2 | R>,\n  <A, In, L, E, R, X, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    finalizer: Effect.Effect<X, never, R2>\n  ) => Sink.Sink<A, In, L, E, R2 | R>\n>(\n  2,\n  (self, finalizer) => new SinkImpl(pipe(self, toChannel, channel.ensuring(finalizer)))\n)\n\n/** @internal */\nexport const ensuringWith = dual<\n  <A, E, X, R2>(\n    finalizer: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>\n  ) => <In, L, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In, L, E, R2 | R>,\n  <A, In, L, E, R, X, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    finalizer: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>\n  ) => Sink.Sink<A, In, L, E, R2 | R>\n>(\n  2,\n  (self, finalizer) => new SinkImpl(pipe(self, toChannel, core.ensuringWith(finalizer)))\n)\n\n/** @internal */\nexport const context = <R>(): Sink.Sink<Context.Context<R>, unknown, never, never, R> => fromEffect(Effect.context<R>())\n\n/** @internal */\nexport const contextWith = <R, Z>(\n  f: (context: Context.Context<R>) => Z\n): Sink.Sink<Z, unknown, never, never, R> => pipe(context<R>(), map(f))\n\n/** @internal */\nexport const contextWithEffect = <R0, A, E, R>(\n  f: (context: Context.Context<R0>) => Effect.Effect<A, E, R>\n): Sink.Sink<A, unknown, never, E, R0 | R> => pipe(context<R0>(), mapEffect(f))\n\n/** @internal */\nexport const contextWithSink = <R0, A, In, L, E, R>(\n  f: (context: Context.Context<R0>) => Sink.Sink<A, In, L, E, R>\n): Sink.Sink<A, In, L, E, R0 | R> =>\n  new SinkImpl(channel.unwrap(Effect.contextWith((context) => toChannel(f(context)))))\n\n/** @internal */\nexport const every = <In>(predicate: Predicate<In>): Sink.Sink<boolean, In, In> =>\n  fold(true, identity, (acc, input) => acc && predicate(input))\n\n/** @internal */\nexport const fail = <E>(e: E): Sink.Sink<never, unknown, never, E> => new SinkImpl(core.fail(e))\n\n/** @internal */\nexport const failSync = <E>(evaluate: LazyArg<E>): Sink.Sink<never, unknown, never, E> =>\n  new SinkImpl(core.failSync(evaluate))\n\n/** @internal */\nexport const failCause = <E>(cause: Cause.Cause<E>): Sink.Sink<never, unknown, never, E> =>\n  new SinkImpl(core.failCause(cause))\n\n/** @internal */\nexport const failCauseSync = <E>(evaluate: LazyArg<Cause.Cause<E>>): Sink.Sink<never, unknown, never, E> =>\n  new SinkImpl(core.failCauseSync(evaluate))\n\n/** @internal */\nexport const filterInput: {\n  <In, In1 extends In, In2 extends In1>(\n    f: Refinement<In1, In2>\n  ): <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In2, L, E, R>\n  <In, In1 extends In>(f: Predicate<In1>): <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In1, L, E, R>\n} = <In, In1 extends In>(f: Predicate<In1>) => {\n  return <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>): Sink.Sink<A, In1, L, E, R> =>\n    pipe(self, mapInputChunks(Chunk.filter(f)))\n}\n\n/** @internal */\nexport const filterInputEffect = dual<\n  <In, In1 extends In, E2, R2>(\n    f: (input: In1) => Effect.Effect<boolean, E2, R2>\n  ) => <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In1, L, E2 | E, R2 | R>,\n  <A, In, L, E, R, In1 extends In, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (input: In1) => Effect.Effect<boolean, E2, R2>\n  ) => Sink.Sink<A, In1, L, E2 | E, R2 | R>\n>(\n  2,\n  (self, f) =>\n    mapInputChunksEffect(\n      self,\n      (chunk) => Effect.map(Effect.filter(chunk, f), Chunk.unsafeFromArray)\n    )\n)\n\n/** @internal */\nexport const findEffect = dual<\n  <A, E2, R2>(\n    f: (a: A) => Effect.Effect<boolean, E2, R2>\n  ) => <In, L extends In, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<Option.Option<A>, In, L, E2 | E, R2 | R>,\n  <A, In, L extends In, E, R, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (a: A) => Effect.Effect<boolean, E2, R2>\n  ) => Sink.Sink<Option.Option<A>, In, L, E2 | E, R2 | R>\n>(\n  2,\n  <A, In, L extends In, E, R, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (a: A) => Effect.Effect<boolean, E2, R2>\n  ): Sink.Sink<Option.Option<A>, In, L, E2 | E, R2 | R> => {\n    const newChannel = pipe(\n      core.fromEffect(pipe(\n        Ref.make(Chunk.empty<In>()),\n        Effect.zip(Ref.make(false))\n      )),\n      core.flatMap(([leftoversRef, upstreamDoneRef]) => {\n        const upstreamMarker: Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, never, never, unknown, unknown> = core\n          .readWith({\n            onInput: (input) => pipe(core.write(input), core.flatMap(() => upstreamMarker)),\n            onFailure: core.fail,\n            onDone: (done) => pipe(core.fromEffect(Ref.set(upstreamDoneRef, true)), channel.as(done))\n          })\n        const loop: Channel.Channel<Chunk.Chunk<L>, Chunk.Chunk<In>, E | E2, never, Option.Option<A>, unknown, R | R2> =\n          channel.foldChannel(core.collectElements(toChannel(self)), {\n            onFailure: core.fail,\n            onSuccess: ([leftovers, doneValue]) =>\n              pipe(\n                core.fromEffect(f(doneValue)),\n                core.flatMap((satisfied) =>\n                  pipe(\n                    core.fromEffect(Ref.set(leftoversRef, Chunk.flatten(leftovers))),\n                    channel.zipRight(\n                      pipe(\n                        core.fromEffect(Ref.get(upstreamDoneRef)),\n                        core.flatMap((upstreamDone) => {\n                          if (satisfied) {\n                            return pipe(core.write(Chunk.flatten(leftovers)), channel.as(Option.some(doneValue)))\n                          }\n                          if (upstreamDone) {\n                            return pipe(core.write(Chunk.flatten(leftovers)), channel.as(Option.none()))\n                          }\n                          return loop\n                        })\n                      )\n                    )\n                  )\n                )\n              )\n          })\n        return pipe(upstreamMarker, core.pipeTo(channel.bufferChunk(leftoversRef)), core.pipeTo(loop))\n      })\n    )\n    return new SinkImpl(newChannel)\n  }\n)\n\n/** @internal */\nexport const fold = <S, In>(\n  s: S,\n  contFn: Predicate<S>,\n  f: (s: S, input: In) => S\n): Sink.Sink<S, In, In> => suspend(() => new SinkImpl(foldReader(s, contFn, f)))\n\n/** @internal */\nconst foldReader = <S, In>(\n  s: S,\n  contFn: Predicate<S>,\n  f: (z: S, input: In) => S\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, never, never, S, unknown> => {\n  if (!contFn(s)) {\n    return core.succeedNow(s)\n  }\n  return core.readWith({\n    onInput: (input: Chunk.Chunk<In>) => {\n      const [nextS, leftovers] = foldChunkSplit(s, input, contFn, f, 0, input.length)\n      if (Chunk.isNonEmpty(leftovers)) {\n        return pipe(core.write(leftovers), channel.as(nextS))\n      }\n      return foldReader(nextS, contFn, f)\n    },\n    onFailure: core.fail,\n    onDone: () => core.succeedNow(s)\n  })\n}\n\n/** @internal */\nconst foldChunkSplit = <S, In>(\n  s: S,\n  chunk: Chunk.Chunk<In>,\n  contFn: Predicate<S>,\n  f: (z: S, input: In) => S,\n  index: number,\n  length: number\n): [S, Chunk.Chunk<In>] => {\n  if (index === length) {\n    return [s, Chunk.empty()]\n  }\n  const s1 = f(s, pipe(chunk, Chunk.unsafeGet(index)))\n  if (contFn(s1)) {\n    return foldChunkSplit(s1, chunk, contFn, f, index + 1, length)\n  }\n  return [s1, pipe(chunk, Chunk.drop(index + 1))]\n}\n\n/** @internal */\nexport const foldSink = dual<\n  <E, A1, In, In1 extends In, L1, E1, R1, A, A2, In2 extends In, L2, E2, R2>(\n    options: {\n      readonly onFailure: (err: E) => Sink.Sink<A1, In1, L1, E1, R1>\n      readonly onSuccess: (a: A) => Sink.Sink<A2, In2, L2, E2, R2>\n    }\n  ) => <L, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A1 | A2, In1 & In2, L1 | L2, E1 | E2, R1 | R2 | R>,\n  <A, In, L, E, R, A1, In1 extends In, L1, E1, R1, A2, In2 extends In, L2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly onFailure: (err: E) => Sink.Sink<A1, In1, L1, E1, R1>\n      readonly onSuccess: (a: A) => Sink.Sink<A2, In2, L2, E2, R2>\n    }\n  ) => Sink.Sink<A1 | A2, In1 & In2, L1 | L2, E1 | E2, R1 | R2 | R>\n>(\n  2,\n  <A, In, L, E, R, A1, In1 extends In, L1, E1, R1, A2, In2 extends In, L2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly onFailure: (err: E) => Sink.Sink<A1, In1, L1, E1, R1>\n      readonly onSuccess: (z: A) => Sink.Sink<A2, In2, L2, E2, R2>\n    }\n  ): Sink.Sink<A1 | A2, In1 & In2, L1 | L2, E1 | E2, R | R1 | R2> => {\n    const newChannel: Channel.Channel<\n      Chunk.Chunk<L1 | L2>,\n      Chunk.Chunk<In1 & In2>,\n      E1 | E2,\n      never,\n      A1 | A2,\n      unknown,\n      R | R1 | R2\n    > = pipe(\n      toChannel(self),\n      core.collectElements,\n      channel.foldChannel({\n        onFailure: (error) => toChannel(options.onFailure(error)),\n        onSuccess: ([leftovers, z]) =>\n          core.suspend(() => {\n            const leftoversRef = {\n              ref: pipe(leftovers, Chunk.filter(Chunk.isNonEmpty)) as Chunk.Chunk<Chunk.Chunk<L1 | L2>>\n            }\n            const refReader = pipe(\n              core.sync(() => {\n                const ref = leftoversRef.ref\n                leftoversRef.ref = Chunk.empty()\n                return ref\n              }),\n              // This cast is safe because of the L1 >: L <: In1 bound. It follows that\n              // L <: In1 and therefore Chunk[L] can be safely cast to Chunk[In1].\n              core.flatMap((chunk) => channel.writeChunk(chunk as Chunk.Chunk<Chunk.Chunk<In1 & In2>>))\n            )\n            const passthrough = channel.identityChannel<Chunk.Chunk<In1 & In2>, never, unknown>()\n            const continuationSink = pipe(\n              refReader,\n              channel.zipRight(passthrough),\n              core.pipeTo(toChannel(options.onSuccess(z)))\n            )\n            return core.flatMap(\n              core.collectElements(continuationSink),\n              ([newLeftovers, z1]) =>\n                pipe(\n                  core.succeed(leftoversRef.ref),\n                  core.flatMap(channel.writeChunk),\n                  channel.zipRight(channel.writeChunk(newLeftovers)),\n                  channel.as(z1)\n                )\n            )\n          })\n      })\n    )\n    return new SinkImpl(newChannel)\n  }\n)\n\n/** @internal */\nexport const foldChunks = <S, In>(\n  s: S,\n  contFn: Predicate<S>,\n  f: (s: S, chunk: Chunk.Chunk<In>) => S\n): Sink.Sink<S, In> => suspend(() => new SinkImpl(foldChunksReader(s, contFn, f)))\n\n/** @internal */\nconst foldChunksReader = <S, In>(\n  s: S,\n  contFn: Predicate<S>,\n  f: (s: S, chunk: Chunk.Chunk<In>) => S\n): Channel.Channel<never, Chunk.Chunk<In>, never, never, S, unknown> => {\n  if (!contFn(s)) {\n    return core.succeedNow(s)\n  }\n  return core.readWith({\n    onInput: (input: Chunk.Chunk<In>) => foldChunksReader(f(s, input), contFn, f),\n    onFailure: core.fail,\n    onDone: () => core.succeedNow(s)\n  })\n}\n\n/** @internal */\nexport const foldChunksEffect = <S, In, E, R>(\n  s: S,\n  contFn: Predicate<S>,\n  f: (s: S, chunk: Chunk.Chunk<In>) => Effect.Effect<S, E, R>\n): Sink.Sink<S, In, In, E, R> => suspend(() => new SinkImpl(foldChunksEffectReader(s, contFn, f)))\n\n/** @internal */\nconst foldChunksEffectReader = <S, R, E, In>(\n  s: S,\n  contFn: Predicate<S>,\n  f: (s: S, chunk: Chunk.Chunk<In>) => Effect.Effect<S, E, R>\n): Channel.Channel<never, Chunk.Chunk<In>, E, E, S, unknown, R> => {\n  if (!contFn(s)) {\n    return core.succeedNow(s)\n  }\n  return core.readWith({\n    onInput: (input: Chunk.Chunk<In>) =>\n      pipe(\n        core.fromEffect(f(s, input)),\n        core.flatMap((s) => foldChunksEffectReader(s, contFn, f))\n      ),\n    onFailure: core.fail,\n    onDone: () => core.succeedNow(s)\n  })\n}\n\n/** @internal */\nexport const foldEffect = <S, In, E, R>(\n  s: S,\n  contFn: Predicate<S>,\n  f: (s: S, input: In) => Effect.Effect<S, E, R>\n): Sink.Sink<S, In, In, E, R> => suspend(() => new SinkImpl(foldEffectReader(s, contFn, f)))\n\n/** @internal */\nconst foldEffectReader = <S, In, R, E>(\n  s: S,\n  contFn: Predicate<S>,\n  f: (s: S, input: In) => Effect.Effect<S, E, R>\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, E, E, S, unknown, R> => {\n  if (!contFn(s)) {\n    return core.succeedNow(s)\n  }\n  return core.readWith({\n    onInput: (input: Chunk.Chunk<In>) =>\n      pipe(\n        core.fromEffect(foldChunkSplitEffect(s, input, contFn, f)),\n        core.flatMap(([nextS, leftovers]) =>\n          pipe(\n            leftovers,\n            Option.match({\n              onNone: () => foldEffectReader(nextS, contFn, f),\n              onSome: (leftover) => pipe(core.write(leftover), channel.as(nextS))\n            })\n          )\n        )\n      ),\n    onFailure: core.fail,\n    onDone: () => core.succeedNow(s)\n  })\n}\n\n/** @internal */\nconst foldChunkSplitEffect = <S, R, E, In>(\n  s: S,\n  chunk: Chunk.Chunk<In>,\n  contFn: Predicate<S>,\n  f: (s: S, input: In) => Effect.Effect<S, E, R>\n): Effect.Effect<[S, Option.Option<Chunk.Chunk<In>>], E, R> =>\n  foldChunkSplitEffectInternal(s, chunk, 0, chunk.length, contFn, f)\n\n/** @internal */\nconst foldChunkSplitEffectInternal = <S, R, E, In>(\n  s: S,\n  chunk: Chunk.Chunk<In>,\n  index: number,\n  length: number,\n  contFn: Predicate<S>,\n  f: (s: S, input: In) => Effect.Effect<S, E, R>\n): Effect.Effect<[S, Option.Option<Chunk.Chunk<In>>], E, R> => {\n  if (index === length) {\n    return Effect.succeed([s, Option.none()])\n  }\n  return pipe(\n    f(s, pipe(chunk, Chunk.unsafeGet(index))),\n    Effect.flatMap((s1) =>\n      contFn(s1) ?\n        foldChunkSplitEffectInternal(s1, chunk, index + 1, length, contFn, f) :\n        Effect.succeed([s1, Option.some(pipe(chunk, Chunk.drop(index + 1)))])\n    )\n  )\n}\n\n/** @internal */\nexport const foldLeft = <S, In>(s: S, f: (s: S, input: In) => S): Sink.Sink<S, In> =>\n  ignoreLeftover(fold(s, constTrue, f))\n\n/** @internal */\nexport const foldLeftChunks = <S, In>(\n  s: S,\n  f: (s: S, chunk: Chunk.Chunk<In>) => S\n): Sink.Sink<S, In> => foldChunks(s, constTrue, f)\n\n/** @internal */\nexport const foldLeftChunksEffect = <S, In, E, R>(\n  s: S,\n  f: (s: S, chunk: Chunk.Chunk<In>) => Effect.Effect<S, E, R>\n): Sink.Sink<S, In, never, E, R> => ignoreLeftover(foldChunksEffect(s, constTrue, f))\n\n/** @internal */\nexport const foldLeftEffect = <S, In, E, R>(\n  s: S,\n  f: (s: S, input: In) => Effect.Effect<S, E, R>\n): Sink.Sink<S, In, In, E, R> => foldEffect(s, constTrue, f)\n\n/** @internal */\nexport const foldUntil = <S, In>(s: S, max: number, f: (s: S, input: In) => S): Sink.Sink<S, In, In> =>\n  pipe(\n    fold<[S, number], In>(\n      [s, 0],\n      (tuple) => tuple[1] < max,\n      ([output, count], input) => [f(output, input), count + 1]\n    ),\n    map((tuple) => tuple[0])\n  )\n\n/** @internal */\nexport const foldUntilEffect = <S, In, E, R>(\n  s: S,\n  max: number,\n  f: (s: S, input: In) => Effect.Effect<S, E, R>\n): Sink.Sink<S, In, In, E, R> =>\n  pipe(\n    foldEffect(\n      [s, 0 as number] as const,\n      (tuple) => tuple[1] < max,\n      ([output, count], input: In) => pipe(f(output, input), Effect.map((s) => [s, count + 1] as const))\n    ),\n    map((tuple) => tuple[0])\n  )\n\n/** @internal */\nexport const foldWeighted = <S, In>(\n  options: {\n    readonly initial: S\n    readonly maxCost: number\n    readonly cost: (s: S, input: In) => number\n    readonly body: (s: S, input: In) => S\n  }\n): Sink.Sink<S, In, In> =>\n  foldWeightedDecompose({\n    ...options,\n    decompose: Chunk.of\n  })\n\n/** @internal */\nexport const foldWeightedDecompose = <S, In>(\n  options: {\n    readonly initial: S\n    readonly maxCost: number\n    readonly cost: (s: S, input: In) => number\n    readonly decompose: (input: In) => Chunk.Chunk<In>\n    readonly body: (s: S, input: In) => S\n  }\n): Sink.Sink<S, In, In> =>\n  suspend(() =>\n    new SinkImpl(\n      foldWeightedDecomposeLoop(\n        options.initial,\n        0,\n        false,\n        options.maxCost,\n        options.cost,\n        options.decompose,\n        options.body\n      )\n    )\n  )\n\n/** @internal */\nconst foldWeightedDecomposeLoop = <S, In>(\n  s: S,\n  cost: number,\n  dirty: boolean,\n  max: number,\n  costFn: (s: S, input: In) => number,\n  decompose: (input: In) => Chunk.Chunk<In>,\n  f: (s: S, input: In) => S\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, never, never, S, unknown> =>\n  core.readWith({\n    onInput: (input: Chunk.Chunk<In>) => {\n      const [nextS, nextCost, nextDirty, leftovers] = foldWeightedDecomposeFold(\n        input,\n        s,\n        cost,\n        dirty,\n        max,\n        costFn,\n        decompose,\n        f\n      )\n      if (Chunk.isNonEmpty(leftovers)) {\n        return pipe(core.write(leftovers), channel.zipRight(core.succeedNow(nextS)))\n      }\n      if (cost > max) {\n        return core.succeedNow(nextS)\n      }\n      return foldWeightedDecomposeLoop(nextS, nextCost, nextDirty, max, costFn, decompose, f)\n    },\n    onFailure: core.fail,\n    onDone: () => core.succeedNow(s)\n  })\n\n/** @internal */\nconst foldWeightedDecomposeFold = <In, S>(\n  input: Chunk.Chunk<In>,\n  s: S,\n  cost: number,\n  dirty: boolean,\n  max: number,\n  costFn: (s: S, input: In) => number,\n  decompose: (input: In) => Chunk.Chunk<In>,\n  f: (s: S, input: In) => S\n): [S, number, boolean, Chunk.Chunk<In>] => {\n  for (let index = 0; index < input.length; index++) {\n    const elem = Chunk.unsafeGet(input, index)\n    const prevCost = cost\n    cost = cost + costFn(s, elem)\n    if (cost <= max) {\n      s = f(s, elem)\n      dirty = true\n      continue\n    }\n    const decomposed = decompose(elem)\n    if (decomposed.length <= 1 && !dirty) {\n      // If `elem` cannot be decomposed, we need to cross the `max` threshold. To\n      // minimize \"injury\", we only allow this when we haven't added anything else\n      // to the aggregate (dirty = false).\n      return [f(s, elem), cost, true, Chunk.drop(input, index + 1)]\n    }\n    if (decomposed.length <= 1 && dirty) {\n      // If the state is dirty and `elem` cannot be decomposed, we stop folding\n      // and include `elem` in the leftovers.\n      return [s, prevCost, dirty, Chunk.drop(input, index)]\n    }\n    // `elem` got decomposed, so we will recurse with the decomposed elements pushed\n    // into the chunk we're processing and see if we can aggregate further.\n    input = Chunk.appendAll(decomposed, Chunk.drop(input, index + 1))\n    cost = prevCost\n    index = -1\n  }\n  return [s, cost, dirty, Chunk.empty<In>()]\n}\n\n/** @internal */\nexport const foldWeightedDecomposeEffect = <S, In, E, R, E2, R2, E3, R3>(\n  options: {\n    readonly initial: S\n    readonly maxCost: number\n    readonly cost: (s: S, input: In) => Effect.Effect<number, E, R>\n    readonly decompose: (input: In) => Effect.Effect<Chunk.Chunk<In>, E2, R2>\n    readonly body: (s: S, input: In) => Effect.Effect<S, E3, R3>\n  }\n): Sink.Sink<S, In, In, E | E2 | E3, R | R2 | R3> =>\n  suspend(() =>\n    new SinkImpl(\n      foldWeightedDecomposeEffectLoop(\n        options.initial,\n        options.maxCost,\n        options.cost,\n        options.decompose,\n        options.body,\n        0,\n        false\n      )\n    )\n  )\n\n/** @internal */\nexport const foldWeightedEffect = <S, In, E, R, E2, R2>(\n  options: {\n    readonly initial: S\n    readonly maxCost: number\n    readonly cost: (s: S, input: In) => Effect.Effect<number, E, R>\n    readonly body: (s: S, input: In) => Effect.Effect<S, E2, R2>\n  }\n): Sink.Sink<S, In, In, E | E2, R | R2> =>\n  foldWeightedDecomposeEffect({\n    ...options,\n    decompose: (input) => Effect.succeed(Chunk.of(input))\n  })\n\nconst foldWeightedDecomposeEffectLoop = <S, In, E, R, E2, R2, E3, R3>(\n  s: S,\n  max: number,\n  costFn: (s: S, input: In) => Effect.Effect<number, E, R>,\n  decompose: (input: In) => Effect.Effect<Chunk.Chunk<In>, E2, R2>,\n  f: (s: S, input: In) => Effect.Effect<S, E3, R3>,\n  cost: number,\n  dirty: boolean\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, E | E2 | E3, E | E2 | E3, S, unknown, R | R2 | R3> =>\n  core.readWith({\n    onInput: (input: Chunk.Chunk<In>) =>\n      pipe(\n        core.fromEffect(foldWeightedDecomposeEffectFold(s, max, costFn, decompose, f, input, dirty, cost, 0)),\n        core.flatMap(([nextS, nextCost, nextDirty, leftovers]) => {\n          if (Chunk.isNonEmpty(leftovers)) {\n            return pipe(core.write(leftovers), channel.zipRight(core.succeedNow(nextS)))\n          }\n          if (cost > max) {\n            return core.succeedNow(nextS)\n          }\n          return foldWeightedDecomposeEffectLoop(nextS, max, costFn, decompose, f, nextCost, nextDirty)\n        })\n      ),\n    onFailure: core.fail,\n    onDone: () => core.succeedNow(s)\n  })\n\n/** @internal */\nconst foldWeightedDecomposeEffectFold = <S, In, E, R, E2, R2, E3, R3>(\n  s: S,\n  max: number,\n  costFn: (s: S, input: In) => Effect.Effect<number, E, R>,\n  decompose: (input: In) => Effect.Effect<Chunk.Chunk<In>, E2, R2>,\n  f: (s: S, input: In) => Effect.Effect<S, E3, R3>,\n  input: Chunk.Chunk<In>,\n  dirty: boolean,\n  cost: number,\n  index: number\n): Effect.Effect<[S, number, boolean, Chunk.Chunk<In>], E | E2 | E3, R | R2 | R3> => {\n  if (index === input.length) {\n    return Effect.succeed([s, cost, dirty, Chunk.empty<In>()])\n  }\n  const elem = pipe(input, Chunk.unsafeGet(index))\n  return pipe(\n    costFn(s, elem),\n    Effect.map((newCost) => cost + newCost),\n    Effect.flatMap((total) => {\n      if (total <= max) {\n        return pipe(\n          f(s, elem),\n          Effect.flatMap((s) =>\n            foldWeightedDecomposeEffectFold(s, max, costFn, decompose, f, input, true, total, index + 1)\n          )\n        )\n      }\n      return pipe(\n        decompose(elem),\n        Effect.flatMap((decomposed) => {\n          if (decomposed.length <= 1 && !dirty) {\n            // If `elem` cannot be decomposed, we need to cross the `max` threshold. To\n            // minimize \"injury\", we only allow this when we haven't added anything else\n            // to the aggregate (dirty = false).\n            return pipe(\n              f(s, elem),\n              Effect.map((s) => [s, total, true, pipe(input, Chunk.drop(index + 1))])\n            )\n          }\n          if (decomposed.length <= 1 && dirty) {\n            // If the state is dirty and `elem` cannot be decomposed, we stop folding\n            // and include `elem` in th leftovers.\n            return Effect.succeed([s, cost, dirty, pipe(input, Chunk.drop(index))])\n          }\n          // `elem` got decomposed, so we will recurse with the decomposed elements pushed\n          // into the chunk we're processing and see if we can aggregate further.\n          const next = pipe(decomposed, Chunk.appendAll(pipe(input, Chunk.drop(index + 1))))\n          return foldWeightedDecomposeEffectFold(s, max, costFn, decompose, f, next, dirty, cost, 0)\n        })\n      )\n    })\n  )\n}\n\n/** @internal */\nexport const flatMap = dual<\n  <A, A1, In, In1 extends In, L1, E1, R1>(\n    f: (a: A) => Sink.Sink<A1, In1, L1, E1, R1>\n  ) => <L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A1, In & In1, L | L1, E1 | E, R1 | R>,\n  <A, In, L, E, R, A1, In1 extends In, L1, E1, R1>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (a: A) => Sink.Sink<A1, In1, L1, E1, R1>\n  ) => Sink.Sink<A1, In & In1, L | L1, E1 | E, R1 | R>\n>(\n  2,\n  (self, f) => foldSink(self, { onFailure: fail, onSuccess: f })\n)\n\n/** @internal */\nexport const forEach = <In, X, E, R>(f: (input: In) => Effect.Effect<X, E, R>): Sink.Sink<void, In, never, E, R> => {\n  const process: Channel.Channel<never, Chunk.Chunk<In>, E, E, void, unknown, R> = core.readWithCause({\n    onInput: (input: Chunk.Chunk<In>) =>\n      pipe(core.fromEffect(Effect.forEach(input, (v) => f(v), { discard: true })), core.flatMap(() => process)),\n    onFailure: core.failCause,\n    onDone: () => core.void\n  })\n  return new SinkImpl(process)\n}\n\n/** @internal */\nexport const forEachChunk = <In, X, E, R>(\n  f: (input: Chunk.Chunk<In>) => Effect.Effect<X, E, R>\n): Sink.Sink<void, In, never, E, R> => {\n  const process: Channel.Channel<never, Chunk.Chunk<In>, E, E, void, unknown, R> = core.readWithCause({\n    onInput: (input: Chunk.Chunk<In>) => pipe(core.fromEffect(f(input)), core.flatMap(() => process)),\n    onFailure: core.failCause,\n    onDone: () => core.void\n  })\n  return new SinkImpl(process)\n}\n\n/** @internal */\nexport const forEachWhile = <In, E, R>(\n  f: (input: In) => Effect.Effect<boolean, E, R>\n): Sink.Sink<void, In, In, E, R> => {\n  const process: Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, E, E, void, unknown, R> = core.readWithCause({\n    onInput: (input: Chunk.Chunk<In>) => forEachWhileReader(f, input, 0, input.length, process),\n    onFailure: core.failCause,\n    onDone: () => core.void\n  })\n  return new SinkImpl(process)\n}\n\n/** @internal */\nconst forEachWhileReader = <In, E, R>(\n  f: (input: In) => Effect.Effect<boolean, E, R>,\n  input: Chunk.Chunk<In>,\n  index: number,\n  length: number,\n  cont: Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, E, E, void, unknown, R>\n): Channel.Channel<Chunk.Chunk<In>, Chunk.Chunk<In>, E, E, void, unknown, R> => {\n  if (index === length) {\n    return cont\n  }\n  return pipe(\n    core.fromEffect(f(pipe(input, Chunk.unsafeGet(index)))),\n    core.flatMap((bool) =>\n      bool ?\n        forEachWhileReader(f, input, index + 1, length, cont) :\n        core.write(pipe(input, Chunk.drop(index)))\n    ),\n    channel.catchAll((error) => pipe(core.write(pipe(input, Chunk.drop(index))), channel.zipRight(core.fail(error))))\n  )\n}\n\n/** @internal */\nexport const forEachChunkWhile = <In, E, R>(\n  f: (input: Chunk.Chunk<In>) => Effect.Effect<boolean, E, R>\n): Sink.Sink<void, In, In, E, R> => {\n  const reader: Channel.Channel<never, Chunk.Chunk<In>, E, E, void, unknown, R> = core.readWith({\n    onInput: (input: Chunk.Chunk<In>) =>\n      pipe(\n        core.fromEffect(f(input)),\n        core.flatMap((cont) => cont ? reader : core.void)\n      ),\n    onFailure: core.fail,\n    onDone: () => core.void\n  })\n  return new SinkImpl(reader)\n}\n\n/** @internal */\nexport const fromChannel = <L, In, E, A, R>(\n  channel: Channel.Channel<Chunk.Chunk<L>, Chunk.Chunk<In>, E, never, A, unknown, R>\n): Sink.Sink<A, In, L, E, R> => new SinkImpl(channel)\n\n/** @internal */\nexport const fromEffect = <A, E, R>(effect: Effect.Effect<A, E, R>): Sink.Sink<A, unknown, never, E, R> =>\n  new SinkImpl(core.fromEffect(effect))\n\n/** @internal */\nexport const fromPubSub = <In>(\n  pubsub: PubSub.PubSub<In>,\n  options?: {\n    readonly shutdown?: boolean | undefined\n  }\n): Sink.Sink<void, In> => fromQueue(pubsub, options)\n\n/** @internal */\nexport const fromPush = <In, L0, R0, L, R>(\n  push: Effect.Effect<\n    (_: Option.Option<Chunk.Chunk<In>>) => Effect.Effect<void, readonly [Either.Either<R0, L0>, Chunk.Chunk<L>], R>,\n    never,\n    R\n  >\n): Sink.Sink<R0, In, L, L0, Exclude<R, Scope.Scope>> =>\n  new SinkImpl(channel.unwrapScoped(pipe(push, Effect.map(fromPushPull))))\n\nconst fromPushPull = <In, Z, E, L, R>(\n  push: (\n    option: Option.Option<Chunk.Chunk<In>>\n  ) => Effect.Effect<void, readonly [Either.Either<Z, E>, Chunk.Chunk<L>], R>\n): Channel.Channel<Chunk.Chunk<L>, Chunk.Chunk<In>, E, never, Z, unknown, R> =>\n  core.readWith({\n    onInput: (input: Chunk.Chunk<In>) =>\n      channel.foldChannel(core.fromEffect(push(Option.some(input))), {\n        onFailure: ([either, leftovers]) =>\n          Either.match(either, {\n            onLeft: (error) => pipe(core.write(leftovers), channel.zipRight(core.fail(error))),\n            onRight: (z) => pipe(core.write(leftovers), channel.zipRight(core.succeedNow(z)))\n          }),\n        onSuccess: () => fromPushPull(push)\n      }),\n    onFailure: core.fail,\n    onDone: () =>\n      channel.foldChannel(core.fromEffect(push(Option.none())), {\n        onFailure: ([either, leftovers]) =>\n          Either.match(either, {\n            onLeft: (error) => pipe(core.write(leftovers), channel.zipRight(core.fail(error))),\n            onRight: (z) => pipe(core.write(leftovers), channel.zipRight(core.succeedNow(z)))\n          }),\n        onSuccess: () =>\n          core.fromEffect(\n            Effect.dieMessage(\n              \"BUG: Sink.fromPush - please report an issue at https://github.com/Effect-TS/effect/issues\"\n            )\n          )\n      })\n  })\n\n/** @internal */\nexport const fromQueue = <In>(\n  queue: Queue.Enqueue<In>,\n  options?: {\n    readonly shutdown?: boolean | undefined\n  }\n): Sink.Sink<void, In> =>\n  options?.shutdown ?\n    unwrapScoped(\n      Effect.map(\n        Effect.acquireRelease(Effect.succeed(queue), Queue.shutdown),\n        fromQueue\n      )\n    ) :\n    forEachChunk((input: Chunk.Chunk<In>) => Queue.offerAll(queue, input))\n\n/** @internal */\nexport const head = <In>(): Sink.Sink<Option.Option<In>, In, In> =>\n  fold(\n    Option.none() as Option.Option<In>,\n    Option.isNone,\n    (option, input) =>\n      Option.match(option, {\n        onNone: () => Option.some(input),\n        onSome: () => option\n      })\n  )\n\n/** @internal */\nexport const ignoreLeftover = <A, In, L, E, R>(self: Sink.Sink<A, In, L, E, R>): Sink.Sink<A, In, never, E, R> =>\n  new SinkImpl(channel.drain(toChannel(self)))\n\n/** @internal */\nexport const last = <In>(): Sink.Sink<Option.Option<In>, In, In> =>\n  foldLeftChunks(Option.none<In>(), (s, input) => Option.orElse(Chunk.last(input), () => s))\n\n/** @internal */\nexport const leftover = <L>(chunk: Chunk.Chunk<L>): Sink.Sink<void, unknown, L> =>\n  new SinkImpl(core.suspend(() => core.write(chunk)))\n\n/** @internal */\nexport const map = dual<\n  <A, A2>(f: (a: A) => A2) => <In, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A2, In, L, E, R>,\n  <A, In, L, E, R, A2>(self: Sink.Sink<A, In, L, E, R>, f: (a: A) => A2) => Sink.Sink<A2, In, L, E, R>\n>(2, (self, f) => {\n  return new SinkImpl(pipe(toChannel(self), channel.map(f)))\n})\n\n/** @internal */\nexport const mapEffect = dual<\n  <A, A2, E2, R2>(\n    f: (a: A) => Effect.Effect<A2, E2, R2>\n  ) => <In, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A2, In, L, E2 | E, R2 | R>,\n  <A, In, L, E, R, A2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    f: (a: A) => Effect.Effect<A2, E2, R2>\n  ) => Sink.Sink<A2, In, L, E2 | E, R2 | R>\n>(\n  2,\n  (self, f) => new SinkImpl(pipe(toChannel(self), channel.mapEffect(f)))\n)\n\n/** @internal */\nexport const mapError = dual<\n  <E, E2>(f: (error: E) => E2) => <A, In, L, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In, L, E2, R>,\n  <A, In, L, E, R, E2>(self: Sink.Sink<A, In, L, E, R>, f: (error: E) => E2) => Sink.Sink<A, In, L, E2, R>\n>(\n  2,\n  (self, f) => new SinkImpl(pipe(toChannel(self), channel.mapError(f)))\n)\n\n/** @internal */\nexport const mapLeftover = dual<\n  <L, L2>(f: (leftover: L) => L2) => <A, In, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In, L2, E, R>,\n  <A, In, L, E, R, L2>(self: Sink.Sink<A, In, L, E, R>, f: (leftover: L) => L2) => Sink.Sink<A, In, L2, E, R>\n>(\n  2,\n  (self, f) => new SinkImpl(pipe(toChannel(self), channel.mapOut(Chunk.map(f))))\n)\n\n/** @internal */\nexport const never: Sink.Sink<never, unknown> = fromEffect(Effect.never)\n\n/** @internal */\nexport const orElse = dual<\n  <A2, In2, L2, E2, R2>(\n    that: LazyArg<Sink.Sink<A2, In2, L2, E2, R2>>\n  ) => <A, In, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A2 | A, In & In2, L2 | L, E2 | E, R2 | R>,\n  <A, In, L, E, R, A2, In2, L2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: LazyArg<Sink.Sink<A2, In2, L2, E2, R2>>\n  ) => Sink.Sink<A2 | A, In & In2, L2 | L, E2 | E, R2 | R>\n>(\n  2,\n  <A, In, L, E, R, A2, In2, L2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: LazyArg<Sink.Sink<A2, In2, L2, E2, R2>>\n  ): Sink.Sink<A | A2, In & In2, L | L2, E | E2, R | R2> =>\n    new SinkImpl<A | A2, In & In2, L | L2, E | E2, R | R2>(\n      pipe(toChannel(self), channel.orElse(() => toChannel(that())))\n    )\n)\n\n/** @internal */\nexport const provideContext = dual<\n  <R>(context: Context.Context<R>) => <A, In, L, E>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In, L, E>,\n  <A, In, L, E, R>(self: Sink.Sink<A, In, L, E, R>, context: Context.Context<R>) => Sink.Sink<A, In, L, E>\n>(\n  2,\n  (self, context) => new SinkImpl(pipe(toChannel(self), core.provideContext(context)))\n)\n\n/** @internal */\nexport const race = dual<\n  <R1, E1, In1, L1, A1>(\n    that: Sink.Sink<A1, In1, L1, E1, R1>\n  ) => <A, In, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A1 | A, In & In1, L1 | L, E1 | E, R1 | R>,\n  <A, In, L, E, R, A1, In1, L1, E1, R1>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: Sink.Sink<A1, In1, L1, E1, R1>\n  ) => Sink.Sink<A1 | A, In & In1, L1 | L, E1 | E, R1 | R>\n>(\n  2,\n  (self, that) => pipe(self, raceBoth(that), map(Either.merge))\n)\n\n/** @internal */\nexport const raceBoth = dual<\n  <A1, In1, L1, E1, R1>(\n    that: Sink.Sink<A1, In1, L1, E1, R1>,\n    options?: {\n      readonly capacity?: number | undefined\n    }\n  ) => <A, In, L, E, R>(\n    self: Sink.Sink<A, In, L, E, R>\n  ) => Sink.Sink<Either.Either<A1, A>, In & In1, L1 | L, E1 | E, R1 | R>,\n  <A, In, L, E, R, A1, In1, L1, E1, R1>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: Sink.Sink<A1, In1, L1, E1, R1>,\n    options?: {\n      readonly capacity?: number | undefined\n    }\n  ) => Sink.Sink<Either.Either<A1, A>, In & In1, L1 | L, E1 | E, R1 | R>\n>(\n  (args) => isSink(args[1]),\n  (self, that, options) =>\n    raceWith(self, {\n      other: that,\n      onSelfDone: (selfDone) => mergeDecision.Done(Effect.map(selfDone, Either.left)),\n      onOtherDone: (thatDone) => mergeDecision.Done(Effect.map(thatDone, Either.right)),\n      capacity: options?.capacity ?? 16\n    })\n)\n\n/** @internal */\nexport const raceWith = dual<\n  <A2, In2, L2, E2, R2, A, E, A3, A4>(\n    options: {\n      readonly other: Sink.Sink<A2, In2, L2, E2, R2>\n      readonly onSelfDone: (exit: Exit.Exit<A, E>) => MergeDecision.MergeDecision<R2, E2, A2, E2 | E, A3>\n      readonly onOtherDone: (exit: Exit.Exit<A2, E2>) => MergeDecision.MergeDecision<R2, E, A, E2 | E, A4>\n      readonly capacity?: number | undefined\n    }\n  ) => <In, L, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A3 | A4, In & In2, L2 | L, E2 | E, R2 | R>,\n  <A, In, L, E, R, A2, In2, L2, E2, R2, A3, A4>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly other: Sink.Sink<A2, In2, L2, E2, R2>\n      readonly onSelfDone: (exit: Exit.Exit<A, E>) => MergeDecision.MergeDecision<R2, E2, A2, E2 | E, A3>\n      readonly onOtherDone: (exit: Exit.Exit<A2, E2>) => MergeDecision.MergeDecision<R2, E, A, E2 | E, A4>\n      readonly capacity?: number | undefined\n    }\n  ) => Sink.Sink<A3 | A4, In & In2, L2 | L, E2 | E, R2 | R>\n>(\n  2,\n  <A, In, L, E, R, A2, In2, L2, E2, R2, A3, A4>(\n    self: Sink.Sink<A, In, L, E, R>,\n    options: {\n      readonly other: Sink.Sink<A2, In2, L2, E2, R2>\n      readonly onSelfDone: (exit: Exit.Exit<A, E>) => MergeDecision.MergeDecision<R2, E2, A2, E2 | E, A3>\n      readonly onOtherDone: (exit: Exit.Exit<A2, E2>) => MergeDecision.MergeDecision<R2, E, A, E2 | E, A4>\n      readonly capacity?: number | undefined\n    }\n  ): Sink.Sink<A3 | A4, In & In2, L2 | L, E2 | E, R2 | R> => {\n    function race(scope: Scope.Scope) {\n      return Effect.gen(function*() {\n        const pubsub = yield* PubSub.bounded<\n          Either.Either<Chunk.Chunk<In & In2>, Exit.Exit<unknown>>\n        >(options?.capacity ?? 16)\n        const subscription1 = yield* Scope.extend(PubSub.subscribe(pubsub), scope)\n        const subscription2 = yield* Scope.extend(PubSub.subscribe(pubsub), scope)\n        const reader = channel.toPubSub(pubsub)\n        const writer = channel.fromQueue(subscription1).pipe(\n          core.pipeTo(toChannel(self)),\n          channel.zipLeft(core.fromEffect(Queue.shutdown(subscription1))),\n          channel.mergeWith({\n            other: channel.fromQueue(subscription2).pipe(\n              core.pipeTo(toChannel(options.other)),\n              channel.zipLeft(core.fromEffect(Queue.shutdown(subscription2)))\n            ),\n            onSelfDone: options.onSelfDone,\n            onOtherDone: options.onOtherDone\n          })\n        )\n        const racedChannel = channel.mergeWith(reader, {\n          other: writer,\n          onSelfDone: () => mergeDecision.Await(identity),\n          onOtherDone: (exit) => mergeDecision.Done(exit)\n        }) as Channel.Channel<\n          Chunk.Chunk<L | L2>,\n          Chunk.Chunk<In & In2>,\n          E | E2,\n          never,\n          A3 | A4,\n          unknown,\n          R | R2\n        >\n        return new SinkImpl(racedChannel)\n      })\n    }\n    return unwrapScopedWith(race)\n  }\n)\n\n/** @internal */\nexport const refineOrDie = dual<\n  <E, E2>(\n    pf: (error: E) => Option.Option<E2>\n  ) => <A, In, L, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In, L, E2, R>,\n  <A, In, L, E, R, E2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    pf: (error: E) => Option.Option<E2>\n  ) => Sink.Sink<A, In, L, E2, R>\n>(\n  2,\n  (self, pf) => pipe(self, refineOrDieWith(pf, identity))\n)\n\n/** @internal */\nexport const refineOrDieWith = dual<\n  <E, E2>(\n    pf: (error: E) => Option.Option<E2>,\n    f: (error: E) => unknown\n  ) => <A, In, L, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In, L, E2, R>,\n  <A, In, L, E, R, E2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    pf: (error: E) => Option.Option<E2>,\n    f: (error: E) => unknown\n  ) => Sink.Sink<A, In, L, E2, R>\n>(\n  3,\n  (self, pf, f) => {\n    const newChannel = pipe(\n      self,\n      toChannel,\n      channel.catchAll((error) =>\n        Option.match(pf(error), {\n          onNone: () => core.failCauseSync(() => Cause.die(f(error))),\n          onSome: core.fail\n        })\n      )\n    )\n    return new SinkImpl(newChannel)\n  }\n)\n\n/** @internal */\nexport const service = <I, S>(\n  tag: Context.Tag<I, S>\n): Sink.Sink<S, unknown, never, never, I> => serviceWith(tag, identity)\n\n/** @internal */\nexport const serviceWith = <I, S, Z>(\n  tag: Context.Tag<I, S>,\n  f: (service: Types.NoInfer<S>) => Z\n): Sink.Sink<Z, unknown, never, never, I> => fromEffect(Effect.map(tag, f))\n\n/** @internal */\nexport const serviceWithEffect = <I, S, R, E, Z>(\n  tag: Context.Tag<I, S>,\n  f: (service: Types.NoInfer<S>) => Effect.Effect<Z, E, R>\n): Sink.Sink<Z, unknown, never, E, R | I> => fromEffect(Effect.flatMap(tag, f))\n\n/** @internal */\nexport const serviceWithSink = <I, S, R, E, In, L, Z>(\n  tag: Context.Tag<I, S>,\n  f: (service: Types.NoInfer<S>) => Sink.Sink<Z, In, L, E, R>\n): Sink.Sink<Z, In, L, E, R | I> =>\n  new SinkImpl(pipe(Effect.map(tag, (service) => toChannel(f(service))), channel.unwrap))\n\n/** @internal */\nexport const some = <In>(predicate: Predicate<In>): Sink.Sink<boolean, In, In> =>\n  fold(false, (bool) => !bool, (acc, input) => acc || predicate(input))\n\n/** @internal */\nexport const splitWhere = dual<\n  <In>(f: Predicate<In>) => <A, L extends In, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In, In, E, R>,\n  <A, In, L extends In, E, R>(self: Sink.Sink<A, In, L, E, R>, f: Predicate<In>) => Sink.Sink<A, In, In, E, R>\n>(2, <A, In, L extends In, E, R>(self: Sink.Sink<A, In, L, E, R>, f: Predicate<In>): Sink.Sink<A, In, In, E, R> => {\n  const newChannel = pipe(\n    core.fromEffect(Ref.make(Chunk.empty<In>())),\n    core.flatMap((ref) =>\n      pipe(\n        splitWhereSplitter<In, E>(false, ref, f),\n        channel.pipeToOrFail(toChannel(self)),\n        core.collectElements,\n        core.flatMap(([leftovers, z]) =>\n          pipe(\n            core.fromEffect(Ref.get(ref)),\n            core.flatMap((leftover) =>\n              pipe(\n                core.write<Chunk.Chunk<In>>(pipe(leftover, Chunk.appendAll(Chunk.flatten(leftovers)))),\n                channel.zipRight(core.succeed(z))\n              )\n            )\n          )\n        )\n      )\n    )\n  )\n  return new SinkImpl(newChannel)\n})\n\n/** @internal */\nconst splitWhereSplitter = <A, E>(\n  written: boolean,\n  leftovers: Ref.Ref<Chunk.Chunk<A>>,\n  f: Predicate<A>\n): Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<A>, E, never, unknown, unknown> =>\n  core.readWithCause({\n    onInput: (input) => {\n      if (Chunk.isEmpty(input)) {\n        return splitWhereSplitter(written, leftovers, f)\n      }\n      if (written) {\n        const index = indexWhere(input, f)\n        if (index === -1) {\n          return channel.zipRight(\n            core.write(input),\n            splitWhereSplitter<A, E>(true, leftovers, f)\n          )\n        }\n        const [left, right] = Chunk.splitAt(input, index)\n        return channel.zipRight(\n          core.write(left),\n          core.fromEffect(Ref.set(leftovers, right))\n        )\n      }\n      const index = indexWhere(input, f, 1)\n      if (index === -1) {\n        return channel.zipRight(\n          core.write(input),\n          splitWhereSplitter<A, E>(true, leftovers, f)\n        )\n      }\n      const [left, right] = pipe(input, Chunk.splitAt(Math.max(index, 1)))\n      return channel.zipRight(core.write(left), core.fromEffect(Ref.set(leftovers, right)))\n    },\n    onFailure: core.failCause,\n    onDone: core.succeed\n  })\n\n/** @internal */\nconst indexWhere = <A>(self: Chunk.Chunk<A>, predicate: Predicate<A>, from = 0): number => {\n  const iterator = self[Symbol.iterator]()\n  let index = 0\n  let result = -1\n  let next: IteratorResult<A, any>\n  while (result < 0 && (next = iterator.next()) && !next.done) {\n    const a = next.value\n    if (index >= from && predicate(a)) {\n      result = index\n    }\n    index = index + 1\n  }\n  return result\n}\n\n/** @internal */\nexport const succeed = <A>(a: A): Sink.Sink<A, unknown> => new SinkImpl(core.succeed(a))\n\n/** @internal */\nexport const sum: Sink.Sink<number, number> = foldLeftChunks(\n  0,\n  (acc, chunk) => acc + Chunk.reduce(chunk, 0, (s, a) => s + a)\n)\n\n/** @internal */\nexport const summarized = dual<\n  <A2, E2, R2, A3>(\n    summary: Effect.Effect<A2, E2, R2>,\n    f: (start: A2, end: A2) => A3\n  ) => <A, In, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<[A, A3], In, L, E2 | E, R2 | R>,\n  <A, In, L, E, R, A2, E2, R2, A3>(\n    self: Sink.Sink<A, In, L, E, R>,\n    summary: Effect.Effect<A2, E2, R2>,\n    f: (start: A2, end: A2) => A3\n  ) => Sink.Sink<[A, A3], In, L, E2 | E, R2 | R>\n>(\n  3,\n  (self, summary, f) => {\n    const newChannel = pipe(\n      core.fromEffect(summary),\n      core.flatMap((start) =>\n        pipe(\n          self,\n          toChannel,\n          core.flatMap((done) =>\n            pipe(\n              core.fromEffect(summary),\n              channel.map((end) => [done, f(start, end)])\n            )\n          )\n        )\n      )\n    )\n    return new SinkImpl(newChannel)\n  }\n)\n\n/** @internal */\nexport const sync = <A>(evaluate: LazyArg<A>): Sink.Sink<A, unknown> => new SinkImpl(core.sync(evaluate))\n\n/** @internal */\nexport const take = <In>(n: number): Sink.Sink<Chunk.Chunk<In>, In, In> =>\n  pipe(\n    foldChunks<Chunk.Chunk<In>, In>(\n      Chunk.empty(),\n      (chunk) => chunk.length < n,\n      (acc, chunk) => pipe(acc, Chunk.appendAll(chunk))\n    ),\n    flatMap((acc) => {\n      const [taken, leftover] = pipe(acc, Chunk.splitAt(n))\n      return new SinkImpl(pipe(core.write(leftover), channel.zipRight(core.succeedNow(taken))))\n    })\n  )\n\n/** @internal */\nexport const toChannel = <A, In, L, E, R>(\n  self: Sink.Sink<A, In, L, E, R>\n): Channel.Channel<Chunk.Chunk<L>, Chunk.Chunk<In>, E, never, A, unknown, R> =>\n  Effect.isEffect(self) ?\n    toChannel(fromEffect(self as Effect.Effect<A, E, R>)) :\n    (self as SinkImpl<A, In, L, E, R>).channel\n\n/** @internal */\nexport const unwrap = <A, In, L, E2, R2, E, R>(\n  effect: Effect.Effect<Sink.Sink<A, In, L, E2, R2>, E, R>\n): Sink.Sink<A, In, L, E | E2, R | R2> =>\n  new SinkImpl(\n    channel.unwrap(pipe(effect, Effect.map((sink) => toChannel(sink))))\n  )\n\n/** @internal */\nexport const unwrapScoped = <A, In, L, E, R>(\n  effect: Effect.Effect<Sink.Sink<A, In, L, E, R>, E, R>\n): Sink.Sink<A, In, L, E, Exclude<R, Scope.Scope>> =>\n  new SinkImpl(\n    channel.unwrapScoped(effect.pipe(\n      Effect.map((sink) => toChannel(sink))\n    ))\n  )\n\n/** @internal */\nexport const unwrapScopedWith = <A, In, L, E, R>(\n  f: (scope: Scope.Scope) => Effect.Effect<Sink.Sink<A, In, L, E, R>, E, R>\n): Sink.Sink<A, In, L, E, R> =>\n  new SinkImpl(\n    channel.unwrapScopedWith((scope) =>\n      f(scope).pipe(\n        Effect.map((sink) => toChannel(sink))\n      )\n    )\n  )\n\n/** @internal */\nexport const withDuration = <A, In, L, E, R>(\n  self: Sink.Sink<A, In, L, E, R>\n): Sink.Sink<[A, Duration.Duration], In, L, E, R> =>\n  pipe(self, summarized(Clock.currentTimeMillis, (start, end) => Duration.millis(end - start)))\n\n/** @internal */\nexport const zip = dual<\n  <A2, In, In2 extends In, L2, E2, R2>(\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<[A, A2], In & In2, L | L2, E2 | E, R2 | R>,\n  <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => Sink.Sink<[A, A2], In & In2, L | L2, E2 | E, R2 | R>\n>(\n  (args) => isSink(args[1]),\n  <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ): Sink.Sink<[A, A2], In & In2, L | L2, E2 | E, R2 | R> => zipWith(self, that, (z, z2) => [z, z2], options)\n)\n\n/** @internal */\nexport const zipLeft = dual<\n  <A2, In, In2 extends In, L2, E2, R2>(\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A, In & In2, L | L2, E2 | E, R2 | R>,\n  <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => Sink.Sink<A, In & In2, L | L2, E2 | E, R2 | R>\n>(\n  (args) => isSink(args[1]),\n  <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ): Sink.Sink<A, In & In2, L | L2, E2 | E, R2 | R> => zipWith(self, that, (z, _) => z, options)\n)\n\n/** @internal */\nexport const zipRight = dual<\n  <A2, In, In2 extends In, L2, E2, R2>(\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => <A, L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A2, In & In2, L | L2, E2 | E, R2 | R>,\n  <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => Sink.Sink<A2, In & In2, L | L2, E2 | E, R2 | R>\n>(\n  (args) => isSink(args[1]),\n  <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ): Sink.Sink<A2, In & In2, L | L2, E2 | E, R2 | R> => zipWith(self, that, (_, z2) => z2, options)\n)\n\n/** @internal */\nexport const zipWith = dual<\n  <A2, In, In2 extends In, L2, E2, R2, A, A3>(\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    f: (a: A, a2: A2) => A3,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => <L, E, R>(self: Sink.Sink<A, In, L, E, R>) => Sink.Sink<A3, In & In2, L | L2, E2 | E, R2 | R>,\n  <A, In, L, E, R, A2, In2 extends In, L2, E2, R2, A3>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    f: (a: A, a2: A2) => A3,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ) => Sink.Sink<A3, In & In2, L | L2, E2 | E, R2 | R>\n>(\n  (args) => isSink(args[1]),\n  <A, In, L, E, R, A2, In2 extends In, L2, E2, R2, A3>(\n    self: Sink.Sink<A, In, L, E, R>,\n    that: Sink.Sink<A2, In2, L2, E2, R2>,\n    f: (a: A, a2: A2) => A3,\n    options?: {\n      readonly concurrent?: boolean | undefined\n    }\n  ): Sink.Sink<A3, In & In2, L | L2, E2 | E, R2 | R> =>\n    options?.concurrent ?\n      raceWith(self, {\n        other: that,\n        onSelfDone: Exit.match({\n          onFailure: (cause) => mergeDecision.Done(Effect.failCause(cause)),\n          onSuccess: (leftZ) =>\n            mergeDecision.Await<R | R2, E2, A2, E | E2, A3>(\n              Exit.match({\n                onFailure: Effect.failCause,\n                onSuccess: (rightZ) => Effect.succeed(f(leftZ, rightZ))\n              })\n            )\n        }),\n        onOtherDone: Exit.match({\n          onFailure: (cause) => mergeDecision.Done(Effect.failCause(cause)),\n          onSuccess: (rightZ) =>\n            mergeDecision.Await<R | R2, E, A, E | E2, A3>(\n              Exit.match({\n                onFailure: Effect.failCause,\n                onSuccess: (leftZ) => Effect.succeed(f(leftZ, rightZ))\n              })\n            )\n        })\n      }) :\n      flatMap(self, (z) => map(that, (z2) => f(z, z2)))\n)\n\n// Circular with Channel\n\n/** @internal */\nexport const channelToSink = <OutElem, InElem, OutErr, InErr, OutDone, Env>(\n  self: Channel.Channel<Chunk.Chunk<OutElem>, Chunk.Chunk<InElem>, OutErr, InErr, OutDone, unknown, Env>\n): Sink.Sink<OutDone, InElem, OutElem, OutErr, Env> => new SinkImpl(self)\n\n// Constants\n\n/** @internal */\nexport const count: Sink.Sink<number, unknown> = foldLeftChunks(\n  0,\n  (acc, chunk) => acc + chunk.length\n)\n\n/** @internal */\nexport const mkString: Sink.Sink<string, unknown> = suspend(() => {\n  const strings: Array<string> = []\n  return pipe(\n    foldLeftChunks<void, unknown>(void 0, (_, elems) =>\n      Chunk.map(elems, (elem) => {\n        strings.push(String(elem))\n      })),\n    map(() => strings.join(\"\"))\n  )\n})\n\n/** @internal */\nexport const timed: Sink.Sink<Duration.Duration, unknown> = pipe(\n  withDuration(drain),\n  map((tuple) => tuple[1])\n)\n"],"names":["Arr","Cause","Chunk","Clock","Duration","Effect","Either","Exit","constTrue","dual","identity","pipe","HashMap","HashSet","Option","pipeArguments","hasProperty","PubSub","Queue","Ref","Scope","channel","mergeDecision","core","SinkTypeId","Symbol","for","sinkVariance","_A","_","_In","_L","_E","_R","SinkImpl","constructor","arguments","isSink","u","suspend","evaluate","toChannel","as","self","a","map","collectAll","collectAllLoop","empty","acc","readWithCause","onInput","chunk","appendAll","onFailure","failCause","onDone","succeed","collectAllN","n","fromChannel","collectAllNLoop","collected","leftovers","splitAt","length","isEmpty","flatMap","write","collectAllFrom","collectAllWhileWith","initial","while","body","append","collectAllToMap","key","merge","foldLeftChunks","reduce","input","k","v","has","unsafeGet","set","collectAllToMapN","foldWeighted","maxCost","cost","collectAllToSet","add","collectAllToSetN","collectAllUntil","p","fold","tuple","collectAllUntilEffect","foldEffect","bool","collectAllWhile","predicate","collectAllWhileReader","done","readWith","toReadonlyArray","span","unsafeFromArray","zipRight","fail","collectAllWhileEffect","collectAllWhileEffectReader","fromEffect","takeWhile","drop","options","refs","make","zip","newChannel","leftoversRef","upstreamDoneRef","upstreamMarker","pipeTo","bufferChunk","collectAllWhileWithLoop","currentResult","f","doneCollect","foldChannel","onSuccess","doneValue","flatten","get","upstreamDone","accumulatedResult","collectLeftover","collectElements","chunks","z","mapInput","mapInputChunks","mapInputEffect","mapInputChunksEffect","forEach","loop","pipeToOrFail","die","defect","dieMessage","message","RuntimeException","dieSync","failCauseSync","dimap","dimapEffect","mapEffect","dimapChunks","dimapChunksEffect","drain","identityChannel","dropLoop","dropped","leftover","Math","max","more","void","dropUntil","dropWhile","dropUntilEffect","dropUntilEffectReader","unwrap","dropWhileReader","out","succeedNow","dropWhileEffect","dropWhileEffectReader","ensuring","finalizer","ensuringWith","context","contextWith","contextWithEffect","contextWithSink","every","e","failSync","cause","filterInput","filter","filterInputEffect","findEffect","satisfied","some","none","s","contFn","foldReader","nextS","foldChunkSplit","isNonEmpty","index","s1","foldSink","error","ref","refReader","sync","writeChunk","passthrough","continuationSink","newLeftovers","z1","foldChunks","foldChunksReader","foldChunksEffect","foldChunksEffectReader","foldEffectReader","foldChunkSplitEffect","match","onNone","onSome","foldChunkSplitEffectInternal","foldLeft","ignoreLeftover","foldLeftChunksEffect","foldLeftEffect","foldUntil","output","count","foldUntilEffect","foldWeightedDecompose","decompose","of","foldWeightedDecomposeLoop","dirty","costFn","nextCost","nextDirty","foldWeightedDecomposeFold","elem","prevCost","decomposed","foldWeightedDecomposeEffect","foldWeightedDecomposeEffectLoop","foldWeightedEffect","foldWeightedDecomposeEffectFold","newCost","total","next","process","discard","forEachChunk","forEachWhile","forEachWhileReader","cont","catchAll","forEachChunkWhile","reader","effect","fromPubSub","pubsub","fromQueue","fromPush","push","unwrapScoped","fromPushPull","either","onLeft","onRight","queue","shutdown","acquireRelease","offerAll","head","isNone","option","last","orElse","mapError","mapLeftover","mapOut","never","that","provideContext","race","raceBoth","args","raceWith","other","onSelfDone","selfDone","Done","left","onOtherDone","thatDone","right","capacity","scope","gen","bounded","subscription1","extend","subscribe","subscription2","toPubSub","writer","zipLeft","mergeWith","racedChannel","Await","exit","unwrapScopedWith","refineOrDie","pf","refineOrDieWith","service","tag","serviceWith","serviceWithEffect","serviceWithSink","splitWhere","splitWhereSplitter","written","indexWhere","from","iterator","result","value","sum","summarized","summary","start","end","take","taken","isEffect","sink","withDuration","currentTimeMillis","millis","zipWith","z2","concurrent","leftZ","rightZ","channelToSink","mkString","strings","elems","String","join","timed"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAO,KAAKA,GAAG,MAAM,aAAa;AAClC,OAAO,KAAKC,KAAK,MAAM,aAAa;AAEpC,OAAO,KAAKC,KAAK,MAAM,aAAa;AACpC,OAAO,KAAKC,KAAK,MAAM,aAAa;AAEpC,OAAO,KAAKC,QAAQ,MAAM,gBAAgB;AAC1C,OAAO,KAAKC,MAAM,MAAM,cAAc;AACtC,OAAO,KAAKC,MAAM,MAAM,cAAc;AACtC,OAAO,KAAKC,IAAI,MAAM,YAAY;AAClC,SAASC,SAAS,EAAEC,IAAI,EAAEC,QAAQ,EAAEC,IAAI,QAAQ,gBAAgB;AAEhE,OAAO,KAAKC,OAAO,MAAM,eAAe;AACxC,OAAO,KAAKC,OAAO,MAAM,eAAe;AAExC,OAAO,KAAKC,MAAM,MAAM,cAAc;AACtC,SAASC,aAAa,QAAQ,gBAAgB;AAC9C,SAASC,WAAW,QAAyC,iBAAiB;AAC9E,OAAO,KAAKC,MAAM,MAAM,cAAc;AACtC,OAAO,KAAKC,KAAK,MAAM,aAAa;AACpC,OAAO,KAAKC,GAAG,MAAM,WAAW;AAChC,OAAO,KAAKC,KAAK,MAAM,aAAa;AAGpC,OAAO,KAAKC,OAAO,MAAM,cAAc;AACvC,OAAO,KAAKC,aAAa,MAAM,4BAA4B;AAC3D,OAAO,KAAKC,IAAI,MAAM,kBAAkB;;;;;;;;;;;;;;;;;;;;;;AAGjC,MAAMC,UAAU,GAAA,WAAA,GAAoBC,MAAM,CAACC,GAAG,CAAC,aAAa,CAAoB;AAEvF,MAAMC,YAAY,GAAG;IACnB,kBAAA,GACAC,EAAE,GAAGC,CAAQ,GAAKA,CAAC;IACnB,kBAAA,GACAC,GAAG,GAAGD,CAAU,GAAKA,CAAC;IACtB,kBAAA,GACAE,EAAE,GAAGF,CAAQ,GAAKA,CAAC;IACnB,kBAAA,GACAG,EAAE,GAAGH,CAAQ,GAAKA,CAAC;IACnB,kBAAA,GACAI,EAAE,GAAGJ,CAAQ,GAAKA;CACnB;AAGK,MAAOK,QAAQ;IAKRb,OAAA,CAAA;IAFF,CAACG,UAAU,CAAA,GAAIG,YAAY,CAAA;IACpCQ,YACWd,OAAkF,CAAA;QAAlF,IAAA,CAAAA,OAAO,GAAPA,OAAO;IAElB;IACAV,IAAIA,CAAA,EAAA;QACF,WAAOI,mMAAa,EAAC,IAAI,EAAEqB,SAAS,CAAC;IACvC;;AAIK,MAAMC,MAAM,IAAIC,CAAU,OAC/BtB,kMAAW,EAACsB,CAAC,EAAEd,UAAU,CAAC;AAGrB,MAAMe,OAAO,IAAoBC,QAA4C,GAClF,IAAIN,QAAQ,CAACX,IAAI,CAACgB,0MAAO,CAAC,IAAME,SAAS,CAACD,QAAQ,EAAE,CAAC,CAAC,CAAC;AAGlD,MAAME,EAAE,GAAA,WAAA,OAAGjC,0LAAI,EAIpB,CAAC,EACD,CAACkC,IAAI,EAAEC,CAAC,OAAKjC,0LAAI,EAACgC,IAAI,EAAEE,GAAG,CAAC,IAAMD,CAAC,CAAC,CAAC,CACtC;AAGM,MAAME,UAAU,GAAGA,CAAA,GAA0C,IAAIZ,QAAQ,CAACa,cAAc,CAAC7C,KAAK,CAAC8C,kLAAK,EAAE,CAAC,CAAC;AAE/G,cAAA,GACA,MAAMD,cAAc,IAClBE,GAAoB,GAEpB1B,IAAI,CAAC2B,gNAAa,CAAC;QACjBC,OAAO,GAAGC,KAAsB,GAAKL,cAAc,KAACpC,0LAAI,EAACsC,GAAG,EAAE/C,KAAK,CAACmD,sLAAS,CAACD,KAAK,CAAC,CAAC,CAAC;QACtFE,SAAS,EAAE/B,IAAI,CAACgC,4MAAS;QACzBC,MAAM,EAAEA,CAAA,GAAMjC,IAAI,CAACkC,0MAAO,CAACR,GAAG;KAC/B,CAAC;AAGG,MAAMS,WAAW,IAAQC,CAAS,GACvCpB,OAAO,CAAC,IAAMqB,WAAW,CAACC,eAAe,CAACF,CAAC,EAAEzD,KAAK,CAAC8C,kLAAK,EAAE,CAAC,CAAC,CAAC;AAE/D,cAAA,GACA,MAAMa,eAAe,GAAGA,CACtBF,CAAS,EACTV,GAAoB,GAEpB1B,IAAI,CAAC2B,gNAAa,CAAC;QACjBC,OAAO,GAAGC,KAAsB,IAAI;YAClC,MAAM,CAACU,SAAS,EAAEC,SAAS,CAAC,GAAG7D,KAAK,CAAC8D,oLAAO,CAACZ,KAAK,EAAEO,CAAC,CAAC;YACtD,IAAIG,SAAS,CAACG,MAAM,GAAGN,CAAC,EAAE;gBACxB,OAAOE,eAAe,CAACF,CAAC,GAAGG,SAAS,CAACG,MAAM,EAAE/D,KAAK,CAACmD,sLAAS,CAACJ,GAAG,EAAEa,SAAS,CAAC,CAAC;YAC/E;YACA,IAAI5D,KAAK,CAACgE,oLAAO,CAACH,SAAS,CAAC,EAAE;gBAC5B,OAAOxC,IAAI,CAACkC,0MAAO,CAACvD,KAAK,CAACmD,sLAAS,CAACJ,GAAG,EAAEa,SAAS,CAAC,CAAC;YACtD;YACA,OAAOvC,IAAI,CAAC4C,0MAAO,CAAC5C,IAAI,CAAC6C,wMAAK,CAACL,SAAS,CAAC,EAAE,IAAMxC,IAAI,CAACkC,0MAAO,CAACvD,KAAK,CAACmD,sLAAS,CAACJ,GAAG,EAAEa,SAAS,CAAC,CAAC,CAAC;QACjG,CAAC;QACDR,SAAS,EAAE/B,IAAI,CAACgC,4MAAS;QACzBC,MAAM,EAAEA,CAAA,GAAMjC,IAAI,CAACkC,0MAAO,CAACR,GAAG;KAC/B,CAAC;AAGG,MAAMoB,cAAc,IACzB1B,IAA+B,GAE/B2B,mBAAmB,CAAC3B,IAAI,EAAE;QACxB4B,OAAO,EAAErE,KAAK,CAAC8C,kLAAK,EAAK;QACzBwB,KAAK,EAAEhE,+LAAS;QAChBiE,IAAI,EAAEA,CAACrB,KAAK,EAAER,CAAC,OAAKjC,0LAAI,EAACyC,KAAK,EAAElD,KAAK,CAACwE,mLAAM,CAAC9B,CAAC,CAAC;KAChD,CAAC;AAGG,MAAM+B,eAAe,GAAGA,CAC7BC,GAAqB,EACrBC,KAA2B,KACc;IACzC,OAAOC,cAAc,CAAClE,OAAO,CAACoC,kLAAK,EAAS,EAAE,CAACH,GAAG,EAAEO,KAAK,OACvDzC,0LAAI,EACFyC,KAAK,EACLlD,KAAK,CAAC6E,mLAAM,CAAClC,GAAG,EAAE,CAACA,GAAG,EAAEmC,KAAK,KAAI;YAC/B,MAAMC,CAAC,GAAML,GAAG,CAACI,KAAK,CAAC;YACvB,MAAME,CAAC,OAAOvE,0LAAI,EAACkC,GAAG,EAAEjC,OAAO,CAACuE,gLAAG,CAACF,CAAC,CAAC,CAAC,GACrCJ,KAAK,KAAClE,0LAAI,EAACkC,GAAG,EAAEjC,OAAO,CAACwE,sLAAS,CAACH,CAAC,CAAC,CAAC,EAAED,KAAK,CAAC,GAC7CA,KAAK;YACP,WAAOrE,0LAAI,EAACkC,GAAG,EAAEjC,OAAO,CAACyE,gLAAG,CAACJ,CAAC,EAAEC,CAAC,CAAC,CAAC;QACrC,CAAC,CAAC,CACH,CAAC;AACN,CAAC;AAGM,MAAMI,gBAAgB,GAAGA,CAC9B3B,CAAS,EACTiB,GAAqB,EACrBC,KAA2B,KACkB;IAC7C,OAAOU,YAAY,CAA6B;QAC9ChB,OAAO,EAAE3D,OAAO,CAACoC,kLAAK,EAAE;QACxBwC,OAAO,EAAE7B,CAAC;QACV8B,IAAI,EAAEA,CAACxC,GAAG,EAAE+B,KAAK,OAAKrE,0LAAI,EAACsC,GAAG,EAAErC,OAAO,CAACuE,gLAAG,CAACP,GAAG,CAACI,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC;QAChEP,IAAI,EAAEA,CAACxB,GAAG,EAAE+B,KAAK,KAAI;YACnB,MAAMC,CAAC,GAAML,GAAG,CAACI,KAAK,CAAC;YACvB,MAAME,CAAC,OAAOvE,0LAAI,EAACsC,GAAG,EAAErC,OAAO,CAACuE,gLAAG,CAACF,CAAC,CAAC,CAAC,GACrCJ,KAAK,KAAClE,0LAAI,EAACsC,GAAG,EAAErC,OAAO,CAACwE,sLAAS,CAACH,CAAC,CAAC,CAAC,EAAED,KAAK,CAAC,GAC7CA,KAAK;YACP,WAAOrE,0LAAI,EAACsC,GAAG,EAAErC,OAAO,CAACyE,gLAAG,CAACJ,CAAC,EAAEC,CAAC,CAAC,CAAC;QACrC;KACD,CAAC;AACJ,CAAC;AAGM,MAAMQ,eAAe,GAAGA,CAAA,GAC7BZ,cAAc,CACZjE,OAAO,CAACmC,kLAAK,EAAE,EACf,CAACC,GAAG,EAAEG,KAAK,OAAKzC,0LAAI,EAACyC,KAAK,EAAElD,KAAK,CAAC6E,mLAAM,CAAC9B,GAAG,EAAE,CAACA,GAAG,EAAE+B,KAAK,OAAKrE,0LAAI,EAACsC,GAAG,EAAEpC,OAAO,CAAC8E,gLAAG,CAACX,KAAK,CAAC,CAAC,CAAC,CAAC,CAC9F;AAGI,MAAMY,gBAAgB,IAAQjC,CAAS,GAC5C4B,YAAY,CAA0B;QACpChB,OAAO,EAAE1D,OAAO,CAACmC,kLAAK,EAAE;QACxBwC,OAAO,EAAE7B,CAAC;QACV8B,IAAI,EAAEA,CAACxC,GAAG,EAAE+B,KAAK,GAAKnE,OAAO,CAACsE,gLAAG,CAAClC,GAAG,EAAE+B,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC;QACrDP,IAAI,EAAEA,CAACxB,GAAG,EAAE+B,KAAK,GAAKnE,OAAO,CAAC8E,gLAAG,CAAC1C,GAAG,EAAE+B,KAAK;KAC7C,CAAC;AAGG,MAAMa,eAAe,IAAQC,CAAgB,IAAwC;IAC1F,WAAOnF,0LAAI,EACToF,IAAI,CACF;QAAC7F,KAAK,CAAC8C,kLAAK,EAAE;QAAE,IAAI;KAAC,GACpBgD,KAAK,GAAKA,KAAK,CAAC,CAAC,CAAC,EACnB,CAAC,CAAC5C,KAAK,EAAEvB,CAAC,CAAC,EAAEmD,KAAK,GAAK;gBAACrE,0LAAI,EAACyC,KAAK,EAAElD,KAAK,CAACwE,mLAAM,CAACM,KAAK,CAAC,CAAC;YAAE,CAACc,CAAC,CAACd,KAAK,CAAC;SAAC,CACrE,EACDnC,GAAG,EAAEmD,KAAK,GAAKA,KAAK,CAAC,CAAC,CAAC,CAAC,CACzB;AACH,CAAC;AAGM,MAAMC,qBAAqB,IAAcH,CAA8C,IAAI;IAChG,WAAOnF,0LAAI,EACTuF,UAAU,CACR;QAAChG,KAAK,CAAC8C,kLAAK,EAAE;QAAE,IAAI;KAAC,GACpBgD,KAAK,GAAKA,KAAK,CAAC,CAAC,CAAC,EACnB,CAAC,CAAC5C,KAAK,EAAEvB,CAAC,CAAC,EAAEmD,KAAK,OAAKrE,0LAAI,EAACmF,CAAC,CAACd,KAAK,CAAC,EAAE3E,MAAM,CAACwC,gLAAG,EAAEsD,IAAI,GAAK;oBAACxF,0LAAI,EAACyC,KAAK,EAAElD,KAAK,CAACwE,mLAAM,CAACM,KAAK,CAAC,CAAC;gBAAE,CAACmB,IAAI;aAAC,CAAC,CAAC,CACvG,EACDtD,GAAG,EAAEmD,KAAK,GAAKA,KAAK,CAAC,CAAC,CAAC,CAAC,CACzB;AACH,CAAC;AAGM,MAAMI,eAAe,IAGnBC,SAAwB,GAC/BzC,WAAW,CAAC0C,qBAAqB,CAACD,SAAS,EAAEnG,KAAK,CAAC8C,kLAAK,EAAE,CAAC,CAAC;AAE9D,cAAA,GACA,MAAMsD,qBAAqB,GAAGA,CAC5BD,SAAwB,EACxBE,IAAqB,GAErBhF,IAAI,CAACiF,2MAAQ,CAAC;QACZrD,OAAO,GAAG6B,KAAsB,IAAI;YAClC,MAAM,CAAClB,SAAS,EAAEC,SAAS,CAAC,OAAGpD,0LAAI,EAACT,KAAK,CAACuG,4LAAe,CAACzB,KAAK,CAAC,EAAEhF,GAAG,CAAC0G,mLAAI,CAACL,SAAS,CAAC,CAAC;YACtF,IAAItC,SAAS,CAACE,MAAM,KAAK,CAAC,EAAE;gBAC1B,OAAOqC,qBAAqB,CAC1BD,SAAS,MACT1F,0LAAI,EAAC4F,IAAI,EAAErG,KAAK,CAACmD,sLAAS,CAACnD,KAAK,CAACyG,4LAAe,CAAC7C,SAAS,CAAC,CAAC,CAAC,CAC9D;YACH;YACA,WAAOnD,0LAAI,EACTY,IAAI,CAAC6C,wMAAK,CAAClE,KAAK,CAACyG,4LAAe,CAAC5C,SAAS,CAAC,CAAC,EAC5C1C,OAAO,CAACuF,iMAAQ,CAACrF,IAAI,CAACkC,0MAAO,KAAC9C,0LAAI,EAAC4F,IAAI,EAAErG,KAAK,CAACmD,sLAAS,CAACnD,KAAK,CAACyG,4LAAe,CAAC7C,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAC9F;QACH,CAAC;QACDR,SAAS,EAAE/B,IAAI,CAACsF,uMAAI;QACpBrD,MAAM,EAAEA,CAAA,GAAMjC,IAAI,CAACkC,0MAAO,CAAC8C,IAAI;KAChC,CAAC;AAGG,MAAMO,qBAAqB,IAChCT,SAAsD,GACTzC,WAAW,CAACmD,2BAA2B,CAACV,SAAS,EAAEnG,KAAK,CAAC8C,kLAAK,EAAE,CAAC,CAAC;AAEjH,cAAA,GACA,MAAM+D,2BAA2B,GAAGA,CAClCV,SAAsD,EACtDE,IAAqB,GAErBhF,IAAI,CAACiF,2MAAQ,CAAC;QACZrD,OAAO,GAAG6B,KAAsB,OAC9BrE,0LAAI,EACFY,IAAI,CAACyF,6MAAU,KAACrG,0LAAI,EAACqE,KAAK,EAAE3E,MAAM,CAAC4G,sLAAS,CAACZ,SAAS,CAAC,EAAEhG,MAAM,CAACwC,gLAAG,CAAC3C,KAAK,CAACyG,4LAAe,CAAC,CAAC,CAAC,EAC5FpF,IAAI,CAAC4C,0MAAO,EAAEL,SAAS,IAAI;gBACzB,MAAMC,SAAS,OAAGpD,0LAAI,EAACqE,KAAK,EAAE9E,KAAK,CAACgH,iLAAI,CAACpD,SAAS,CAACG,MAAM,CAAC,CAAC;gBAC3D,IAAI/D,KAAK,CAACgE,oLAAO,CAACH,SAAS,CAAC,EAAE;oBAC5B,OAAOgD,2BAA2B,CAACV,SAAS,MAAE1F,0LAAI,EAAC4F,IAAI,EAAErG,KAAK,CAACmD,sLAAS,CAACS,SAAS,CAAC,CAAC,CAAC;gBACvF;gBACA,WAAOnD,0LAAI,EAACY,IAAI,CAAC6C,wMAAK,CAACL,SAAS,CAAC,EAAE1C,OAAO,CAACuF,iMAAQ,CAACrF,IAAI,CAACkC,0MAAO,KAAC9C,0LAAI,EAAC4F,IAAI,EAAErG,KAAK,CAACmD,sLAAS,CAACS,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;YAC5G,CAAC,CAAC,CACH;QACHR,SAAS,EAAE/B,IAAI,CAACsF,uMAAI;QACpBrD,MAAM,EAAEA,CAAA,GAAMjC,IAAI,CAACkC,0MAAO,CAAC8C,IAAI;KAChC,CAAC;AAGG,MAAMjC,mBAAmB,GAAA,WAAA,OAgB5B7D,0LAAI,EACN,CAAC,EACD,CACEkC,IAA+B,EAC/BwE,OAIC,KAC4B;IAC7B,MAAMC,IAAI,OAAGzG,0LAAI,EACfQ,GAAG,CAACkG,iLAAI,CAACnH,KAAK,CAAC8C,kLAAK,EAAM,CAAC,EAC3B3C,MAAM,CAACiH,gLAAG,CAACnG,GAAG,CAACkG,iLAAI,CAAC,KAAK,CAAC,CAAC,CAC5B;IACD,MAAME,UAAU,OAAG5G,0LAAI,EACrBY,IAAI,CAACyF,6MAAU,CAACI,IAAI,CAAC,EACrB7F,IAAI,CAAC4C,0MAAO,CAAC,CAAC,CAACqD,YAAY,EAAEC,eAAe,CAAC,KAAI;QAC/C,MAAMC,cAAc,GAAsFnG,IAAI,CAC3GiF,2MAAQ,CAAC;YACRrD,OAAO,GAAG6B,KAAK,OAAKrE,0LAAI,EAACY,IAAI,CAAC6C,wMAAK,CAACY,KAAK,CAAC,EAAEzD,IAAI,CAAC4C,0MAAO,CAAC,IAAMuD,cAAc,CAAC,CAAC;YAC/EpE,SAAS,EAAE/B,IAAI,CAACsF,uMAAI;YACpBrD,MAAM,GAAG+C,IAAI,OAAK5F,0LAAI,EAACY,IAAI,CAACyF,6MAAU,CAAC7F,GAAG,CAACkE,gLAAG,CAACoC,eAAe,EAAE,IAAI,CAAC,CAAC,EAAEpG,OAAO,CAACqB,2LAAE,CAAC6D,IAAI,CAAC;SACzF,CAAC;QACJ,WAAO5F,0LAAI,EACT+G,cAAc,EACdnG,IAAI,CAACoG,yMAAM,CAACtG,OAAO,CAACuG,oMAAW,CAACJ,YAAY,CAAC,CAAC,EAC9CjG,IAAI,CAACoG,yMAAM,CACTE,uBAAuB,CAAClF,IAAI,EAAE6E,YAAY,EAAEC,eAAe,EAAEN,OAAO,CAAC5C,OAAO,EAAE4C,OAAO,CAAC3C,KAAK,EAAE2C,OAAO,CAAC1C,IAAI,CAAC,CAC3G,CACF;IACH,CAAC,CAAC,CACH;IACD,OAAO,IAAIvC,QAAQ,CAACqF,UAAU,CAAC;AACjC,CAAC,CACF;AAED,MAAMM,uBAAuB,GAAGA,CAC9BlF,IAA+B,EAC/B6E,YAAsC,EACtCC,eAAiC,EACjCK,aAAgB,EAChBhC,CAAe,EACfiC,CAAoB,KACyD;IAC7E,WAAOpH,0LAAI,EACT8B,SAAS,CAACE,IAAI,CAAC,EACftB,OAAO,CAAC2G,oMAAW,EACnB3G,OAAO,CAAC4G,oMAAW,CAAC;QAClB3E,SAAS,EAAE/B,IAAI,CAACsF,uMAAI;QACpBqB,SAAS,EAAEA,CAAC,CAACnE,SAAS,EAAEoE,SAAS,CAAC,GAChCrC,CAAC,CAACqC,SAAS,CAAC,OACRxH,0LAAI,EACJY,IAAI,CAACyF,6MAAU,CACb7F,GAAG,CAACkE,gLAAG,CAACmC,YAAY,EAAEtH,KAAK,CAACkI,oLAAO,CAACrE,SAAyC,CAAC,CAAC,CAChF,EACDxC,IAAI,CAAC4C,0MAAO,CAAC,QACXxD,0LAAI,EACFY,IAAI,CAACyF,6MAAU,CAAC7F,GAAG,CAACkH,gLAAG,CAACZ,eAAe,CAAC,CAAC,EACzClG,IAAI,CAAC4C,0MAAO,EAAEmE,YAAY,IAAI;oBAC5B,MAAMC,iBAAiB,GAAGR,CAAC,CAACD,aAAa,EAAEK,SAAS,CAAC;oBACrD,OAAOG,YAAY,OACf3H,0LAAI,EAACY,IAAI,CAAC6C,wMAAK,CAAClE,KAAK,CAACkI,oLAAO,CAACrE,SAAS,CAAC,CAAC,EAAE1C,OAAO,CAACqB,2LAAE,CAAC6F,iBAAiB,CAAC,CAAC,GACzEV,uBAAuB,CAAClF,IAAI,EAAE6E,YAAY,EAAEC,eAAe,EAAEc,iBAAiB,EAAEzC,CAAC,EAAEiC,CAAC,CAAC;gBAC3F,CAAC,CAAC,CACH,CACF,CACF,OACCpH,0LAAI,EAACY,IAAI,CAAC6C,wMAAK,CAAClE,KAAK,CAACkI,oLAAO,CAACrE,SAAS,CAAC,CAAC,EAAE1C,OAAO,CAACqB,2LAAE,CAACoF,aAAa,CAAC;KAC3E,CAAC,CACH;AACH,CAAC;AAGM,MAAMU,eAAe,IAC1B7F,IAA+B,GAE/B,IAAIT,QAAQ,KAACvB,0LAAI,EAACY,IAAI,CAACkH,kNAAe,CAAChG,SAAS,CAACE,IAAI,CAAC,CAAC,EAAEtB,OAAO,CAACwB,4LAAG,CAAC,CAAC,CAAC6F,MAAM,EAAEC,CAAC,CAAC,GAAK;YAACA,CAAC;YAAEzI,KAAK,CAACkI,oLAAO,CAACM,MAAM,CAAC;SAAC,CAAC,CAAC,CAAC;AAG9G,MAAME,QAAQ,GAAA,WAAA,OAAGnI,0LAAI,EAI1B,CAAC,EACD,CAAsBkC,IAA+B,EAAEoF,CAAqB,OAC1EpH,0LAAI,EAACgC,IAAI,EAAEkG,cAAc,CAAC3I,KAAK,CAAC2C,gLAAG,CAACkF,CAAC,CAAC,CAAC,CAAC,CAC3C;AAGM,MAAMe,cAAc,GAAA,WAAA,OAAGrI,0LAAI,EAShC,CAAC,EACD,CACEkC,IAA+B,EAC/BoF,CAA4C,GAE5CgB,oBAAoB,CAClBpG,IAAI,GACHS,KAAK,GACJ/C,MAAM,CAACwC,gLAAG,CACRxC,MAAM,CAAC2I,oLAAO,CAAC5F,KAAK,GAAG8B,CAAC,GAAK6C,CAAC,CAAC7C,CAAC,CAAC,CAAC,EAClChF,KAAK,CAACyG,4LAAe,CACtB,CACJ,CACJ;AAGM,MAAMkC,cAAc,GAAA,WAAA,OAAGpI,0LAAI,EAShC,CAAC,EACD,CACEkC,IAA+B,EAC/BoF,CAA+C,KACjB;IAC9B,MAAMkB,IAAI,GAA0F1H,IAAI,CAACiF,2MAAQ,CAAC;QAChHrD,OAAO,GAAGC,KAAK,OAAKzC,0LAAI,EAACY,IAAI,CAAC6C,wMAAK,CAAC2D,CAAC,CAAC3E,KAAK,CAAC,CAAC,EAAE7B,IAAI,CAAC4C,0MAAO,CAAC,IAAM8E,IAAI,CAAC,CAAC;QACxE3F,SAAS,EAAE/B,IAAI,CAACsF,uMAAI;QACpBrD,MAAM,EAAEjC,IAAI,CAACkC,0MAAAA;KACd,CAAC;IACF,OAAO,IAAIvB,QAAQ,KAACvB,0LAAI,EAACsI,IAAI,EAAE1H,IAAI,CAACoG,yMAAM,CAAClF,SAAS,CAACE,IAAI,CAAC,CAAC,CAAC,CAAC;AAC/D,CAAC,CACF;AAGM,MAAMoG,oBAAoB,GAAA,WAAA,OAAGtI,0LAAI,EAStC,CAAC,EACD,CACEkC,IAA+B,EAC/BoF,CAAsE,KAC9B;IACxC,MAAMkB,IAAI,GAA4F1H,IAAI,CACvGiF,2MAAQ,CAAC;QACRrD,OAAO,GAAGC,KAAK,OAAKzC,0LAAI,EAACY,IAAI,CAACyF,6MAAU,CAACe,CAAC,CAAC3E,KAAK,CAAC,CAAC,EAAE7B,IAAI,CAAC4C,0MAAO,CAAC5C,IAAI,CAAC6C,wMAAK,CAAC,EAAE7C,IAAI,CAAC4C,0MAAO,CAAC,IAAM8E,IAAI,CAAC,CAAC;QACvG3F,SAAS,EAAE/B,IAAI,CAACsF,uMAAI;QACpBrD,MAAM,EAAEjC,IAAI,CAACkC,0MAAAA;KACd,CAAC;IACJ,OAAO,IAAIvB,QAAQ,KAACvB,0LAAI,EAACsI,IAAI,EAAE5H,OAAO,CAAC6H,qMAAY,CAACzG,SAAS,CAACE,IAAI,CAAC,CAAC,CAAC,CAAC;AACxE,CAAC,CACF;AAGM,MAAMwG,GAAG,IAAIC,MAAe,GAAgC7F,SAAS,CAACtD,KAAK,CAACkJ,gLAAG,CAACC,MAAM,CAAC,CAAC;AAGxF,MAAMC,UAAU,IAAIC,OAAe,GACxC/F,SAAS,CAACtD,KAAK,CAACkJ,gLAAG,CAAC,IAAIlJ,KAAK,CAACsJ,6LAAgB,CAACD,OAAO,CAAC,CAAC,CAAC;AAGpD,MAAME,OAAO,IAAIhH,QAA0B,GAChDiH,aAAa,CAAC,IAAMxJ,KAAK,CAACkJ,gLAAG,CAAC3G,QAAQ,EAAE,CAAC,CAAC;AAGrC,MAAMkH,KAAK,GAAA,WAAA,OAAGjJ,0LAAI,EAevB,CAAC,EACD,CACEkC,IAA+B,EAC/BwE,OAGC,GAC+BtE,GAAG,CAAC+F,QAAQ,CAACjG,IAAI,EAAEwE,OAAO,CAAChE,OAAO,CAAC,EAAEgE,OAAO,CAAC3D,MAAM,CAAC,CACvF;AAGM,MAAMmG,WAAW,GAAA,WAAA,OAAGlJ,0LAAI,EAe7B,CAAC,EACD,CAACkC,IAAI,EAAEwE,OAAO,GACZyC,SAAS,CACPd,cAAc,CAACnG,IAAI,EAAEwE,OAAO,CAAChE,OAAO,CAAC,EACrCgE,OAAO,CAAC3D,MAAM,CACf,CACJ;AAGM,MAAMqG,WAAW,GAAA,WAAA,OAAGpJ,0LAAI,EAe7B,CAAC,EACD,CAACkC,IAAI,EAAEwE,OAAO,GACZtE,GAAG,CACDgG,cAAc,CAAClG,IAAI,EAAEwE,OAAO,CAAChE,OAAO,CAAC,EACrCgE,OAAO,CAAC3D,MAAM,CACf,CACJ;AAGM,MAAMsG,iBAAiB,GAAA,WAAA,OAAGrJ,0LAAI,EAenC,CAAC,EACD,CAACkC,IAAI,EAAEwE,OAAO,GAAKyC,SAAS,CAACb,oBAAoB,CAACpG,IAAI,EAAEwE,OAAO,CAAChE,OAAO,CAAC,EAAEgE,OAAO,CAAC3D,MAAM,CAAC,CAC1F;AAGM,MAAMuG,KAAK,GAAA,WAAA,GAA6B,IAAI7H,QAAQ,CAAA,WAAA,GACzDb,OAAO,CAAC0I,8LAAK,CAAA,WAAA,GAAC1I,OAAO,CAAC2I,wMAAe,EAAE,CAAC,CACzC;AAGM,MAAM9C,IAAI,IAAQvD,CAAS,GAAiCpB,OAAO,CAAC,IAAM,IAAIL,QAAQ,CAAC+H,QAAQ,CAACtG,CAAC,CAAC,CAAC,CAAC;AAE3G,cAAA,GACA,MAAMsG,QAAQ,IACZtG,CAAS,GAETpC,IAAI,CAACiF,2MAAQ,CAAC;QACZrD,OAAO,GAAG6B,KAAsB,IAAI;YAClC,MAAMkF,OAAO,OAAGvJ,0LAAI,EAACqE,KAAK,EAAE9E,KAAK,CAACgH,iLAAI,CAACvD,CAAC,CAAC,CAAC;YAC1C,MAAMwG,QAAQ,GAAGC,IAAI,CAACC,GAAG,CAAC1G,CAAC,GAAGqB,KAAK,CAACf,MAAM,EAAE,CAAC,CAAC;YAC9C,MAAMqG,IAAI,GAAGpK,KAAK,CAACgE,oLAAO,CAACc,KAAK,CAAC,IAAImF,QAAQ,GAAG,CAAC;YACjD,IAAIG,IAAI,EAAE;gBACR,OAAOL,QAAQ,CAACE,QAAQ,CAAC;YAC3B;YACA,WAAOxJ,0LAAI,EACTY,IAAI,CAAC6C,wMAAK,CAAC8F,OAAO,CAAC,EACnB7I,OAAO,CAACuF,iMAAQ,CAACvF,OAAO,CAAC2I,wMAAe,EAAmC,CAAC,CAC7E;QACH,CAAC;QACD1G,SAAS,EAAE/B,IAAI,CAACsF,uMAAI;QACpBrD,MAAM,EAAEA,CAAA,GAAMjC,IAAI,CAACgJ,uMAAAA;KACpB,CAAC;AAGG,MAAMC,SAAS,IAAQnE,SAAwB,GACpD,IAAInE,QAAQ,KACVvB,0LAAI,EAAC8B,SAAS,CAACgI,SAAS,EAAEzF,KAAS,GAAK,CAACqB,SAAS,CAACrB,KAAK,CAAC,CAAC,CAAC,EAAE3D,OAAO,CAAC6H,qMAAY,CAACzG,SAAS,CAACyE,IAAI,CAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAC3G;AAGI,MAAMwD,eAAe,IAC1BrE,SAAsD,GACjB9D,OAAO,CAAC,IAAM,IAAIL,QAAQ,CAACyI,qBAAqB,CAACtE,SAAS,CAAC,CAAC,CAAC;AAEpG,cAAA,GACA,MAAMsE,qBAAqB,IACzBtE,SAAsD,GAEtD9E,IAAI,CAACiF,2MAAQ,CAAC;QACZrD,OAAO,GAAG6B,KAAsB,OAC9BrE,0LAAI,EACFqE,KAAK,EACL3E,MAAM,CAACmK,sLAAS,CAACnE,SAAS,CAAC,EAC3BhG,MAAM,CAACwC,gLAAG,EAAEsH,QAAQ,IAAI;gBACtB,MAAMG,IAAI,GAAGH,QAAQ,CAAClG,MAAM,KAAK,CAAC;gBAClC,OAAOqG,IAAI,GACTK,qBAAqB,CAACtE,SAAS,CAAC,OAChC1F,0LAAI,EACFY,IAAI,CAAC6C,wMAAK,CAAClE,KAAK,CAACyG,4LAAe,CAACwD,QAAQ,CAAC,CAAC,EAC3C9I,OAAO,CAACuF,iMAAQ,CAACvF,OAAO,CAAC2I,wMAAe,EAA+B,CAAC,CACzE;YACL,CAAC,CAAC,EACF3I,OAAO,CAACuJ,+LAAM,CACf;QACHtH,SAAS,EAAE/B,IAAI,CAACsF,uMAAI;QACpBrD,MAAM,EAAEA,CAAA,GAAMjC,IAAI,CAACgJ,uMAAAA;KACpB,CAAC;AAGG,MAAME,SAAS,IAAQpE,SAAwB,GACpD,IAAInE,QAAQ,CAAC2I,eAAe,CAACxE,SAAS,CAAC,CAAC;AAE1C,cAAA,GACA,MAAMwE,eAAe,IACnBxE,SAAwB,GAExB9E,IAAI,CAACiF,2MAAQ,CAAC;QACZrD,OAAO,GAAG6B,KAAsB,IAAI;YAClC,MAAM8F,GAAG,OAAGnK,0LAAI,EAACqE,KAAK,EAAE9E,KAAK,CAACuK,sLAAS,CAACpE,SAAS,CAAC,CAAC;YACnD,IAAInG,KAAK,CAACgE,oLAAO,CAAC4G,GAAG,CAAC,EAAE;gBACtB,OAAOD,eAAe,CAACxE,SAAS,CAAC;YACnC;YACA,WAAO1F,0LAAI,EAACY,IAAI,CAAC6C,wMAAK,CAAC0G,GAAG,CAAC,EAAEzJ,OAAO,CAACuF,iMAAQ,CAACvF,OAAO,CAAC2I,wMAAe,EAAmC,CAAC,CAAC;QAC5G,CAAC;QACD1G,SAAS,EAAE/B,IAAI,CAACsF,uMAAI;QACpBrD,MAAM,EAAEjC,IAAI,CAACwJ,6MAAAA;KACd,CAAC;AAGG,MAAMC,eAAe,IAC1B3E,SAAsD,GACjB9D,OAAO,CAAC,IAAM,IAAIL,QAAQ,CAAC+I,qBAAqB,CAAC5E,SAAS,CAAC,CAAC,CAAC;AAEpG,cAAA,GACA,MAAM4E,qBAAqB,IACzB5E,SAAsD,GAEtD9E,IAAI,CAACiF,2MAAQ,CAAC;QACZrD,OAAO,GAAG6B,KAAsB,OAC9BrE,0LAAI,EACFqE,KAAK,EACL3E,MAAM,CAACoK,sLAAS,CAACpE,SAAS,CAAC,EAC3BhG,MAAM,CAACwC,gLAAG,EAAEsH,QAAQ,IAAI;gBACtB,MAAMG,IAAI,GAAGH,QAAQ,CAAClG,MAAM,KAAK,CAAC;gBAClC,OAAOqG,IAAI,GACTW,qBAAqB,CAAC5E,SAAS,CAAC,OAChC1F,0LAAI,EACFY,IAAI,CAAC6C,wMAAK,CAAClE,KAAK,CAACyG,4LAAe,CAACwD,QAAQ,CAAC,CAAC,EAC3C9I,OAAO,CAACuF,iMAAQ,CAACvF,OAAO,CAAC2I,wMAAe,EAA+B,CAAC,CACzE;YACL,CAAC,CAAC,EACF3I,OAAO,CAACuJ,+LAAM,CACf;QACHtH,SAAS,EAAE/B,IAAI,CAACsF,uMAAI;QACpBrD,MAAM,EAAEA,CAAA,GAAMjC,IAAI,CAACgJ,uMAAAA;KACpB,CAAC;AAGG,MAAMW,QAAQ,GAAA,WAAA,OAAGzK,0LAAI,EAS1B,CAAC,EACD,CAACkC,IAAI,EAAEwI,SAAS,GAAK,IAAIjJ,QAAQ,KAACvB,0LAAI,EAACgC,IAAI,EAAEF,SAAS,EAAEpB,OAAO,CAAC6J,iMAAQ,CAACC,SAAS,CAAC,CAAC,CAAC,CACtF;AAGM,MAAMC,YAAY,GAAA,WAAA,OAAG3K,0LAAI,EAS9B,CAAC,EACD,CAACkC,IAAI,EAAEwI,SAAS,GAAK,IAAIjJ,QAAQ,KAACvB,0LAAI,EAACgC,IAAI,EAAEF,SAAS,EAAElB,IAAI,CAAC6J,+MAAY,CAACD,SAAS,CAAC,CAAC,CAAC,CACvF;AAGM,MAAME,OAAO,GAAGA,CAAA,GAAkErE,UAAU,CAAC3G,MAAM,CAACgL,oLAAO,EAAK,CAAC;AAGjH,MAAMC,WAAW,IACtBvD,CAAqC,OACMpH,0LAAI,EAAC0K,OAAO,EAAK,EAAExI,GAAG,CAACkF,CAAC,CAAC,CAAC;AAGhE,MAAMwD,iBAAiB,IAC5BxD,CAA2D,OACfpH,0LAAI,EAAC0K,OAAO,EAAM,EAAEzB,SAAS,CAAC7B,CAAC,CAAC,CAAC;AAGxE,MAAMyD,eAAe,IAC1BzD,CAA8D,GAE9D,IAAI7F,QAAQ,CAACb,OAAO,CAACuJ,+LAAM,CAACvK,MAAM,CAACiL,wLAAW,EAAED,OAAO,GAAK5I,SAAS,CAACsF,CAAC,CAACsD,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;AAG/E,MAAMI,KAAK,IAAQpF,SAAwB,GAChDN,IAAI,CAAC,IAAI,EAAErF,8LAAQ,EAAE,CAACuC,GAAG,EAAE+B,KAAK,GAAK/B,GAAG,IAAIoD,SAAS,CAACrB,KAAK,CAAC,CAAC;AAGxD,MAAM6B,IAAI,IAAO6E,CAAI,GAA0C,IAAIxJ,QAAQ,CAACX,IAAI,CAACsF,uMAAI,CAAC6E,CAAC,CAAC,CAAC;AAGzF,MAAMC,QAAQ,IAAOnJ,QAAoB,GAC9C,IAAIN,QAAQ,CAACX,IAAI,CAACoK,2MAAQ,CAACnJ,QAAQ,CAAC,CAAC;AAGhC,MAAMe,SAAS,IAAOqI,KAAqB,GAChD,IAAI1J,QAAQ,CAACX,IAAI,CAACgC,4MAAS,CAACqI,KAAK,CAAC,CAAC;AAG9B,MAAMnC,aAAa,IAAOjH,QAAiC,GAChE,IAAIN,QAAQ,CAACX,IAAI,CAACkI,gNAAa,CAACjH,QAAQ,CAAC,CAAC;AAGrC,MAAMqJ,WAAW,IAKC9D,CAAiB,IAAI;IAC5C,QAAoBpF,IAA+B,OACjDhC,0LAAI,EAACgC,IAAI,EAAEkG,cAAc,CAAC3I,KAAK,CAAC4L,mLAAM,CAAC/D,CAAC,CAAC,CAAC,CAAC;AAC/C,CAAC;AAGM,MAAMgE,iBAAiB,GAAA,WAAA,OAAGtL,0LAAI,EASnC,CAAC,EACD,CAACkC,IAAI,EAAEoF,CAAC,GACNgB,oBAAoB,CAClBpG,IAAI,GACHS,KAAK,GAAK/C,MAAM,CAACwC,gLAAG,CAACxC,MAAM,CAACyL,mLAAM,CAAC1I,KAAK,EAAE2E,CAAC,CAAC,EAAE7H,KAAK,CAACyG,4LAAe,CAAC,CACtE,CACJ;AAGM,MAAMqF,UAAU,GAAA,WAAA,OAAGvL,0LAAI,EAS5B,CAAC,EACD,CACEkC,IAA+B,EAC/BoF,CAA2C,KACW;IACtD,MAAMR,UAAU,OAAG5G,0LAAI,EACrBY,IAAI,CAACyF,6MAAU,KAACrG,0LAAI,EAClBQ,GAAG,CAACkG,iLAAI,CAACnH,KAAK,CAAC8C,kLAAK,EAAM,CAAC,EAC3B3C,MAAM,CAACiH,gLAAG,CAACnG,GAAG,CAACkG,iLAAI,CAAC,KAAK,CAAC,CAAC,CAC5B,CAAC,EACF9F,IAAI,CAAC4C,0MAAO,CAAC,CAAC,CAACqD,YAAY,EAAEC,eAAe,CAAC,KAAI;QAC/C,MAAMC,cAAc,GAAsFnG,IAAI,CAC3GiF,2MAAQ,CAAC;YACRrD,OAAO,GAAG6B,KAAK,OAAKrE,0LAAI,EAACY,IAAI,CAAC6C,wMAAK,CAACY,KAAK,CAAC,EAAEzD,IAAI,CAAC4C,0MAAO,CAAC,IAAMuD,cAAc,CAAC,CAAC;YAC/EpE,SAAS,EAAE/B,IAAI,CAACsF,uMAAI;YACpBrD,MAAM,GAAG+C,IAAI,OAAK5F,0LAAI,EAACY,IAAI,CAACyF,6MAAU,CAAC7F,GAAG,CAACkE,gLAAG,CAACoC,eAAe,EAAE,IAAI,CAAC,CAAC,EAAEpG,OAAO,CAACqB,2LAAE,CAAC6D,IAAI,CAAC;SACzF,CAAC;QACJ,MAAM0C,IAAI,GACR5H,OAAO,CAAC4G,oMAAW,CAAC1G,IAAI,CAACkH,kNAAe,CAAChG,SAAS,CAACE,IAAI,CAAC,CAAC,EAAE;YACzDW,SAAS,EAAE/B,IAAI,CAACsF,uMAAI;YACpBqB,SAAS,EAAEA,CAAC,CAACnE,SAAS,EAAEoE,SAAS,CAAC,OAChCxH,0LAAI,EACFY,IAAI,CAACyF,6MAAU,CAACe,CAAC,CAACI,SAAS,CAAC,CAAC,EAC7B5G,IAAI,CAAC4C,0MAAO,EAAE8H,SAAS,OACrBtL,0LAAI,EACFY,IAAI,CAACyF,6MAAU,CAAC7F,GAAG,CAACkE,gLAAG,CAACmC,YAAY,EAAEtH,KAAK,CAACkI,oLAAO,CAACrE,SAAS,CAAC,CAAC,CAAC,EAChE1C,OAAO,CAACuF,iMAAQ,KACdjG,0LAAI,EACFY,IAAI,CAACyF,6MAAU,CAAC7F,GAAG,CAACkH,gLAAG,CAACZ,eAAe,CAAC,CAAC,EACzClG,IAAI,CAAC4C,0MAAO,EAAEmE,YAAY,IAAI;wBAC5B,IAAI2D,SAAS,EAAE;4BACb,WAAOtL,0LAAI,EAACY,IAAI,CAAC6C,wMAAK,CAAClE,KAAK,CAACkI,oLAAO,CAACrE,SAAS,CAAC,CAAC,EAAE1C,OAAO,CAACqB,2LAAE,CAAC5B,MAAM,CAACoL,iLAAI,CAAC/D,SAAS,CAAC,CAAC,CAAC;wBACvF;wBACA,IAAIG,YAAY,EAAE;4BAChB,WAAO3H,0LAAI,EAACY,IAAI,CAAC6C,wMAAK,CAAClE,KAAK,CAACkI,oLAAO,CAACrE,SAAS,CAAC,CAAC,EAAE1C,OAAO,CAACqB,2LAAE,CAAC5B,MAAM,CAACqL,iLAAI,EAAE,CAAC,CAAC;wBAC9E;wBACA,OAAOlD,IAAI;oBACb,CAAC,CAAC,CACH,CACF,CACF,CACF;SAEN,CAAC;QACJ,WAAOtI,0LAAI,EAAC+G,cAAc,EAAEnG,IAAI,CAACoG,yMAAM,CAACtG,OAAO,CAACuG,oMAAW,CAACJ,YAAY,CAAC,CAAC,EAAEjG,IAAI,CAACoG,yMAAM,CAACsB,IAAI,CAAC,CAAC;IAChG,CAAC,CAAC,CACH;IACD,OAAO,IAAI/G,QAAQ,CAACqF,UAAU,CAAC;AACjC,CAAC,CACF;AAGM,MAAMxB,IAAI,GAAGA,CAClBqG,CAAI,EACJC,MAAoB,EACpBtE,CAAyB,GACAxF,OAAO,CAAC,IAAM,IAAIL,QAAQ,CAACoK,UAAU,CAACF,CAAC,EAAEC,MAAM,EAAEtE,CAAC,CAAC,CAAC,CAAC;AAEhF,cAAA,GACA,MAAMuE,UAAU,GAAGA,CACjBF,CAAI,EACJC,MAAoB,EACpBtE,CAAyB,KACsD;IAC/E,IAAI,CAACsE,MAAM,CAACD,CAAC,CAAC,EAAE;QACd,OAAO7K,IAAI,CAACwJ,6MAAU,CAACqB,CAAC,CAAC;IAC3B;IACA,OAAO7K,IAAI,CAACiF,2MAAQ,CAAC;QACnBrD,OAAO,GAAG6B,KAAsB,IAAI;YAClC,MAAM,CAACuH,KAAK,EAAExI,SAAS,CAAC,GAAGyI,cAAc,CAACJ,CAAC,EAAEpH,KAAK,EAAEqH,MAAM,EAAEtE,CAAC,EAAE,CAAC,EAAE/C,KAAK,CAACf,MAAM,CAAC;YAC/E,IAAI/D,KAAK,CAACuM,uLAAU,CAAC1I,SAAS,CAAC,EAAE;gBAC/B,WAAOpD,0LAAI,EAACY,IAAI,CAAC6C,wMAAK,CAACL,SAAS,CAAC,EAAE1C,OAAO,CAACqB,2LAAE,CAAC6J,KAAK,CAAC,CAAC;YACvD;YACA,OAAOD,UAAU,CAACC,KAAK,EAAEF,MAAM,EAAEtE,CAAC,CAAC;QACrC,CAAC;QACDzE,SAAS,EAAE/B,IAAI,CAACsF,uMAAI;QACpBrD,MAAM,EAAEA,CAAA,GAAMjC,IAAI,CAACwJ,6MAAU,CAACqB,CAAC;KAChC,CAAC;AACJ,CAAC;AAED,cAAA,GACA,MAAMI,cAAc,GAAGA,CACrBJ,CAAI,EACJhJ,KAAsB,EACtBiJ,MAAoB,EACpBtE,CAAyB,EACzB2E,KAAa,EACbzI,MAAc,KACU;IACxB,IAAIyI,KAAK,KAAKzI,MAAM,EAAE;QACpB,OAAO;YAACmI,CAAC;YAAElM,KAAK,CAAC8C,kLAAK,EAAE;SAAC;IAC3B;IACA,MAAM2J,EAAE,GAAG5E,CAAC,CAACqE,CAAC,MAAEzL,0LAAI,EAACyC,KAAK,EAAElD,KAAK,CAACkF,sLAAS,CAACsH,KAAK,CAAC,CAAC,CAAC;IACpD,IAAIL,MAAM,CAACM,EAAE,CAAC,EAAE;QACd,OAAOH,cAAc,CAACG,EAAE,EAAEvJ,KAAK,EAAEiJ,MAAM,EAAEtE,CAAC,EAAE2E,KAAK,GAAG,CAAC,EAAEzI,MAAM,CAAC;IAChE;IACA,OAAO;QAAC0I,EAAE;YAAEhM,0LAAI,EAACyC,KAAK,EAAElD,KAAK,CAACgH,iLAAI,CAACwF,KAAK,GAAG,CAAC,CAAC,CAAC;KAAC;AACjD,CAAC;AAGM,MAAME,QAAQ,GAAA,WAAA,OAAGnM,0LAAI,EAe1B,CAAC,EACD,CACEkC,IAA+B,EAC/BwE,OAGC,KAC+D;IAChE,MAAMI,UAAU,OAQZ5G,0LAAI,EACN8B,SAAS,CAACE,IAAI,CAAC,EACfpB,IAAI,CAACkH,kNAAe,EACpBpH,OAAO,CAAC4G,oMAAW,CAAC;QAClB3E,SAAS,GAAGuJ,KAAK,GAAKpK,SAAS,CAAC0E,OAAO,CAAC7D,SAAS,CAACuJ,KAAK,CAAC,CAAC;QACzD3E,SAAS,EAAEA,CAAC,CAACnE,SAAS,EAAE4E,CAAC,CAAC,GACxBpH,IAAI,CAACgB,0MAAO,CAAC,MAAK;gBAChB,MAAMiF,YAAY,GAAG;oBACnBsF,GAAG,MAAEnM,0LAAI,EAACoD,SAAS,EAAE7D,KAAK,CAAC4L,mLAAM,CAAC5L,KAAK,CAACuM,uLAAU,CAAC;iBACpD;gBACD,MAAMM,SAAS,OAAGpM,0LAAI,EACpBY,IAAI,CAACyL,uMAAI,CAAC,MAAK;oBACb,MAAMF,GAAG,GAAGtF,YAAY,CAACsF,GAAG;oBAC5BtF,YAAY,CAACsF,GAAG,GAAG5M,KAAK,CAAC8C,kLAAK,EAAE;oBAChC,OAAO8J,GAAG;gBACZ,CAAC,CAAC,EACF,yEAAA;gBACA,oEAAA;gBACAvL,IAAI,CAAC4C,0MAAO,EAAEf,KAAK,GAAK/B,OAAO,CAAC4L,mMAAU,CAAC7J,KAA4C,CAAC,CAAC,CAC1F;gBACD,MAAM8J,WAAW,GAAG7L,OAAO,CAAC2I,wMAAe,EAA0C;gBACrF,MAAMmD,gBAAgB,OAAGxM,0LAAI,EAC3BoM,SAAS,EACT1L,OAAO,CAACuF,iMAAQ,CAACsG,WAAW,CAAC,EAC7B3L,IAAI,CAACoG,yMAAM,CAAClF,SAAS,CAAC0E,OAAO,CAACe,SAAS,CAACS,CAAC,CAAC,CAAC,CAAC,CAC7C;gBACD,OAAOpH,IAAI,CAAC4C,0MAAO,CACjB5C,IAAI,CAACkH,kNAAe,CAAC0E,gBAAgB,CAAC,EACtC,CAAC,CAACC,YAAY,EAAEC,EAAE,CAAC,OACjB1M,0LAAI,EACFY,IAAI,CAACkC,0MAAO,CAAC+D,YAAY,CAACsF,GAAG,CAAC,EAC9BvL,IAAI,CAAC4C,0MAAO,CAAC9C,OAAO,CAAC4L,mMAAU,CAAC,EAChC5L,OAAO,CAACuF,iMAAQ,CAACvF,OAAO,CAAC4L,mMAAU,CAACG,YAAY,CAAC,CAAC,EAClD/L,OAAO,CAACqB,2LAAE,CAAC2K,EAAE,CAAC,CACf,CACJ;YACH,CAAC;KACJ,CAAC,CACH;IACD,OAAO,IAAInL,QAAQ,CAACqF,UAAU,CAAC;AACjC,CAAC,CACF;AAGM,MAAM+F,UAAU,GAAGA,CACxBlB,CAAI,EACJC,MAAoB,EACpBtE,CAAsC,GACjBxF,OAAO,CAAC,IAAM,IAAIL,QAAQ,CAACqL,gBAAgB,CAACnB,CAAC,EAAEC,MAAM,EAAEtE,CAAC,CAAC,CAAC,CAAC;AAElF,cAAA,GACA,MAAMwF,gBAAgB,GAAGA,CACvBnB,CAAI,EACJC,MAAoB,EACpBtE,CAAsC,KAC+B;IACrE,IAAI,CAACsE,MAAM,CAACD,CAAC,CAAC,EAAE;QACd,OAAO7K,IAAI,CAACwJ,6MAAU,CAACqB,CAAC,CAAC;IAC3B;IACA,OAAO7K,IAAI,CAACiF,2MAAQ,CAAC;QACnBrD,OAAO,GAAG6B,KAAsB,GAAKuI,gBAAgB,CAACxF,CAAC,CAACqE,CAAC,EAAEpH,KAAK,CAAC,EAAEqH,MAAM,EAAEtE,CAAC,CAAC;QAC7EzE,SAAS,EAAE/B,IAAI,CAACsF,uMAAI;QACpBrD,MAAM,EAAEA,CAAA,GAAMjC,IAAI,CAACwJ,6MAAU,CAACqB,CAAC;KAChC,CAAC;AACJ,CAAC;AAGM,MAAMoB,gBAAgB,GAAGA,CAC9BpB,CAAI,EACJC,MAAoB,EACpBtE,CAA2D,GAC5BxF,OAAO,CAAC,IAAM,IAAIL,QAAQ,CAACuL,sBAAsB,CAACrB,CAAC,EAAEC,MAAM,EAAEtE,CAAC,CAAC,CAAC,CAAC;AAElG,cAAA,GACA,MAAM0F,sBAAsB,GAAGA,CAC7BrB,CAAI,EACJC,MAAoB,EACpBtE,CAA2D,KACK;IAChE,IAAI,CAACsE,MAAM,CAACD,CAAC,CAAC,EAAE;QACd,OAAO7K,IAAI,CAACwJ,6MAAU,CAACqB,CAAC,CAAC;IAC3B;IACA,OAAO7K,IAAI,CAACiF,2MAAQ,CAAC;QACnBrD,OAAO,GAAG6B,KAAsB,OAC9BrE,0LAAI,EACFY,IAAI,CAACyF,6MAAU,CAACe,CAAC,CAACqE,CAAC,EAAEpH,KAAK,CAAC,CAAC,EAC5BzD,IAAI,CAAC4C,0MAAO,EAAEiI,CAAC,GAAKqB,sBAAsB,CAACrB,CAAC,EAAEC,MAAM,EAAEtE,CAAC,CAAC,CAAC,CAC1D;QACHzE,SAAS,EAAE/B,IAAI,CAACsF,uMAAI;QACpBrD,MAAM,EAAEA,CAAA,GAAMjC,IAAI,CAACwJ,6MAAU,CAACqB,CAAC;KAChC,CAAC;AACJ,CAAC;AAGM,MAAMlG,UAAU,GAAGA,CACxBkG,CAAI,EACJC,MAAoB,EACpBtE,CAA8C,GACfxF,OAAO,CAAC,IAAM,IAAIL,QAAQ,CAACwL,gBAAgB,CAACtB,CAAC,EAAEC,MAAM,EAAEtE,CAAC,CAAC,CAAC,CAAC;AAE5F,cAAA,GACA,MAAM2F,gBAAgB,GAAGA,CACvBtB,CAAI,EACJC,MAAoB,EACpBtE,CAA8C,KAC4B;IAC1E,IAAI,CAACsE,MAAM,CAACD,CAAC,CAAC,EAAE;QACd,OAAO7K,IAAI,CAACwJ,6MAAU,CAACqB,CAAC,CAAC;IAC3B;IACA,OAAO7K,IAAI,CAACiF,2MAAQ,CAAC;QACnBrD,OAAO,GAAG6B,KAAsB,OAC9BrE,0LAAI,EACFY,IAAI,CAACyF,6MAAU,CAAC2G,oBAAoB,CAACvB,CAAC,EAAEpH,KAAK,EAAEqH,MAAM,EAAEtE,CAAC,CAAC,CAAC,EAC1DxG,IAAI,CAAC4C,0MAAO,CAAC,CAAC,CAACoI,KAAK,EAAExI,SAAS,CAAC,OAC9BpD,0LAAI,EACFoD,SAAS,EACTjD,MAAM,CAAC8M,kLAAK,CAAC;oBACXC,MAAM,EAAEA,CAAA,GAAMH,gBAAgB,CAACnB,KAAK,EAAEF,MAAM,EAAEtE,CAAC,CAAC;oBAChD+F,MAAM,GAAG3D,QAAQ,OAAKxJ,0LAAI,EAACY,IAAI,CAAC6C,wMAAK,CAAC+F,QAAQ,CAAC,EAAE9I,OAAO,CAACqB,2LAAE,CAAC6J,KAAK,CAAC;iBACnE,CAAC,CACH,CACF,CACF;QACHjJ,SAAS,EAAE/B,IAAI,CAACsF,uMAAI;QACpBrD,MAAM,EAAEA,CAAA,GAAMjC,IAAI,CAACwJ,6MAAU,CAACqB,CAAC;KAChC,CAAC;AACJ,CAAC;AAED,cAAA,GACA,MAAMuB,oBAAoB,GAAGA,CAC3BvB,CAAI,EACJhJ,KAAsB,EACtBiJ,MAAoB,EACpBtE,CAA8C,GAE9CgG,4BAA4B,CAAC3B,CAAC,EAAEhJ,KAAK,EAAE,CAAC,EAAEA,KAAK,CAACa,MAAM,EAAEoI,MAAM,EAAEtE,CAAC,CAAC;AAEpE,cAAA,GACA,MAAMgG,4BAA4B,GAAGA,CACnC3B,CAAI,EACJhJ,KAAsB,EACtBsJ,KAAa,EACbzI,MAAc,EACdoI,MAAoB,EACpBtE,CAA8C,KACc;IAC5D,IAAI2E,KAAK,KAAKzI,MAAM,EAAE;QACpB,OAAO5D,MAAM,CAACoD,oLAAO,CAAC;YAAC2I,CAAC;YAAEtL,MAAM,CAACqL,iLAAI,EAAE;SAAC,CAAC;IAC3C;IACA,WAAOxL,0LAAI,EACToH,CAAC,CAACqE,CAAC,MAAEzL,0LAAI,EAACyC,KAAK,EAAElD,KAAK,CAACkF,sLAAS,CAACsH,KAAK,CAAC,CAAC,CAAC,EACzCrM,MAAM,CAAC8D,oLAAO,EAAEwI,EAAE,GAChBN,MAAM,CAACM,EAAE,CAAC,GACRoB,4BAA4B,CAACpB,EAAE,EAAEvJ,KAAK,EAAEsJ,KAAK,GAAG,CAAC,EAAEzI,MAAM,EAAEoI,MAAM,EAAEtE,CAAC,CAAC,GACrE1H,MAAM,CAACoD,oLAAO,CAAC;YAACkJ,EAAE;YAAE7L,MAAM,CAACoL,iLAAI,KAACvL,0LAAI,EAACyC,KAAK,EAAElD,KAAK,CAACgH,iLAAI,CAACwF,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC;SAAC,CAAC,CACxE,CACF;AACH,CAAC;AAGM,MAAMsB,QAAQ,GAAGA,CAAQ5B,CAAI,EAAErE,CAAyB,GAC7DkG,cAAc,CAAClI,IAAI,CAACqG,CAAC,EAAE5L,+LAAS,EAAEuH,CAAC,CAAC,CAAC;AAGhC,MAAMjD,cAAc,GAAGA,CAC5BsH,CAAI,EACJrE,CAAsC,GACjBuF,UAAU,CAAClB,CAAC,EAAE5L,+LAAS,EAAEuH,CAAC,CAAC;AAG3C,MAAMmG,oBAAoB,GAAGA,CAClC9B,CAAI,EACJrE,CAA2D,GACzBkG,cAAc,CAACT,gBAAgB,CAACpB,CAAC,EAAE5L,+LAAS,EAAEuH,CAAC,CAAC,CAAC;AAG9E,MAAMoG,cAAc,GAAGA,CAC5B/B,CAAI,EACJrE,CAA8C,GACf7B,UAAU,CAACkG,CAAC,EAAE5L,+LAAS,EAAEuH,CAAC,CAAC;AAGrD,MAAMqG,SAAS,GAAGA,CAAQhC,CAAI,EAAE/B,GAAW,EAAEtC,CAAyB,OAC3EpH,0LAAI,EACFoF,IAAI,CACF;QAACqG,CAAC;QAAE,CAAC;KAAC,GACLpG,KAAK,GAAKA,KAAK,CAAC,CAAC,CAAC,GAAGqE,GAAG,EACzB,CAAC,CAACgE,MAAM,EAAEC,KAAK,CAAC,EAAEtJ,KAAK,GAAK;YAAC+C,CAAC,CAACsG,MAAM,EAAErJ,KAAK,CAAC;YAAEsJ,KAAK,GAAG,CAAC;SAAC,CAC1D,EACDzL,GAAG,EAAEmD,KAAK,GAAKA,KAAK,CAAC,CAAC,CAAC,CAAC,CACzB;AAGI,MAAMuI,eAAe,GAAGA,CAC7BnC,CAAI,EACJ/B,GAAW,EACXtC,CAA8C,OAE9CpH,0LAAI,EACFuF,UAAU,CACR;QAACkG,CAAC;QAAE,CAAW;KAAU,GACxBpG,KAAK,GAAKA,KAAK,CAAC,CAAC,CAAC,GAAGqE,GAAG,EACzB,CAAC,CAACgE,MAAM,EAAEC,KAAK,CAAC,EAAEtJ,KAAS,OAAKrE,0LAAI,EAACoH,CAAC,CAACsG,MAAM,EAAErJ,KAAK,CAAC,EAAE3E,MAAM,CAACwC,gLAAG,EAAEuJ,CAAC,GAAK;gBAACA,CAAC;gBAAEkC,KAAK,GAAG,CAAC;aAAU,CAAC,CAAC,CACnG,EACDzL,GAAG,EAAEmD,KAAK,GAAKA,KAAK,CAAC,CAAC,CAAC,CAAC,CACzB;AAGI,MAAMT,YAAY,IACvB4B,OAKC,GAEDqH,qBAAqB,CAAC;QACpB,GAAGrH,OAAO;QACVsH,SAAS,EAAEvO,KAAK,CAACwO,+KAAAA;KAClB,CAAC;AAGG,MAAMF,qBAAqB,IAChCrH,OAMC,GAED5E,OAAO,CAAC,IACN,IAAIL,QAAQ,CACVyM,yBAAyB,CACvBxH,OAAO,CAAC5C,OAAO,EACf,CAAC,EACD,KAAK,EACL4C,OAAO,CAAC3B,OAAO,EACf2B,OAAO,CAAC1B,IAAI,EACZ0B,OAAO,CAACsH,SAAS,EACjBtH,OAAO,CAAC1C,IAAI,CACb,CACF,CACF;AAEH,cAAA,GACA,MAAMkK,yBAAyB,GAAGA,CAChCvC,CAAI,EACJ3G,IAAY,EACZmJ,KAAc,EACdvE,GAAW,EACXwE,MAAmC,EACnCJ,SAAyC,EACzC1G,CAAyB,GAEzBxG,IAAI,CAACiF,2MAAQ,CAAC;QACZrD,OAAO,GAAG6B,KAAsB,IAAI;YAClC,MAAM,CAACuH,KAAK,EAAEuC,QAAQ,EAAEC,SAAS,EAAEhL,SAAS,CAAC,GAAGiL,yBAAyB,CACvEhK,KAAK,EACLoH,CAAC,EACD3G,IAAI,EACJmJ,KAAK,EACLvE,GAAG,EACHwE,MAAM,EACNJ,SAAS,EACT1G,CAAC,CACF;YACD,IAAI7H,KAAK,CAACuM,uLAAU,CAAC1I,SAAS,CAAC,EAAE;gBAC/B,WAAOpD,0LAAI,EAACY,IAAI,CAAC6C,wMAAK,CAACL,SAAS,CAAC,EAAE1C,OAAO,CAACuF,iMAAQ,CAACrF,IAAI,CAACwJ,6MAAU,CAACwB,KAAK,CAAC,CAAC,CAAC;YAC9E;YACA,IAAI9G,IAAI,GAAG4E,GAAG,EAAE;gBACd,OAAO9I,IAAI,CAACwJ,6MAAU,CAACwB,KAAK,CAAC;YAC/B;YACA,OAAOoC,yBAAyB,CAACpC,KAAK,EAAEuC,QAAQ,EAAEC,SAAS,EAAE1E,GAAG,EAAEwE,MAAM,EAAEJ,SAAS,EAAE1G,CAAC,CAAC;QACzF,CAAC;QACDzE,SAAS,EAAE/B,IAAI,CAACsF,uMAAI;QACpBrD,MAAM,EAAEA,CAAA,GAAMjC,IAAI,CAACwJ,6MAAU,CAACqB,CAAC;KAChC,CAAC;AAEJ,cAAA,GACA,MAAM4C,yBAAyB,GAAGA,CAChChK,KAAsB,EACtBoH,CAAI,EACJ3G,IAAY,EACZmJ,KAAc,EACdvE,GAAW,EACXwE,MAAmC,EACnCJ,SAAyC,EACzC1G,CAAyB,KACgB;IACzC,IAAK,IAAI2E,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG1H,KAAK,CAACf,MAAM,EAAEyI,KAAK,EAAE,CAAE;QACjD,MAAMuC,IAAI,GAAG/O,KAAK,CAACkF,sLAAS,CAACJ,KAAK,EAAE0H,KAAK,CAAC;QAC1C,MAAMwC,QAAQ,GAAGzJ,IAAI;QACrBA,IAAI,GAAGA,IAAI,GAAGoJ,MAAM,CAACzC,CAAC,EAAE6C,IAAI,CAAC;QAC7B,IAAIxJ,IAAI,IAAI4E,GAAG,EAAE;YACf+B,CAAC,GAAGrE,CAAC,CAACqE,CAAC,EAAE6C,IAAI,CAAC;YACdL,KAAK,GAAG,IAAI;YACZ;QACF;QACA,MAAMO,UAAU,GAAGV,SAAS,CAACQ,IAAI,CAAC;QAClC,IAAIE,UAAU,CAAClL,MAAM,IAAI,CAAC,IAAI,CAAC2K,KAAK,EAAE;YACpC,2EAAA;YACA,4EAAA;YACA,oCAAA;YACA,OAAO;gBAAC7G,CAAC,CAACqE,CAAC,EAAE6C,IAAI,CAAC;gBAAExJ,IAAI;gBAAE,IAAI;gBAAEvF,KAAK,CAACgH,iLAAI,CAAClC,KAAK,EAAE0H,KAAK,GAAG,CAAC,CAAC;aAAC;QAC/D;QACA,IAAIyC,UAAU,CAAClL,MAAM,IAAI,CAAC,IAAI2K,KAAK,EAAE;YACnC,yEAAA;YACA,uCAAA;YACA,OAAO;gBAACxC,CAAC;gBAAE8C,QAAQ;gBAAEN,KAAK;gBAAE1O,KAAK,CAACgH,iLAAI,CAAClC,KAAK,EAAE0H,KAAK,CAAC;aAAC;QACvD;QACA,gFAAA;QACA,uEAAA;QACA1H,KAAK,GAAG9E,KAAK,CAACmD,sLAAS,CAAC8L,UAAU,EAAEjP,KAAK,CAACgH,iLAAI,CAAClC,KAAK,EAAE0H,KAAK,GAAG,CAAC,CAAC,CAAC;QACjEjH,IAAI,GAAGyJ,QAAQ;QACfxC,KAAK,GAAG,CAAC,CAAC;IACZ;IACA,OAAO;QAACN,CAAC;QAAE3G,IAAI;QAAEmJ,KAAK;QAAE1O,KAAK,CAAC8C,kLAAK,EAAM;KAAC;AAC5C,CAAC;AAGM,MAAMoM,2BAA2B,IACtCjI,OAMC,GAED5E,OAAO,CAAC,IACN,IAAIL,QAAQ,CACVmN,+BAA+B,CAC7BlI,OAAO,CAAC5C,OAAO,EACf4C,OAAO,CAAC3B,OAAO,EACf2B,OAAO,CAAC1B,IAAI,EACZ0B,OAAO,CAACsH,SAAS,EACjBtH,OAAO,CAAC1C,IAAI,EACZ,CAAC,EACD,KAAK,CACN,CACF,CACF;AAGI,MAAM6K,kBAAkB,IAC7BnI,OAKC,GAEDiI,2BAA2B,CAAC;QAC1B,GAAGjI,OAAO;QACVsH,SAAS,GAAGzJ,KAAK,GAAK3E,MAAM,CAACoD,oLAAO,CAACvD,KAAK,CAACwO,+KAAE,CAAC1J,KAAK,CAAC;KACrD,CAAC;AAEJ,MAAMqK,+BAA+B,GAAGA,CACtCjD,CAAI,EACJ/B,GAAW,EACXwE,MAAwD,EACxDJ,SAAgE,EAChE1G,CAAgD,EAChDtC,IAAY,EACZmJ,KAAc,GAEdrN,IAAI,CAACiF,2MAAQ,CAAC;QACZrD,OAAO,GAAG6B,KAAsB,OAC9BrE,0LAAI,EACFY,IAAI,CAACyF,6MAAU,CAACuI,+BAA+B,CAACnD,CAAC,EAAE/B,GAAG,EAAEwE,MAAM,EAAEJ,SAAS,EAAE1G,CAAC,EAAE/C,KAAK,EAAE4J,KAAK,EAAEnJ,IAAI,EAAE,CAAC,CAAC,CAAC,EACrGlE,IAAI,CAAC4C,0MAAO,CAAC,CAAC,CAACoI,KAAK,EAAEuC,QAAQ,EAAEC,SAAS,EAAEhL,SAAS,CAAC,KAAI;gBACvD,IAAI7D,KAAK,CAACuM,uLAAU,CAAC1I,SAAS,CAAC,EAAE;oBAC/B,WAAOpD,0LAAI,EAACY,IAAI,CAAC6C,wMAAK,CAACL,SAAS,CAAC,EAAE1C,OAAO,CAACuF,iMAAQ,CAACrF,IAAI,CAACwJ,6MAAU,CAACwB,KAAK,CAAC,CAAC,CAAC;gBAC9E;gBACA,IAAI9G,IAAI,GAAG4E,GAAG,EAAE;oBACd,OAAO9I,IAAI,CAACwJ,6MAAU,CAACwB,KAAK,CAAC;gBAC/B;gBACA,OAAO8C,+BAA+B,CAAC9C,KAAK,EAAElC,GAAG,EAAEwE,MAAM,EAAEJ,SAAS,EAAE1G,CAAC,EAAE+G,QAAQ,EAAEC,SAAS,CAAC;YAC/F,CAAC,CAAC,CACH;QACHzL,SAAS,EAAE/B,IAAI,CAACsF,uMAAI;QACpBrD,MAAM,EAAEA,CAAA,GAAMjC,IAAI,CAACwJ,6MAAU,CAACqB,CAAC;KAChC,CAAC;AAEJ,cAAA,GACA,MAAMmD,+BAA+B,GAAGA,CACtCnD,CAAI,EACJ/B,GAAW,EACXwE,MAAwD,EACxDJ,SAAgE,EAChE1G,CAAgD,EAChD/C,KAAsB,EACtB4J,KAAc,EACdnJ,IAAY,EACZiH,KAAa,KACqE;IAClF,IAAIA,KAAK,KAAK1H,KAAK,CAACf,MAAM,EAAE;QAC1B,OAAO5D,MAAM,CAACoD,oLAAO,CAAC;YAAC2I,CAAC;YAAE3G,IAAI;YAAEmJ,KAAK;YAAE1O,KAAK,CAAC8C,kLAAK,EAAM;SAAC,CAAC;IAC5D;IACA,MAAMiM,IAAI,OAAGtO,0LAAI,EAACqE,KAAK,EAAE9E,KAAK,CAACkF,sLAAS,CAACsH,KAAK,CAAC,CAAC;IAChD,WAAO/L,0LAAI,EACTkO,MAAM,CAACzC,CAAC,EAAE6C,IAAI,CAAC,EACf5O,MAAM,CAACwC,gLAAG,EAAE2M,OAAO,GAAK/J,IAAI,GAAG+J,OAAO,CAAC,EACvCnP,MAAM,CAAC8D,oLAAO,EAAEsL,KAAK,IAAI;QACvB,IAAIA,KAAK,IAAIpF,GAAG,EAAE;YAChB,WAAO1J,0LAAI,EACToH,CAAC,CAACqE,CAAC,EAAE6C,IAAI,CAAC,EACV5O,MAAM,CAAC8D,oLAAO,EAAEiI,CAAC,GACfmD,+BAA+B,CAACnD,CAAC,EAAE/B,GAAG,EAAEwE,MAAM,EAAEJ,SAAS,EAAE1G,CAAC,EAAE/C,KAAK,EAAE,IAAI,EAAEyK,KAAK,EAAE/C,KAAK,GAAG,CAAC,CAAC,CAC7F,CACF;QACH;QACA,WAAO/L,0LAAI,EACT8N,SAAS,CAACQ,IAAI,CAAC,EACf5O,MAAM,CAAC8D,oLAAO,EAAEgL,UAAU,IAAI;YAC5B,IAAIA,UAAU,CAAClL,MAAM,IAAI,CAAC,IAAI,CAAC2K,KAAK,EAAE;gBACpC,2EAAA;gBACA,4EAAA;gBACA,oCAAA;gBACA,WAAOjO,0LAAI,EACToH,CAAC,CAACqE,CAAC,EAAE6C,IAAI,CAAC,EACV5O,MAAM,CAACwC,gLAAG,EAAEuJ,CAAC,GAAK;wBAACA,CAAC;wBAAEqD,KAAK;wBAAE,IAAI;4BAAE9O,0LAAI,EAACqE,KAAK,EAAE9E,KAAK,CAACgH,iLAAI,CAACwF,KAAK,GAAG,CAAC,CAAC,CAAC;qBAAC,CAAC,CACxE;YACH;YACA,IAAIyC,UAAU,CAAClL,MAAM,IAAI,CAAC,IAAI2K,KAAK,EAAE;gBACnC,yEAAA;gBACA,sCAAA;gBACA,OAAOvO,MAAM,CAACoD,oLAAO,CAAC;oBAAC2I,CAAC;oBAAE3G,IAAI;oBAAEmJ,KAAK;wBAAEjO,0LAAI,EAACqE,KAAK,EAAE9E,KAAK,CAACgH,iLAAI,CAACwF,KAAK,CAAC,CAAC;iBAAC,CAAC;YACzE;YACA,gFAAA;YACA,uEAAA;YACA,MAAMgD,IAAI,OAAG/O,0LAAI,EAACwO,UAAU,EAAEjP,KAAK,CAACmD,sLAAS,KAAC1C,0LAAI,EAACqE,KAAK,EAAE9E,KAAK,CAACgH,iLAAI,CAACwF,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;YAClF,OAAO6C,+BAA+B,CAACnD,CAAC,EAAE/B,GAAG,EAAEwE,MAAM,EAAEJ,SAAS,EAAE1G,CAAC,EAAE2H,IAAI,EAAEd,KAAK,EAAEnJ,IAAI,EAAE,CAAC,CAAC;QAC5F,CAAC,CAAC,CACH;IACH,CAAC,CAAC,CACH;AACH,CAAC;AAGM,MAAMtB,OAAO,GAAA,WAAA,OAAG1D,0LAAI,EASzB,CAAC,EACD,CAACkC,IAAI,EAAEoF,CAAC,GAAK6E,QAAQ,CAACjK,IAAI,EAAE;QAAEW,SAAS,EAAEuD,IAAI;QAAEqB,SAAS,EAAEH;IAAC,CAAE,CAAC,CAC/D;AAGM,MAAMiB,OAAO,IAAiBjB,CAAwC,IAAsC;IACjH,MAAM4H,OAAO,GAAoEpO,IAAI,CAAC2B,gNAAa,CAAC;QAClGC,OAAO,GAAG6B,KAAsB,OAC9BrE,0LAAI,EAACY,IAAI,CAACyF,6MAAU,CAAC3G,MAAM,CAAC2I,oLAAO,CAAChE,KAAK,GAAGE,CAAC,GAAK6C,CAAC,CAAC7C,CAAC,CAAC,EAAE;gBAAE0K,OAAO,EAAE;YAAI,CAAE,CAAC,CAAC,EAAErO,IAAI,CAAC4C,0MAAO,CAAC,IAAMwL,OAAO,CAAC,CAAC;QAC3GrM,SAAS,EAAE/B,IAAI,CAACgC,4MAAS;QACzBC,MAAM,EAAEA,CAAA,GAAMjC,IAAI,CAACgJ,uMAAAA;KACpB,CAAC;IACF,OAAO,IAAIrI,QAAQ,CAACyN,OAAO,CAAC;AAC9B,CAAC;AAGM,MAAME,YAAY,IACvB9H,CAAqD,IACjB;IACpC,MAAM4H,OAAO,GAAoEpO,IAAI,CAAC2B,gNAAa,CAAC;QAClGC,OAAO,GAAG6B,KAAsB,OAAKrE,0LAAI,EAACY,IAAI,CAACyF,6MAAU,CAACe,CAAC,CAAC/C,KAAK,CAAC,CAAC,EAAEzD,IAAI,CAAC4C,0MAAO,CAAC,IAAMwL,OAAO,CAAC,CAAC;QACjGrM,SAAS,EAAE/B,IAAI,CAACgC,4MAAS;QACzBC,MAAM,EAAEA,CAAA,GAAMjC,IAAI,CAACgJ,uMAAAA;KACpB,CAAC;IACF,OAAO,IAAIrI,QAAQ,CAACyN,OAAO,CAAC;AAC9B,CAAC;AAGM,MAAMG,YAAY,IACvB/H,CAA8C,IACb;IACjC,MAAM4H,OAAO,GAA8EpO,IAAI,CAAC2B,gNAAa,CAAC;QAC5GC,OAAO,GAAG6B,KAAsB,GAAK+K,kBAAkB,CAAChI,CAAC,EAAE/C,KAAK,EAAE,CAAC,EAAEA,KAAK,CAACf,MAAM,EAAE0L,OAAO,CAAC;QAC3FrM,SAAS,EAAE/B,IAAI,CAACgC,4MAAS;QACzBC,MAAM,EAAEA,CAAA,GAAMjC,IAAI,CAACgJ,uMAAAA;KACpB,CAAC;IACF,OAAO,IAAIrI,QAAQ,CAACyN,OAAO,CAAC;AAC9B,CAAC;AAED,cAAA,GACA,MAAMI,kBAAkB,GAAGA,CACzBhI,CAA8C,EAC9C/C,KAAsB,EACtB0H,KAAa,EACbzI,MAAc,EACd+L,IAA+E,KACF;IAC7E,IAAItD,KAAK,KAAKzI,MAAM,EAAE;QACpB,OAAO+L,IAAI;IACb;IACA,WAAOrP,0LAAI,EACTY,IAAI,CAACyF,6MAAU,CAACe,CAAC,KAACpH,0LAAI,EAACqE,KAAK,EAAE9E,KAAK,CAACkF,sLAAS,CAACsH,KAAK,CAAC,CAAC,CAAC,CAAC,EACvDnL,IAAI,CAAC4C,0MAAO,EAAEgC,IAAI,GAChBA,IAAI,GACF4J,kBAAkB,CAAChI,CAAC,EAAE/C,KAAK,EAAE0H,KAAK,GAAG,CAAC,EAAEzI,MAAM,EAAE+L,IAAI,CAAC,GACrDzO,IAAI,CAAC6C,wMAAK,KAACzD,0LAAI,EAACqE,KAAK,EAAE9E,KAAK,CAACgH,iLAAI,CAACwF,KAAK,CAAC,CAAC,CAAC,CAC7C,EACDrL,OAAO,CAAC4O,iMAAQ,EAAEpD,KAAK,OAAKlM,0LAAI,EAACY,IAAI,CAAC6C,wMAAK,KAACzD,0LAAI,EAACqE,KAAK,EAAE9E,KAAK,CAACgH,iLAAI,CAACwF,KAAK,CAAC,CAAC,CAAC,EAAErL,OAAO,CAACuF,iMAAQ,CAACrF,IAAI,CAACsF,uMAAI,CAACgG,KAAK,CAAC,CAAC,CAAC,CAAC,CAClH;AACH,CAAC;AAGM,MAAMqD,iBAAiB,IAC5BnI,CAA2D,IAC1B;IACjC,MAAMoI,MAAM,GAAoE5O,IAAI,CAACiF,2MAAQ,CAAC;QAC5FrD,OAAO,GAAG6B,KAAsB,OAC9BrE,0LAAI,EACFY,IAAI,CAACyF,6MAAU,CAACe,CAAC,CAAC/C,KAAK,CAAC,CAAC,EACzBzD,IAAI,CAAC4C,0MAAO,EAAE6L,IAAI,GAAKA,IAAI,GAAGG,MAAM,GAAG5O,IAAI,CAACgJ,uMAAI,CAAC,CAClD;QACHjH,SAAS,EAAE/B,IAAI,CAACsF,uMAAI;QACpBrD,MAAM,EAAEA,CAAA,GAAMjC,IAAI,CAACgJ,uMAAAA;KACpB,CAAC;IACF,OAAO,IAAIrI,QAAQ,CAACiO,MAAM,CAAC;AAC7B,CAAC;AAGM,MAAMvM,WAAW,IACtBvC,OAAkF,GACpD,IAAIa,QAAQ,CAACb,OAAO,CAAC;AAG9C,MAAM2F,UAAU,IAAaoJ,MAA8B,GAChE,IAAIlO,QAAQ,CAACX,IAAI,CAACyF,6MAAU,CAACoJ,MAAM,CAAC,CAAC;AAGhC,MAAMC,UAAU,GAAGA,CACxBC,MAAyB,EACzBnJ,OAEC,GACuBoJ,SAAS,CAACD,MAAM,EAAEnJ,OAAO,CAAC;AAG7C,MAAMqJ,QAAQ,IACnBC,IAIC,GAED,IAAIvO,QAAQ,CAACb,OAAO,CAACqP,qMAAY,KAAC/P,0LAAI,EAAC8P,IAAI,EAAEpQ,MAAM,CAACwC,gLAAG,CAAC8N,YAAY,CAAC,CAAC,CAAC,CAAC;AAE1E,MAAMA,YAAY,IAChBF,IAE2E,GAE3ElP,IAAI,CAACiF,2MAAQ,CAAC;QACZrD,OAAO,GAAG6B,KAAsB,GAC9B3D,OAAO,CAAC4G,oMAAW,CAAC1G,IAAI,CAACyF,6MAAU,CAACyJ,IAAI,CAAC3P,MAAM,CAACoL,iLAAI,CAAClH,KAAK,CAAC,CAAC,CAAC,EAAE;gBAC7D1B,SAAS,EAAEA,CAAC,CAACsN,MAAM,EAAE7M,SAAS,CAAC,GAC7BzD,MAAM,CAACsN,kLAAK,CAACgD,MAAM,EAAE;wBACnBC,MAAM,GAAGhE,KAAK,OAAKlM,0LAAI,EAACY,IAAI,CAAC6C,wMAAK,CAACL,SAAS,CAAC,EAAE1C,OAAO,CAACuF,iMAAQ,CAACrF,IAAI,CAACsF,uMAAI,CAACgG,KAAK,CAAC,CAAC,CAAC;wBAClFiE,OAAO,GAAGnI,CAAC,OAAKhI,0LAAI,EAACY,IAAI,CAAC6C,wMAAK,CAACL,SAAS,CAAC,EAAE1C,OAAO,CAACuF,iMAAQ,CAACrF,IAAI,CAACwJ,6MAAU,CAACpC,CAAC,CAAC,CAAC;qBACjF,CAAC;gBACJT,SAAS,EAAEA,CAAA,GAAMyI,YAAY,CAACF,IAAI;aACnC,CAAC;QACJnN,SAAS,EAAE/B,IAAI,CAACsF,uMAAI;QACpBrD,MAAM,EAAEA,CAAA,GACNnC,OAAO,CAAC4G,oMAAW,CAAC1G,IAAI,CAACyF,6MAAU,CAACyJ,IAAI,CAAC3P,MAAM,CAACqL,iLAAI,EAAE,CAAC,CAAC,EAAE;gBACxD7I,SAAS,EAAEA,CAAC,CAACsN,MAAM,EAAE7M,SAAS,CAAC,GAC7BzD,MAAM,CAACsN,kLAAK,CAACgD,MAAM,EAAE;wBACnBC,MAAM,GAAGhE,KAAK,OAAKlM,0LAAI,EAACY,IAAI,CAAC6C,wMAAK,CAACL,SAAS,CAAC,EAAE1C,OAAO,CAACuF,iMAAQ,CAACrF,IAAI,CAACsF,uMAAI,CAACgG,KAAK,CAAC,CAAC,CAAC;wBAClFiE,OAAO,GAAGnI,CAAC,OAAKhI,0LAAI,EAACY,IAAI,CAAC6C,wMAAK,CAACL,SAAS,CAAC,EAAE1C,OAAO,CAACuF,iMAAQ,CAACrF,IAAI,CAACwJ,6MAAU,CAACpC,CAAC,CAAC,CAAC;qBACjF,CAAC;gBACJT,SAAS,EAAEA,CAAA,GACT3G,IAAI,CAACyF,6MAAU,CACb3G,MAAM,CAACgJ,uLAAU,CACf,2FAA2F,CAC5F;aAEN;KACJ,CAAC;AAGG,MAAMkH,SAAS,GAAGA,CACvBQ,KAAwB,EACxB5J,OAEC,GAEDA,OAAO,EAAE6J,QAAQ,GACfN,YAAY,CACVrQ,MAAM,CAACwC,gLAAG,CACRxC,MAAM,CAAC4Q,2LAAc,CAAC5Q,MAAM,CAACoD,oLAAO,CAACsN,KAAK,CAAC,EAAE7P,KAAK,CAAC8P,qLAAQ,CAAC,EAC5DT,SAAS,CACV,CACF,GACDV,YAAY,EAAE7K,KAAsB,GAAK9D,KAAK,CAACgQ,qLAAQ,CAACH,KAAK,EAAE/L,KAAK,CAAC,CAAC;AAGnE,MAAMmM,IAAI,GAAGA,CAAA,GAClBpL,IAAI,CACFjF,MAAM,CAACqL,iLAAI,EAAuB,EAClCrL,MAAM,CAACsQ,mLAAM,EACb,CAACC,MAAM,EAAErM,KAAK,GACZlE,MAAM,CAAC8M,kLAAK,CAACyD,MAAM,EAAE;YACnBxD,MAAM,EAAEA,CAAA,GAAM/M,MAAM,CAACoL,iLAAI,CAAClH,KAAK,CAAC;YAChC8I,MAAM,EAAEA,CAAA,GAAMuD;SACf,CAAC,CACL;AAGI,MAAMpD,cAAc,IAAoBtL,IAA+B,GAC5E,IAAIT,QAAQ,CAACb,OAAO,CAAC0I,8LAAK,CAACtH,SAAS,CAACE,IAAI,CAAC,CAAC,CAAC;AAGvC,MAAM2O,IAAI,GAAGA,CAAA,GAClBxM,cAAc,CAAChE,MAAM,CAACqL,iLAAI,EAAM,EAAE,CAACC,CAAC,EAAEpH,KAAK,GAAKlE,MAAM,CAACyQ,mLAAM,CAACrR,KAAK,CAACoR,iLAAI,CAACtM,KAAK,CAAC,EAAE,IAAMoH,CAAC,CAAC,CAAC;AAGrF,MAAMjC,QAAQ,IAAO/G,KAAqB,GAC/C,IAAIlB,QAAQ,CAACX,IAAI,CAACgB,0MAAO,CAAC,IAAMhB,IAAI,CAAC6C,wMAAK,CAAChB,KAAK,CAAC,CAAC,CAAC;AAG9C,MAAMP,GAAG,GAAA,WAAA,OAAGpC,0LAAI,EAGrB,CAAC,EAAE,CAACkC,IAAI,EAAEoF,CAAC,KAAI;IACf,OAAO,IAAI7F,QAAQ,KAACvB,0LAAI,EAAC8B,SAAS,CAACE,IAAI,CAAC,EAAEtB,OAAO,CAACwB,4LAAG,CAACkF,CAAC,CAAC,CAAC,CAAC;AAC5D,CAAC,CAAC;AAGK,MAAM6B,SAAS,GAAA,WAAA,OAAGnJ,0LAAI,EAS3B,CAAC,EACD,CAACkC,IAAI,EAAEoF,CAAC,GAAK,IAAI7F,QAAQ,KAACvB,0LAAI,EAAC8B,SAAS,CAACE,IAAI,CAAC,EAAEtB,OAAO,CAACuI,kMAAS,CAAC7B,CAAC,CAAC,CAAC,CAAC,CACvE;AAGM,MAAMyJ,QAAQ,GAAA,WAAA,OAAG/Q,0LAAI,EAI1B,CAAC,EACD,CAACkC,IAAI,EAAEoF,CAAC,GAAK,IAAI7F,QAAQ,KAACvB,0LAAI,EAAC8B,SAAS,CAACE,IAAI,CAAC,EAAEtB,OAAO,CAACmQ,iMAAQ,CAACzJ,CAAC,CAAC,CAAC,CAAC,CACtE;AAGM,MAAM0J,WAAW,GAAA,WAAA,OAAGhR,0LAAI,EAI7B,CAAC,EACD,CAACkC,IAAI,EAAEoF,CAAC,GAAK,IAAI7F,QAAQ,KAACvB,0LAAI,EAAC8B,SAAS,CAACE,IAAI,CAAC,EAAEtB,OAAO,CAACqQ,+LAAM,CAACxR,KAAK,CAAC2C,gLAAG,CAACkF,CAAC,CAAC,CAAC,CAAC,CAAC,CAC/E;AAGM,MAAM4J,KAAK,GAAA,WAAA,GAA8B3K,UAAU,CAAC3G,MAAM,CAACsR,kLAAK,CAAC;AAGjE,MAAMJ,MAAM,GAAA,WAAA,OAAG9Q,0LAAI,EASxB,CAAC,EACD,CACEkC,IAA+B,EAC/BiP,IAA6C,GAE7C,IAAI1P,QAAQ,KACVvB,0LAAI,EAAC8B,SAAS,CAACE,IAAI,CAAC,EAAEtB,OAAO,CAACkQ,+LAAM,CAAC,IAAM9O,SAAS,CAACmP,IAAI,EAAE,CAAC,CAAC,CAAC,CAC/D,CACJ;AAGM,MAAMC,cAAc,GAAA,WAAA,OAAGpR,0LAAI,EAIhC,CAAC,EACD,CAACkC,IAAI,EAAE0I,OAAO,GAAK,IAAInJ,QAAQ,KAACvB,0LAAI,EAAC8B,SAAS,CAACE,IAAI,CAAC,EAAEpB,IAAI,CAACsQ,iNAAc,CAACxG,OAAO,CAAC,CAAC,CAAC,CACrF;AAGM,MAAMyG,IAAI,GAAA,WAAA,OAAGrR,0LAAI,EAStB,CAAC,EACD,CAACkC,IAAI,EAAEiP,IAAI,OAAKjR,0LAAI,EAACgC,IAAI,EAAEoP,QAAQ,CAACH,IAAI,CAAC,EAAE/O,GAAG,CAACvC,MAAM,CAACuE,kLAAK,CAAC,CAAC,CAC9D;AAGM,MAAMkN,QAAQ,GAAA,WAAA,OAAGtR,0LAAI,GAiBzBuR,IAAI,GAAK3P,MAAM,CAAC2P,IAAI,CAAC,CAAC,CAAC,CAAC,EACzB,CAACrP,IAAI,EAAEiP,IAAI,EAAEzK,OAAO,GAClB8K,QAAQ,CAACtP,IAAI,EAAE;QACbuP,KAAK,EAAEN,IAAI;QACXO,UAAU,GAAGC,QAAQ,GAAK9Q,aAAa,CAAC+Q,wMAAI,CAAChS,MAAM,CAACwC,gLAAG,CAACuP,QAAQ,EAAE9R,MAAM,CAACgS,iLAAI,CAAC,CAAC;QAC/EC,WAAW,GAAGC,QAAQ,GAAKlR,aAAa,CAAC+Q,wMAAI,CAAChS,MAAM,CAACwC,gLAAG,CAAC2P,QAAQ,EAAElS,MAAM,CAACmS,kLAAK,CAAC,CAAC;QACjFC,QAAQ,EAAEvL,OAAO,EAAEuL,QAAQ,IAAI;KAChC,CAAC,CACL;AAGM,MAAMT,QAAQ,GAAA,WAAA,OAAGxR,0LAAI,EAmB1B,CAAC,EACD,CACEkC,IAA+B,EAC/BwE,OAKC,KACuD;IACxD,SAAS2K,IAAIA,CAACa,KAAkB;QAC9B,OAAOtS,MAAM,CAACuS,gLAAG,CAAC,aAAS;YACzB,MAAMtC,MAAM,GAAG,OAAOrP,MAAM,CAAC4R,oLAAO,CAElC1L,OAAO,EAAEuL,QAAQ,IAAI,EAAE,CAAC;YAC1B,MAAMI,aAAa,GAAG,OAAO1R,KAAK,CAAC2R,mLAAM,CAAC9R,MAAM,CAAC+R,sLAAS,CAAC1C,MAAM,CAAC,EAAEqC,KAAK,CAAC;YAC1E,MAAMM,aAAa,GAAG,OAAO7R,KAAK,CAAC2R,mLAAM,CAAC9R,MAAM,CAAC+R,sLAAS,CAAC1C,MAAM,CAAC,EAAEqC,KAAK,CAAC;YAC1E,MAAMxC,MAAM,GAAG9O,OAAO,CAAC6R,iMAAQ,CAAC5C,MAAM,CAAC;YACvC,MAAM6C,MAAM,GAAG9R,OAAO,CAACkP,kMAAS,CAACuC,aAAa,CAAC,CAACnS,IAAI,CAClDY,IAAI,CAACoG,yMAAM,CAAClF,SAAS,CAACE,IAAI,CAAC,CAAC,EAC5BtB,OAAO,CAAC+R,gMAAO,CAAC7R,IAAI,CAACyF,6MAAU,CAAC9F,KAAK,CAAC8P,qLAAQ,CAAC8B,aAAa,CAAC,CAAC,CAAC,EAC/DzR,OAAO,CAACgS,kMAAS,CAAC;gBAChBnB,KAAK,EAAE7Q,OAAO,CAACkP,kMAAS,CAAC0C,aAAa,CAAC,CAACtS,IAAI,CAC1CY,IAAI,CAACoG,yMAAM,CAAClF,SAAS,CAAC0E,OAAO,CAAC+K,KAAK,CAAC,CAAC,EACrC7Q,OAAO,CAAC+R,gMAAO,CAAC7R,IAAI,CAACyF,6MAAU,CAAC9F,KAAK,CAAC8P,qLAAQ,CAACiC,aAAa,CAAC,CAAC,CAAC,CAChE;gBACDd,UAAU,EAAEhL,OAAO,CAACgL,UAAU;gBAC9BI,WAAW,EAAEpL,OAAO,CAACoL,WAAAA;aACtB,CAAC,CACH;YACD,MAAMe,YAAY,GAAGjS,OAAO,CAACgS,kMAAS,CAAClD,MAAM,EAAE;gBAC7C+B,KAAK,EAAEiB,MAAM;gBACbhB,UAAU,EAAEA,CAAA,GAAM7Q,aAAa,CAACiS,yMAAK,CAAC7S,8LAAQ,CAAC;gBAC/C6R,WAAW,GAAGiB,IAAI,GAAKlS,aAAa,CAAC+Q,wMAAI,CAACmB,IAAI;aAC/C,CAQA;YACD,OAAO,IAAItR,QAAQ,CAACoR,YAAY,CAAC;QACnC,CAAC,CAAC;IACJ;IACA,OAAOG,gBAAgB,CAAC3B,IAAI,CAAC;AAC/B,CAAC,CACF;AAGM,MAAM4B,WAAW,GAAA,WAAA,OAAGjT,0LAAI,EAS7B,CAAC,EACD,CAACkC,IAAI,EAAEgR,EAAE,OAAKhT,0LAAI,EAACgC,IAAI,EAAEiR,eAAe,CAACD,EAAE,EAAEjT,8LAAQ,CAAC,CAAC,CACxD;AAGM,MAAMkT,eAAe,GAAA,WAAA,OAAGnT,0LAAI,EAWjC,CAAC,EACD,CAACkC,IAAI,EAAEgR,EAAE,EAAE5L,CAAC,KAAI;IACd,MAAMR,UAAU,OAAG5G,0LAAI,EACrBgC,IAAI,EACJF,SAAS,EACTpB,OAAO,CAAC4O,iMAAQ,EAAEpD,KAAK,GACrB/L,MAAM,CAAC8M,kLAAK,CAAC+F,EAAE,CAAC9G,KAAK,CAAC,EAAE;YACtBgB,MAAM,EAAEA,CAAA,GAAMtM,IAAI,CAACkI,gNAAa,CAAC,IAAMxJ,KAAK,CAACkJ,gLAAG,CAACpB,CAAC,CAAC8E,KAAK,CAAC,CAAC,CAAC;YAC3DiB,MAAM,EAAEvM,IAAI,CAACsF,uMAAAA;SACd,CAAC,CACH,CACF;IACD,OAAO,IAAI3E,QAAQ,CAACqF,UAAU,CAAC;AACjC,CAAC,CACF;AAGM,MAAMsM,OAAO,IAClBC,GAAsB,GACqBC,WAAW,CAACD,GAAG,EAAEpT,8LAAQ,CAAC;AAGhE,MAAMqT,WAAW,GAAGA,CACzBD,GAAsB,EACtB/L,CAAmC,GACQf,UAAU,CAAC3G,MAAM,CAACwC,gLAAG,CAACiR,GAAG,EAAE/L,CAAC,CAAC,CAAC;AAGpE,MAAMiM,iBAAiB,GAAGA,CAC/BF,GAAsB,EACtB/L,CAAwD,GACbf,UAAU,CAAC3G,MAAM,CAAC8D,oLAAO,CAAC2P,GAAG,EAAE/L,CAAC,CAAC,CAAC;AAGxE,MAAMkM,eAAe,GAAGA,CAC7BH,GAAsB,EACtB/L,CAA2D,GAE3D,IAAI7F,QAAQ,KAACvB,0LAAI,EAACN,MAAM,CAACwC,gLAAG,CAACiR,GAAG,GAAGD,OAAO,GAAKpR,SAAS,CAACsF,CAAC,CAAC8L,OAAO,CAAC,CAAC,CAAC,EAAExS,OAAO,CAACuJ,+LAAM,CAAC,CAAC;AAGlF,MAAMsB,IAAI,IAAQ7F,SAAwB,GAC/CN,IAAI,CAAC,KAAK,GAAGI,IAAI,GAAK,CAACA,IAAI,EAAE,CAAClD,GAAG,EAAE+B,KAAK,GAAK/B,GAAG,IAAIoD,SAAS,CAACrB,KAAK,CAAC,CAAC;AAGhE,MAAMkP,UAAU,GAAA,WAAA,OAAGzT,0LAAI,EAG5B,CAAC,EAAE,CAA4BkC,IAA+B,EAAEoF,CAAgB,KAAgC;IAChH,MAAMR,UAAU,OAAG5G,0LAAI,EACrBY,IAAI,CAACyF,6MAAU,CAAC7F,GAAG,CAACkG,iLAAI,CAACnH,KAAK,CAAC8C,kLAAK,EAAM,CAAC,CAAC,EAC5CzB,IAAI,CAAC4C,0MAAO,EAAE2I,GAAG,OACfnM,0LAAI,EACFwT,kBAAkB,CAAQ,KAAK,EAAErH,GAAG,EAAE/E,CAAC,CAAC,EACxC1G,OAAO,CAAC6H,qMAAY,CAACzG,SAAS,CAACE,IAAI,CAAC,CAAC,EACrCpB,IAAI,CAACkH,kNAAe,EACpBlH,IAAI,CAAC4C,0MAAO,CAAC,CAAC,CAACJ,SAAS,EAAE4E,CAAC,CAAC,OAC1BhI,0LAAI,EACFY,IAAI,CAACyF,6MAAU,CAAC7F,GAAG,CAACkH,gLAAG,CAACyE,GAAG,CAAC,CAAC,EAC7BvL,IAAI,CAAC4C,0MAAO,EAAEgG,QAAQ,OACpBxJ,0LAAI,EACFY,IAAI,CAAC6C,wMAAK,KAAkBzD,0LAAI,EAACwJ,QAAQ,EAAEjK,KAAK,CAACmD,sLAAS,CAACnD,KAAK,CAACkI,oLAAO,CAACrE,SAAS,CAAC,CAAC,CAAC,CAAC,EACtF1C,OAAO,CAACuF,iMAAQ,CAACrF,IAAI,CAACkC,0MAAO,CAACkF,CAAC,CAAC,CAAC,CAClC,CACF,CACF,CACF,CACF,CACF,CACF;IACD,OAAO,IAAIzG,QAAQ,CAACqF,UAAU,CAAC;AACjC,CAAC,CAAC;AAEF,cAAA,GACA,MAAM4M,kBAAkB,GAAGA,CACzBC,OAAgB,EAChBrQ,SAAkC,EAClCgE,CAAe,GAEfxG,IAAI,CAAC2B,gNAAa,CAAC;QACjBC,OAAO,GAAG6B,KAAK,IAAI;YACjB,IAAI9E,KAAK,CAACgE,oLAAO,CAACc,KAAK,CAAC,EAAE;gBACxB,OAAOmP,kBAAkB,CAACC,OAAO,EAAErQ,SAAS,EAAEgE,CAAC,CAAC;YAClD;YACA,IAAIqM,OAAO,EAAE;gBACX,MAAM1H,KAAK,GAAG2H,UAAU,CAACrP,KAAK,EAAE+C,CAAC,CAAC;gBAClC,IAAI2E,KAAK,KAAK,CAAC,CAAC,EAAE;oBAChB,OAAOrL,OAAO,CAACuF,iMAAQ,CACrBrF,IAAI,CAAC6C,wMAAK,CAACY,KAAK,CAAC,EACjBmP,kBAAkB,CAAO,IAAI,EAAEpQ,SAAS,EAAEgE,CAAC,CAAC,CAC7C;gBACH;gBACA,MAAM,CAACuK,IAAI,EAAEG,KAAK,CAAC,GAAGvS,KAAK,CAAC8D,oLAAO,CAACgB,KAAK,EAAE0H,KAAK,CAAC;gBACjD,OAAOrL,OAAO,CAACuF,iMAAQ,CACrBrF,IAAI,CAAC6C,wMAAK,CAACkO,IAAI,CAAC,EAChB/Q,IAAI,CAACyF,6MAAU,CAAC7F,GAAG,CAACkE,gLAAG,CAACtB,SAAS,EAAE0O,KAAK,CAAC,CAAC,CAC3C;YACH;YACA,MAAM/F,KAAK,GAAG2H,UAAU,CAACrP,KAAK,EAAE+C,CAAC,EAAE,CAAC,CAAC;YACrC,IAAI2E,KAAK,KAAK,CAAC,CAAC,EAAE;gBAChB,OAAOrL,OAAO,CAACuF,iMAAQ,CACrBrF,IAAI,CAAC6C,wMAAK,CAACY,KAAK,CAAC,EACjBmP,kBAAkB,CAAO,IAAI,EAAEpQ,SAAS,EAAEgE,CAAC,CAAC,CAC7C;YACH;YACA,MAAM,CAACuK,IAAI,EAAEG,KAAK,CAAC,OAAG9R,0LAAI,EAACqE,KAAK,EAAE9E,KAAK,CAAC8D,oLAAO,CAACoG,IAAI,CAACC,GAAG,CAACqC,KAAK,EAAE,CAAC,CAAC,CAAC,CAAC;YACpE,OAAOrL,OAAO,CAACuF,iMAAQ,CAACrF,IAAI,CAAC6C,wMAAK,CAACkO,IAAI,CAAC,EAAE/Q,IAAI,CAACyF,6MAAU,CAAC7F,GAAG,CAACkE,gLAAG,CAACtB,SAAS,EAAE0O,KAAK,CAAC,CAAC,CAAC;QACvF,CAAC;QACDnP,SAAS,EAAE/B,IAAI,CAACgC,4MAAS;QACzBC,MAAM,EAAEjC,IAAI,CAACkC,0MAAAA;KACd,CAAC;AAEJ,cAAA,GACA,MAAM4Q,UAAU,GAAGA,CAAI1R,IAAoB,EAAE0D,SAAuB,EAAEiO,IAAI,GAAG,CAAC,KAAY;IACxF,MAAMC,QAAQ,GAAG5R,IAAI,CAAClB,MAAM,CAAC8S,QAAQ,CAAC,EAAE;IACxC,IAAI7H,KAAK,GAAG,CAAC;IACb,IAAI8H,MAAM,GAAG,CAAC,CAAC;IACf,IAAI9E,IAA4B;IAChC,MAAO8E,MAAM,GAAG,CAAC,IAAA,CAAK9E,IAAI,GAAG6E,QAAQ,CAAC7E,IAAI,EAAE,CAAC,IAAI,CAACA,IAAI,CAACnJ,IAAI,CAAE;QAC3D,MAAM3D,CAAC,GAAG8M,IAAI,CAAC+E,KAAK;QACpB,IAAI/H,KAAK,IAAI4H,IAAI,IAAIjO,SAAS,CAACzD,CAAC,CAAC,EAAE;YACjC4R,MAAM,GAAG9H,KAAK;QAChB;QACAA,KAAK,GAAGA,KAAK,GAAG,CAAC;IACnB;IACA,OAAO8H,MAAM;AACf,CAAC;AAGM,MAAM/Q,OAAO,IAAOb,CAAI,GAA4B,IAAIV,QAAQ,CAACX,IAAI,CAACkC,0MAAO,CAACb,CAAC,CAAC,CAAC;AAGjF,MAAM8R,GAAG,GAAA,WAAA,GAA8B5P,cAAc,CAC1D,CAAC,EACD,CAAC7B,GAAG,EAAEG,KAAK,GAAKH,GAAG,GAAG/C,KAAK,CAAC6E,mLAAM,CAAC3B,KAAK,EAAE,CAAC,EAAE,CAACgJ,CAAC,EAAExJ,CAAC,GAAKwJ,CAAC,GAAGxJ,CAAC,CAAC,CAC9D;AAGM,MAAM+R,UAAU,GAAA,WAAA,OAAGlU,0LAAI,EAW5B,CAAC,EACD,CAACkC,IAAI,EAAEiS,OAAO,EAAE7M,CAAC,KAAI;IACnB,MAAMR,UAAU,OAAG5G,0LAAI,EACrBY,IAAI,CAACyF,6MAAU,CAAC4N,OAAO,CAAC,EACxBrT,IAAI,CAAC4C,0MAAO,EAAE0Q,KAAK,OACjBlU,0LAAI,EACFgC,IAAI,EACJF,SAAS,EACTlB,IAAI,CAAC4C,0MAAO,EAAEoC,IAAI,OAChB5F,0LAAI,EACFY,IAAI,CAACyF,6MAAU,CAAC4N,OAAO,CAAC,EACxBvT,OAAO,CAACwB,4LAAG,EAAEiS,GAAG,GAAK;oBAACvO,IAAI;oBAAEwB,CAAC,CAAC8M,KAAK,EAAEC,GAAG,CAAC;iBAAC,CAAC,CAC5C,CACF,CACF,CACF,CACF;IACD,OAAO,IAAI5S,QAAQ,CAACqF,UAAU,CAAC;AACjC,CAAC,CACF;AAGM,MAAMyF,IAAI,IAAOxK,QAAoB,GAA4B,IAAIN,QAAQ,CAACX,IAAI,CAACyL,uMAAI,CAACxK,QAAQ,CAAC,CAAC;AAGlG,MAAMuS,IAAI,IAAQpR,CAAS,OAChChD,0LAAI,EACF2M,UAAU,CACRpN,KAAK,CAAC8C,kLAAK,EAAE,GACZI,KAAK,GAAKA,KAAK,CAACa,MAAM,GAAGN,CAAC,EAC3B,CAACV,GAAG,EAAEG,KAAK,OAAKzC,0LAAI,EAACsC,GAAG,EAAE/C,KAAK,CAACmD,sLAAS,CAACD,KAAK,CAAC,CAAC,CAClD,EACDe,OAAO,EAAElB,GAAG,IAAI;QACd,MAAM,CAAC+R,KAAK,EAAE7K,QAAQ,CAAC,OAAGxJ,0LAAI,EAACsC,GAAG,EAAE/C,KAAK,CAAC8D,oLAAO,CAACL,CAAC,CAAC,CAAC;QACrD,OAAO,IAAIzB,QAAQ,KAACvB,0LAAI,EAACY,IAAI,CAAC6C,wMAAK,CAAC+F,QAAQ,CAAC,EAAE9I,OAAO,CAACuF,iMAAQ,CAACrF,IAAI,CAACwJ,6MAAU,CAACiK,KAAK,CAAC,CAAC,CAAC,CAAC;IAC3F,CAAC,CAAC,CACH;AAGI,MAAMvS,SAAS,IACpBE,IAA+B,GAE/BtC,MAAM,CAAC4U,qLAAQ,CAACtS,IAAI,CAAC,GACnBF,SAAS,CAACuE,UAAU,CAACrE,IAA8B,CAAC,CAAC,GACpDA,IAAiC,CAACtB,OAAO;AAGvC,MAAMuJ,MAAM,IACjBwF,MAAwD,GAExD,IAAIlO,QAAQ,CACVb,OAAO,CAACuJ,+LAAM,KAACjK,0LAAI,EAACyP,MAAM,EAAE/P,MAAM,CAACwC,gLAAG,EAAEqS,IAAI,GAAKzS,SAAS,CAACyS,IAAI,CAAC,CAAC,CAAC,CAAC,CACpE;AAGI,MAAMxE,YAAY,IACvBN,MAAsD,GAEtD,IAAIlO,QAAQ,CACVb,OAAO,CAACqP,qMAAY,CAACN,MAAM,CAACzP,IAAI,CAC9BN,MAAM,CAACwC,gLAAG,EAAEqS,IAAI,GAAKzS,SAAS,CAACyS,IAAI,CAAC,CAAC,CACtC,CAAC,CACH;AAGI,MAAMzB,gBAAgB,IAC3B1L,CAAyE,GAEzE,IAAI7F,QAAQ,CACVb,OAAO,CAACoS,yMAAgB,EAAEd,KAAK,GAC7B5K,CAAC,CAAC4K,KAAK,CAAC,CAAChS,IAAI,CACXN,MAAM,CAACwC,gLAAG,EAAEqS,IAAI,GAAKzS,SAAS,CAACyS,IAAI,CAAC,CAAC,CACtC,CACF,CACF;AAGI,MAAMC,YAAY,IACvBxS,IAA+B,OAE/BhC,0LAAI,EAACgC,IAAI,EAAEgS,UAAU,CAACxU,KAAK,CAACiV,8LAAiB,EAAE,CAACP,KAAK,EAAEC,GAAG,GAAK1U,QAAQ,CAACiV,mLAAM,CAACP,GAAG,GAAGD,KAAK,CAAC,CAAC,CAAC;AAGxF,MAAMvN,GAAG,GAAA,WAAA,OAAG7G,0LAAI,GAepBuR,IAAI,GAAK3P,MAAM,CAAC2P,IAAI,CAAC,CAAC,CAAC,CAAC,EACzB,CACErP,IAA+B,EAC/BiP,IAAoC,EACpCzK,OAEC,GACwDmO,OAAO,CAAC3S,IAAI,EAAEiP,IAAI,EAAE,CAACjJ,CAAC,EAAE4M,EAAE,GAAK;YAAC5M,CAAC;YAAE4M,EAAE;SAAC,EAAEpO,OAAO,CAAC,CAC5G;AAGM,MAAMiM,OAAO,GAAA,WAAA,OAAG3S,0LAAI,GAexBuR,IAAI,GAAK3P,MAAM,CAAC2P,IAAI,CAAC,CAAC,CAAC,CAAC,EACzB,CACErP,IAA+B,EAC/BiP,IAAoC,EACpCzK,OAEC,GACkDmO,OAAO,CAAC3S,IAAI,EAAEiP,IAAI,EAAE,CAACjJ,CAAC,EAAE9G,CAAC,GAAK8G,CAAC,EAAExB,OAAO,CAAC,CAC/F;AAGM,MAAMP,QAAQ,GAAA,WAAA,OAAGnG,0LAAI,GAezBuR,IAAI,GAAK3P,MAAM,CAAC2P,IAAI,CAAC,CAAC,CAAC,CAAC,EACzB,CACErP,IAA+B,EAC/BiP,IAAoC,EACpCzK,OAEC,GACmDmO,OAAO,CAAC3S,IAAI,EAAEiP,IAAI,EAAE,CAAC/P,CAAC,EAAE0T,EAAE,GAAKA,EAAE,EAAEpO,OAAO,CAAC,CAClG;AAGM,MAAMmO,OAAO,GAAA,WAAA,OAAG7U,0LAAI,GAiBxBuR,IAAI,GAAK3P,MAAM,CAAC2P,IAAI,CAAC,CAAC,CAAC,CAAC,EACzB,CACErP,IAA+B,EAC/BiP,IAAoC,EACpC7J,CAAuB,EACvBZ,OAEC,GAEDA,OAAO,EAAEqO,UAAU,GACjBvD,QAAQ,CAACtP,IAAI,EAAE;QACbuP,KAAK,EAAEN,IAAI;QACXO,UAAU,EAAE5R,IAAI,CAACqN,kLAAK,CAAC;YACrBtK,SAAS,GAAGsI,KAAK,GAAKtK,aAAa,CAAC+Q,wMAAI,CAAChS,MAAM,CAACkD,sLAAS,CAACqI,KAAK,CAAC,CAAC;YACjE1D,SAAS,GAAGuN,KAAK,GACfnU,aAAa,CAACiS,yMAAK,CACjBhT,IAAI,CAACqN,kLAAK,CAAC;oBACTtK,SAAS,EAAEjD,MAAM,CAACkD,sLAAS;oBAC3B2E,SAAS,GAAGwN,MAAM,GAAKrV,MAAM,CAACoD,oLAAO,CAACsE,CAAC,CAAC0N,KAAK,EAAEC,MAAM,CAAC;iBACvD,CAAC;SAEP,CAAC;QACFnD,WAAW,EAAEhS,IAAI,CAACqN,kLAAK,CAAC;YACtBtK,SAAS,GAAGsI,KAAK,GAAKtK,aAAa,CAAC+Q,wMAAI,CAAChS,MAAM,CAACkD,sLAAS,CAACqI,KAAK,CAAC,CAAC;YACjE1D,SAAS,GAAGwN,MAAM,GAChBpU,aAAa,CAACiS,yMAAK,CACjBhT,IAAI,CAACqN,kLAAK,CAAC;oBACTtK,SAAS,EAAEjD,MAAM,CAACkD,sLAAS;oBAC3B2E,SAAS,GAAGuN,KAAK,GAAKpV,MAAM,CAACoD,oLAAO,CAACsE,CAAC,CAAC0N,KAAK,EAAEC,MAAM,CAAC;iBACtD,CAAC;SAEP;KACF,CAAC,GACFvR,OAAO,CAACxB,IAAI,GAAGgG,CAAC,GAAK9F,GAAG,CAAC+O,IAAI,GAAG2D,EAAE,GAAKxN,CAAC,CAACY,CAAC,EAAE4M,EAAE,CAAC,CAAC,CAAC,CACtD;AAKM,MAAMI,aAAa,IACxBhT,IAAsG,GACjD,IAAIT,QAAQ,CAACS,IAAI,CAAC;AAKlE,MAAM2L,KAAK,GAAA,WAAA,GAA+BxJ,cAAc,CAC7D,CAAC,EACD,CAAC7B,GAAG,EAAEG,KAAK,GAAKH,GAAG,GAAGG,KAAK,CAACa,MAAM,CACnC;AAGM,MAAM2R,QAAQ,GAAA,WAAA,GAA+BrT,OAAO,CAAC,MAAK;IAC/D,MAAMsT,OAAO,GAAkB,EAAE;IACjC,WAAOlV,0LAAI,EACTmE,cAAc,CAAgB,KAAK,CAAC,EAAE,CAACjD,CAAC,EAAEiU,KAAK,GAC7C5V,KAAK,CAAC2C,gLAAG,CAACiT,KAAK,GAAG7G,IAAI,IAAI;YACxB4G,OAAO,CAACpF,IAAI,CAACsF,MAAM,CAAC9G,IAAI,CAAC,CAAC;QAC5B,CAAC,CAAC,CAAC,EACLpM,GAAG,CAAC,IAAMgT,OAAO,CAACG,IAAI,CAAC,EAAE,CAAC,CAAC,CAC5B;AACH,CAAC,CAAC;AAGK,MAAMC,KAAK,GAAA,WAAA,OAA0CtV,0LAAI,EAAA,WAAA,GAC9DwU,YAAY,CAACpL,KAAK,CAAC,EAAA,WAAA,GACnBlH,GAAG,EAAEmD,KAAK,GAAKA,KAAK,CAAC,CAAC,CAAC,CAAC,CACzB","ignoreList":[],"debugId":null}}]
}